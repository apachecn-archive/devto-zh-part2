# 一种在 ReasonML Express Web 应用程序中处理错误的方法

> 原文:[https://dev . to/Mr Murphy/an-approach-to-handling-errors-in-a-reason ml-express-we b-app-1 o40](https://dev.to/mrmurphy/an-approach-to-handling-errors-in-a-reasonml-express-web-app-1o40)

当第一次开始在 ReasonML 中编写 Node.js 服务器时，开发人员可能会问自己“当出现问题时，我应该抛出异常吗？或者我应该将我的错误编码成数据并使用`Result`类型？”

在最初开发我正在开发的服务器时，我尝试了在出现问题时“抛出异常”的方法。我这样做是因为在请求执行的上下文中，为了返回响应，一切都必须进行得恰到好处。我想，如果出了什么问题，我们只要返回一个 500 就可以了。

但是我遇到了一些挑战:

*   错误很难追踪到源头。
*   错误很难与特定的请求联系起来。
*   当应用程序逻辑*想要直接处理一个失败的请求时，这感觉起来很困难。*

根据我和杰瑞德·福赛思在本期《理性小镇》中的对话:

[https://reason.town/13-error-handing-and-let-anything](https://reason.town/13-error-handing-and-let-anything)(大约 21:00 开始收听)

**异常是指紧急情况**(出现严重问题，整个服务器需要崩溃)。**结果是针对可能失败的事情**。这是 Rust 的方法。可以抛出异常，但是不能捕捉异常。

## 分解一下

在思考这个问题的时候，我意识到我需要把问题的空间分解得更大一些。我试图解决两个问题，只有一个例外；知道如何修复应用程序，知道告诉用户什么。然而，这些问题最好自己解决。它们可以用问题的形式来表达:

1.  作为一名人类工程师，当服务器出现意外故障时，我如何知道应该采取什么样的修复措施？
2.  当一个可能失败的任务确实失败时，*应用程序*如何知道该做什么？那我该怎么办呢？

## 1。知道该做什么

问题 1 的答案是:日志。当服务器上发生了意外情况，导致请求无法正常完成，而应用程序目前又无能为力来修复时，应用程序会向用户返回一个 500 错误。而且，重要的是，*会生成一个详细的日志，让程序员确切地知道什么失败了，在什么情况下失败了。*

这意味着服务器应用程序中的大多数日志都应该连接到一个请求。开发人员应该能够查看一个请求的生命周期的所有日志，并准确指出流程的哪个部分失败了(稍后将详细介绍)。

无法恢复的意外错误可能是服务器中最常见的错误处理情况(什么？这听起来不太对！).是的，为了使整个请求成功，请求生命周期中的大多数操作都需要成功。所以在大多数情况下，如果出了问题，应该会留下详细的日志，服务器应该会返回一个 500。

注意，这并不意味着你的服务器应该返回很多 500。你的服务器试图做的大部分事情应该在大部分时间*起作用*。

但这确实意味着，在大多数情况下，当你尝试失败时，你的应用程序除了返回一个 500 之外别无选择。

**应用程序应该留下详细日志并向上传播故障的示例:**

*   用户发送登录请求。
*   服务器散列用户的密码，并试图从数据库中取出存储的散列密码进行比较。
*   由于网络分区，数据库不可用。
*   应用程序会留下一个详细的日志，说明无法访问数据库。
*   服务器返回一个 500。
*   用户看到一个登录错误，说明服务器有问题。

在上面的例子中，应用程序自己无法修复网络中断。因此，它会留下一个包含足够信息的日志(调用了什么端点，尝试了什么操作，以及无法访问数据库)，然后告诉用户它无法完成操作。

## 2。让应用程序知道该做什么

问题 2 的答案是拥有一个将失败编码为数据的*数据类型*。按理说，`Belt.Result.t('data, 'error)`就是为了这个目的而存在的。如果可能失败的操作确实失败了，它可以向调用者返回一些数据，说明失败发生的原因。

但是接下来的挑战是知道如何处理新的故障信息。

当应用程序或用户可以对失败做些什么的时候，程序员应该使用关于为什么操作失败*的信息。*

**应用程序或用户可以对故障采取措施的例子**:

*   用户发送请求以获取一些信息。
*   作为身份验证步骤的一部分，服务器将用户的凭证转发给身份验证服务器，并期望得到用户对象的响应。
*   认证服务器返回失败，403。用户的凭据不正确。
*   应用程序没有记录错误并返回 500，而是向用户返回 401，告诉他们没有找到电子邮件和密码组合。

在上述情况下，应用程序知道用户凭证不正确(401)。它的逻辑路径会根据该信息进行切换。它没有继续获取用户信息，而是提前返回，通知用户凭证不正确。但是它不会记录错误消息。应用程序维护人员不需要知道用户的凭证不正确，因为应用程序维护人员对此无能为力。(但是，记录不正确的凭证响应的数量可能是好的。如果 401 响应突然激增，这可能是应用程序逻辑错误或数据丢失的症状。

## 知道何时记录什么

程序员如何知道她是否在代码中的某个地方，日志记录会有所帮助？当数据库失败时，她应该添加日志吗？或者当控制器 X 中调用数据库的函数返回失败时？还是在调用控制器 X 的控制器中？

她应该记录尽可能多的必要信息，以告知未来的程序员，如果她找到这些日志，需要修复什么。

例如，查找该日志可能没有太大帮助:

```
[ERROR] POST /users/login
DecodeError: expected "id" but found 'undefined' 
```

Enter fullscreen mode Exit fullscreen mode

看起来对数据库的一些调用解码失败了，但是不清楚哪个调用失败了。在这种情况下，她可能想提供更多关于失败的信息:

```
[ERROR] POST /users/login
DecodeError: expected "id" but found 'undefined'
Failed while trying to fetch the user's primary journal from the journal store 
```

Enter fullscreen mode Exit fullscreen mode

在这种情况下，程序员在解码错误发生时记录了这两个错误，因为她知道独立的解码器错误很难跟踪，并且她在试图进行调用的控制器中记录了日志。现在她知道哪个数据库调用正在获取意外的数据，并且知道问题出在解码器接收到一个没有“id”属性的对象，尽管它应该有一个。

## 在连接日志上发出请求

这可能是一个复杂的话题，值得一提。但简而言之，程序员需要为每个请求添加一个惟一的 ID，这个 ID 可以被添加到该请求产生的每个日志中。

在每个线程运行一个请求的阻塞语言中，请求 ID 可以分配给线程的全局内存，并从该线程的任何代码中读取。但是 Node.js 是单线程的，所以不能用那一招。

Node.js 中有几种方法可以解决这个问题:

*   [延续本地存储](https://github.com/othiym23/node-continuation-local-storage)这种方法试图将数据分配给一个函数中的内存，该函数在请求开始时被添加到调用堆栈中，并允许该函数触发的所有代码访问同一个内存。这是一个好主意，但是据说当使用外部库时，相对容易丢失上下文。
*   将一个对象向下传递给所有函数在这种方法中，程序员创建一个 logger 实例，在请求开始时用请求 ID 作为任何日志的前缀，并将该 logger 实例向下传递给请求生命周期中调用的所有函数。在请求过程中写入的任何日志都使用传递下来的 logger 实例。这种方法简单明了，但是执行起来又麻烦又痛苦。
*   从所有函数向上传递日志这与前面的方法类似，只是日志是在请求执行期间收集并向上传递的。当请求完成时，中间件一次写出所有的日志，包括它们各自的时间戳和请求 ID。这种方法也可能很笨拙，但是创造性地使用数据类型可以使它变得简单一些。

## 结论

服务器应用程序中记录或处理错误的方式可能会影响开发人员的维护体验。需要一种原则性的错误处理方法，以允许开发人员快速找到并修复服务器错误。理想情况下，这种方法:

*   将日志记录与失败的操作分开
    *   日志是为开发人员准备的
    *   失败数据是针对应用程序和用户的
*   将一个请求的所有日志与一个唯一的请求 ID 组合在一起，使开发人员可以在一个请求中看到事件的逻辑进展

按理说，`Result`数据类型非常适合在需要时将故障转化为可用数据。现在为一个请求将日志分组并不是一件非常容易的事情。看起来开发者将不得不选择相对不可靠或者更复杂的代码。