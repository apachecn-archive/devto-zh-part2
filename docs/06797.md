# 保持 ADO Sql 连接的安全

> 原文:[https://dev . to/jamesmh/keeping-your-ado-SQL-connections-safe-3b4j](https://dev.to/jamesmh/keeping-your-ado-sql-connections-safe-3b4j)

*注:[见我博客](https://www.blog.jamesmichaelhickey.com/keeping-ado-sql-connections-safe/)的规范帖子 T3】*

如果你不闭上你的。NET `SqlConnection` s？不好的东西。糟糕的东西将不可避免地把你的 IIS 网站弄得灰飞烟灭。良好的...差不多吧。我们都知道，我们应该格外小心，总是**关闭**我们的数据库连接。对吗？

但是，当开发人员试图对他们的数据库连接着迷，更关注能够重用开放的数据库连接而不是安全性时，会发生什么呢？几周前，后果降临到我头上。

让我(简要地)解释一下发生了什么，什么样的*可能会发生在您身上，以及修复它的方法——同时保持重用开放数据库连接的灵活性，并能够从您的 C#代码中安全地使用数据库事务(使用 ADO)。*

# 当漏接发生时

在我日常工作中使用的代码库中，有一些用于执行 SQL 查询的实用程序(嗯...调用存储过程)。当我第一次看到这段代码时(几个月前)，我立刻认为这不是一件好事(并把我的想法告诉了团队)。

为什么？因为错误处理 DB 连接会导致非常糟糕的事情。安全总比后悔好。但是，这不被认为是一个问题——它从来没有引起任何问题。到目前为止，它运行良好。所以，这不值得大惊小怪——除了公开我的担忧。

问题中的模式是这样的:

1.  接受一个`SqlConnection`作为参数的方法。
2.  检查`SqlConnection`是否已经打开。如果是，不要关闭它，因为调用者希望它保持打开，以便发出进一步的查询。
3.  如果`SqlConnection`是关闭的，打开它，然后运行查询，然后关闭它。

代码可能是这样的:

```
if (cmd.Connection.State != ConnectionState.Open)
{
    cmd.Connection.Open();
}

// Do your stuff...

if (origConnectionState == ConnectionState.Closed)
{
    cmd.Connection.Close();
} 
```

Enter fullscreen mode Exit fullscreen mode

是的，没有 try 块。

# 当这一切摇摇欲坠

几周前，我们遇到了重大问题，我们的网站一直对所有人锁定。长话短说——代码正在调用一个不存在的存储过程，DB 调用抛出了一个错误，调用代码(碰巧！)默默地抓住了错误，继续突突前进。

因为代码试图对连接进行修饰——当抛出错误时，它会绕过应该关闭连接的代码。通常，像这样的异常会在开发过程中被捕获(并修复)。

但是当事情没有被彻底测试时会发生什么呢？调用者正在悄悄地捕捉错误？嘣！

用户没有看到错误。直到所有未关闭的连接堆积起来。

这花了一整天的时间来找出问题的来源，因为这个异常是被无声地捕捉到的！最终，查看 IIS 日志和事件查看器给了我们一些线索。我在我值班的最后十分钟发现并解决了这个问题。唷！多么混乱！

# 为什么这样做？

为什么会有人这么做？原因是这个方法的调用者可能想要发出多个查询。我们不必打开和关闭多个`SqlConnection`,我们可以通过保持一个打开并在所有查询完成后自己关闭它来提高性能。避免额外重新连接到数据库将被避免。

实际上，在整个代码库中，甚至没有一个*调用方重用打开的`SqlConnection`的*实例。:(

# 但是。NET 为您处理 ADO 连接！

这个*真的会让*提升性能吗？不完全是。默认情况下，。NET ADO 连接被[共享](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql-server-connection-pooling)。这意味着在 DB 连接上调用`Close()`并没有*真正地*关闭它(物理上)。

。NET 在幕后处理这个问题，并保持一个活动连接池。获得的任何性能优势很可能仅仅是在内存中实例化一个新的 c#对象的成本和在池中查找连接的成本。连接到数据库的**实际命中**很可能不会获得。

> 经验法则:如果性能是一个问题，测试真实场景。然后，在相同的场景下测试您的优化并进行比较。

# 是谁的责任？

这里还有一个问题。谁负责管理“低级”数据库访问？在上面的代码中——它是:

1.  低级数据库实用程序
2.  以及任何想使用它们的人！

因此，本质上，您可以让一个 MVC 控制器创建一个`SqlConnection`，将它传递给实用程序来执行查询，然后关闭控制器动作内部的连接。

但那不会发生，对吧？嗯，有时候我们继承的代码确实会这样做。:(

> 这就像去一家机械修理店，请他们修理你的汽车，却给他们**你的廉价工具来修理汽车**。

上面的代码也是如此。较低级别的数据库对象应该始终拥有该域/职责。别人不应该告诉他们如何管理他们的数据库连接。

# 做什么。怎么办。

如果我们想的话，我们怎么能安全地重复使用 open s 呢？

在同样的代码库中，我介绍了使用 [Dapper](https://github.com/StackExchange/Dapper) 来取代数据库访问。无论如何，Dapper 比手工制作的迷你对象映射器快 5 倍以上。那是另外一个故事了。

结合这些变化，我创建了一些方法，允许我们安全地使用`SqlConnection`s——但保留了连接重用的灵活性和使用事务的能力。

在过去的一篇文章中，我解释了如何使用高阶函数来封装重复的代码，同时允许你的代码“肉”被传入。我什么意思？

举个例子，一个拥有方法`UsingConnectionAsync`的`Query`类可能会这样使用:

```
await _query.UsingConnectionAsync<int>(
    async con =>  
    {
        var result1 = await con.ExecuteAsync(sql1, parameters1); // ExecuteAsync comes from Dapper
        var result2 = await con.ExecuteAsync(sql2, parameters2);

        return PutTheResultsTogether(result1, result2);
    }
); 
```

Enter fullscreen mode Exit fullscreen mode

这种方法接受一个将被赋予一个`SqlConnection`的函数。该函数可以任意使用那个`SqlConnection`。一旦完成，高阶方法`UsingConnectionAsync`将设法“神奇地”(在某种意义上)关闭连接。

我们可以将所有与数据库相关的代码包装在一个“范围”内，做我们想做的事情。它既安全又灵活。

您可以创建另一个方法`UsingTransactionAsync`，该方法将设法打开一个`SqlConnection`，启动一个事务，并在提交成功的使用时回滚错误。

这里有一个要点，展示了实现这些方法的一种方式。T3】

# 结论

希望这个现实世界的危机会鼓励你去思考你的`SqlConnection`对象是如何被管理的。特别是在旧的“遗留”应用程序中(是的，我们都必须处理它们)，您可能会看到这种优化数据库连接的尝试。

请记住:

*   安全起见，将低级职责放在一个地方。DB 连接管理和查询逻辑不是一回事。
*   即使代码显然没有引起直接的问题——如果它看起来很糟糕，它可能很糟糕。安全总比后悔好。
*   高阶函数是封装一个域/对象的职责的好方法，同时允许调用者灵活地使用这些托管资源。

# 保持联系

别忘了在 [twitter](https://twitter.com/jamesmh_dev) 或 [LinkedIn](https://www.linkedin.com/in/jamesmhickey/) 上联系我！

# 导航您的软件开发生涯

一封电子邮件简讯，我将在其中回答订阅者的问题，并就以下主题提供建议:

✔:软件开发人员的一般阶段是什么？✔:我怎么知道自己处于哪个阶段？我如何进入下一阶段？
✔什么是技术领导者，我如何成为一名技术领导者？

听起来有趣吗？加入社区吧！