# 服务概念:我们如何以及为什么在服务中构建服务

> 原文:[https://dev . to/lei bole/service-ception-how-and-why-we-ve-build-a-service-inside-a-service-17g](https://dev.to/leibole/service-ception-how-and-why-we-ve-built-a-service-inside-a-service-17g)

微服务架构之路:在服务中创建服务

### [](#introduction)**简介**

在 Yotpo，我们运行着一个非常大规模(每天数千万次请求)的网络系统。我们将产品运送到电子商务网站，每个网站都有自己的购物者规模，我们为所有这些网站提供服务。

我们向客户提供的产品之一是用户生成的图像(由购物者创建的图像)。我们最近开始开发一种新产品——相册小部件。在这个小部件中，店主可以选择他们的购物者上传的图像，并在现场小部件上显示这些图像。此外，我们将允许他们对 instagram 上的图片进行审核并添加到相册中。

图像、专辑和专辑创作体验都将由 Yotpo 开发和提供。显然，该产品需要大量的后端实体和代码，它们将与我们现有的代码库的其余部分一起使用。

在下面的帖子中，我们将尝试描述我们如何在开发过程中保持面向服务的方法，同时使用相同的代码库和相同的过程。我们将讨论我们做了什么，为什么要这么做，以及我们在这个过程中发现的方法的优点和缺点。

### [](#the-problem)问题

没有人能忽视最近围绕“微服务”架构的疯狂炒作。描述架构的优点超出了本文的范围。可以说，我们目前拥有的少数服务已经增长到了巨大的比例，作为开发人员，我们的目标是避免向它们添加任何新代码。相反，最好编写尽可能与现有服务分离的新的小型服务。

然而，创建一个新的服务对任何人来说都有相当大的开销。这意味着创建一个全新的部署过程、存储库、数据库、工具链等等。R&D 项目的时间限制总是非常紧迫，产品团队经常不得不放弃许多功能内容来满足它们。

开发人员不断寻求一种方法来保持长期的面向服务的策略，同时仍然保持紧张的时间表。

[![](../Images/9a5a13529d0543911d7a150f68450609.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--xuOMRqAf--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2Asn1L_Ns5eehJaVoPfAFS1A.jpeg) 

<figcaption>有朝一日该是什么样子</figcaption>

### [](#the-proposed-solution)提出解决方案

那么如何面对这个问题呢？对我们来说，一个折中的解决方案是可行的:扩展现有服务之一，即“社交媒体服务”(用于从 instagram 获取媒体)。

但是，仅仅通过添加新的控制器和模型并不能有效地实现这一点，我们知道这是一种很好的老方法。重要的是要确保所有的新行为都在一个单独的流程中，以及一个单独的文件夹结构中。新添加的代码应该获得一个新的名称，并被视为一个完整的独立服务。这种分离可能看起来是“语义上的”和强加的，但是保持这种分离有助于保持新的“服务中的服务”尽可能与现有的服务分离。

该解决方案将面向服务的架构作为其指导原则，同时避免了与创建新的微服务相关的大部分开销。

### [](#challenges)挑战

在开发过程中，我们显然面临一些不可预见的挑战。最有趣的是:

**服务间通信**

新的(相册)服务和旧的(社交媒体)服务仍然需要相互通信。

例如，相册可以包含来自社交服务的图像。每当有对相册的请求时，它将需要返回其社交图像的数据。这些数据存在于社交图片服务中。

在这一点上，混合服务是非常诱人的。例如，在相册服务的控制器中使用来自社交媒体服务的模型。为了避免这种情况，我们引入了一个新的实体来防止这种耦合——social images provider。

这个实体将是从相册服务到社交图像服务的唯一通信点。如果我们决定将其中一个服务提取到一个单独的微服务中，那么 SocialImagesProvider 将是唯一需要重新实现的实体。

**外部服务通信**

与外部服务的沟通也很困难。就像相册可以包含社交图片(来自 instagram)一样，它也可以包含用户生成的图片。同样，当请求包含用户生成的图像的相册时，相册服务需要获取图像的数据。只是这一次，数据不在它的兄弟服务中，而是在我们的其他服务中。

这基本上需要执行服务间连接，以便获得所有图像的细节。这个连接很复杂，因为它包含两个服务，并且不是很可靠。随着我们继续扩展我们的应用程序，我们将需要很快重新考虑这个实现。

### [](#advantages)优点

在旧服务中编写新服务有很多好处，其中包括:

*   使用单个数据库:这节省了部署和维护新数据库的时间。新服务的表是与现有表完全不相关的新表。
*   已知和熟悉的代码:代码库、架构、数据库等等都是项目的所有开发人员所熟悉的，所以不学习新的编程语言/架构/数据库仍然有可能快速前进。
*   服务内部通信:两个兄弟服务可以有效地相互通信:它们基本上运行在相同的进程上。
*   未来提取微服务容易:新服务定义良好，与现有服务分离，因此未来将其提取到单独的微服务(相对)容易。
*   解耦:新服务与旧服务解耦，因此两个服务可以独立前进。可以对其中一个进行更改，而不用担心另一个。此外，服务的边界非常清晰，所以它保持得足够小，更容易被开发人员完全掌握。
*   没有“新的服务开销”。

### [](#disadvantages)缺点

*   服务必须一起部署:即使一个服务的变更独立于另一个服务，部署仍然是联合的。如果其中一个服务中断，另一个也会中断。
*   一些耦合是不可避免的。
*   项目仍然变得更大:原始服务仍然在增长，代码库变得更大且更难完全掌握，数据库显著增长。

### [](#conclusions)结论

在这篇文章中，我们描述了我们开发一个新的有意义的特性的方法，同时试图在紧张的时间表和新的架构方法——微服务之间保持平衡。

我们选择的道路——服务与服务——有优点也有缺点，就像任何其他道路一样。开发和部署进行得非常顺利，产品的启动和运行令我们的客户满意。

在我们不久的将来的路线图中，新的服务将被提取出来，并被赋予它自己的生命，拥有新的数据库、部署和伴随分离的微服务的一切。

* * *