# 领域驱动的灾难

> 原文：<https://dev.to/cheetah100/domain-driven-disaster-147i>

有多少企业仍在使用电子表格作为其业务运营的一部分？现实情况是，它们甚至在跨国公司的最高层也被使用。这是某种意外吗？他们没有收到关于他们所带来的安全风险，他们的局限性，他们的复杂性的备忘录吗？

电子表格仍然存在，因为它们将适应和发展的权力交到了最需要的人手中。电子表格用户不会每周都去敲 IT 部门的门，要求在 Excel 中添加新功能，以便完成工作。无论他们在哪个领域工作，他们都有能力做他们需要做的事情。

但是专业的信息技术人员知道得更多，或者说他们是这样认为的。他们希望编写从头开始设计的软件来完成特定的狭义工作。它从基石开始，即数据结构和模式，在此基础上构建对象模型和对象关系映射。开发人员将业务逻辑直接构建到这些领域特定的业务类中。

最近的发展是微服务，其中系统被分解成具有明确定义的功能子集的独立的迷你应用程序。这是一个类似于用类封装的概念，因为每个类都有一个定义良好的契约，并且只有契约对外部可见。此外，微服务与系统的领域特定方面相关。

模块化和清晰的关注点分离是复杂系统的一个关键部分，它允许你将应用程序分解成具有明确职责的部分。但是我们应该围绕特定的业务领域来设计我们的模块架构吗？答案是断然的不！

### 僵化的建筑

领域驱动开发是个坏主意的第一个原因是，它鼓励你在应用程序中构建业务逻辑。想象一下，如果数据库软件是特定领域的，数据库语言只适用于一个行业。想象一下，每个行业都有不同的数据库，而不是一个允许在其上构建各种不同系统的标准。数据库服务器是一个好的架构设计的例子，其中它们存储数据的目的不会与数据库将用于的领域混淆。

在你的软件中构建不必要的领域级业务逻辑只会导致软件更加脆弱，更不适应变化。想想电子表格，用户可以实时修改它的工作方式，添加新的字段或新的图表。您的应用程序用户可以添加新字段吗？他们可以创建新的报告和查询吗？电子表格从不需要重建或重新部署。不需要仅仅因为添加了一列就重新构建和重新部署数据库。但是商业软件开发人员已经被灌输使用固定模式静态领域模型。但是事情不需要这样。

### 领域衍生模块

随着微服务的出现，我们似乎正在制造与早期 Java EJB 技术相同的混乱，因为它试图通过根据服务合同来拆分服务来进行扩展。假设你有客户、供应商和合作伙伴。每个实体都有不同的字段和业务规则。经典的方法是在数据库中为每个对象建立单独的表，为每个对象建立单独的类，这些类将被映射到表中，并为每个单独的对象公开 web 服务。

微服务方法更进一步，将系统分解为独立的应用程序。也许所有这些实体最终都将成为独立的服务，运行在不同的容器上，与它们自己的数据库对话。可预见的结果是，尝试跨多个服务创建累积数据集是一场噩梦。采用这种方法的一个常见理由是可伸缩性，但实际发生的是服务调用服务的迷宫，一直在增加延迟。

当人们开始构建真正的系统并遇到这个问题时，通常会发生的情况是，权威人士进来告诉他们，他们做错了。他们不太明白唯一的正确道路。看起来我们的专家从来没有真正评估过基于领域拆分架构是否是一个明智的想法，或者使用领域作为应用程序边界的基础是否是明智的。

### 疾病的根源

面向对象编程的入门书籍经常使用真实世界的对象作为例子。它鼓励开发人员用代码来模拟现实世界。我知道他们可能是出于好意，但这样做是向现代开发人员灌输了业务领域属于二进制的思想。

虽然数据库本身很聪明地具有通用性，但它们同时也期望定义一个静态模式，这在现实中与任何二进制文件一样不灵活。随着软件的更新，试图保持数据结构最新的混乱是开发人员的共同经历。这不完全是他们的错；毕竟，流行的语言鼓励将数据库和代码绑定在一起。

### 好吧，聪明的木屐，答案是什么？

对于现代软件架构方法的失败，这是一种很好的抒情方式，却没有提供一些其他方法的工作示例。谴责一种方法而不提供替代方案是没有建设性的。因此，我基于将代码从领域中分离出来的想法，给出了下面的案例研究。

2006 年，我从事医疗保健数据集成应用程序的工作。这听起来很特定于领域，但是健康特定功能是系统的很小一部分，主要限于医院和医疗保健提供商使用的协议的几个连接器。系统的其余部分是一个通用集成引擎，可以为任何需要集成不同系统的公司工作。

这个应用程序是一种叫做 OSGi 的技术的极好例子，这种技术将应用程序分成不同的关注点。没有一个核心模块与健康有关。所有这些都有明确的定义，并有合同或 API。这些模块基于应用程序所需的功能，但是路由和转换的实际配置都是动态配置，用户可以在没有部署的情况下实时修改。重要的是，这些模块没有受到预期领域的任何影响。这种领域独立性会影响我后来的经历。

在随后的工作中，我为一家互联网服务提供商编写了一个流程编排系统。最初，我被请来完成一个项目，这个项目是以与领域紧密结合的方式开发的。过了一段时间后，我们发现它太不灵活了，我们需要一个不同的解决方案。因此，我们为另一个系统开发了一个计划，该计划将解决第一次尝试的架构缺陷。

我们为新项目采用的关键架构原则之一是普遍性。该域将从应用程序中退出并进入配置。这个项目永远不会是特定领域的。我们不会在不考虑适应性或灵活性的情况下，为了解决眼前的需求而修改它。完成核心功能的第一个版本花了三个月，完成插件和编写业务流程的动态配置又花了三个月。

就像医疗保健集成应用程序一样，我们最终得到了一个通用系统。它能够处理任何业务流程的工作流自动化需求。很快，我们比以往任何时候都更快地开发新的业务流程。工作流引擎是作为开源发布的。

今天，它正被成功地用于一个完全不同于最初开发目的的领域。具有讽刺意味的是，它正在取代电子表格，因为虽然它有电子表格的许多灵活的功能，但它也是安全的，集中的和易于使用的。它提供了电子表格中常见的灵活性和适应性，同时在源代码级别上与业务领域完全分离。该域处于运行时配置中。

### 复杂性是可伸缩性和可用性的敌人

让我们做一个小小的思考实验，看看如何基于两个竞争模型进行扩展；功能架构和领域驱动架构。在功能架构中，我们有三个 web 服务器，前面是一个负载平衡器和一个由三个数据库服务器组成的集群。web 服务器的功能是服务 API 调用。数据库集群的功能是将数据存储在跨所有三台服务器复制的单个逻辑数据库中，而不考虑 API 调用。

在域架构中，我们有一个路由器，它根据所需的服务将 API 调用路由到不同的 web 服务器。这些 web 服务器中的每一个都连接到一个数据库服务器来存储该服务的数据。

因此，让我们考虑一下这两个系统中的可伸缩性和可用性。假设有一个数据库服务器发生了磁头崩溃。在功能性架构中，其他两个服务器接管，一切正常运行，而损坏的服务器恢复服务。领域驱动架构会发生什么？其中一个 API 将完全离线。不仅如此，您还需要从备份中恢复数据库服务器，这可能会丢失数据。

好吧，但是领域驱动架构对于扩展来说肯定更好吗？让我们考虑一下。使用域驱动架构，特定服务的所有命中都将到达相同的服务器。这意味着，如果你很不幸地在一个特定的 API 上有所进展，它将会过载。但是使用功能架构，任何 web 服务器都可以服务于任何呼叫，并且负载分布在多个 web 服务器和数据库服务器上。

如果你有多个相互依赖的服务，我甚至无法想象你会陷入什么样的困境。我们需要既普遍又明确的服务。“应用程序”应该是一个动态的单板。

### 你的解决方案只是糟糕的老式整体架构吗？

一点也不。整体架构试图将所有领域特定的规则包含在其自身中。

想象一下电子表格的所有用途。电子表格包含了它们所带来的所有固有的复杂性吗？不。我在这里建议的是，我们将应用程序从域中分离出来，并使用户体验成为数据运行时配置的结果。

这和电子表格使用的模型是一样的，但是我们在网络上的商业软件中使用了这个原则。我们不应该在代码中构建业务规则和领域实体。这个域仍然需要存在，但是它可以从代码中被驱逐到动态运行时配置中。这是思维方式的根本转变。

### 总结领域驱动开发的案例

将业务逻辑和规则放入应用程序中是不变的。它削弱了管理人员以开发人员可能想象不到的方式使用软件的权力。有多少公司有这样一种文化，经理和用户总是与软件开发人员发生冲突，因为作为软件部署的一部分，任何和所有的变更，无论有多小，都需要被设计、计划和推出。在这种情况下，经理们死抓着他们心爱的电子表格不放有什么奇怪的吗？

这不仅仅是一个设计原则，它是一个关于开发者和用户之间关系的基本哲学；我们应该授权给用户，而不是制造障碍。我们不应该抓住城堡和领地的钥匙不放，而应该让它们自由。