# 行走的世界

> 原文:[https://dev.to/dick1marine/the-walking-dom-1df](https://dev.to/dick1marine/the-walking-dom--1df)

本周，作为学习 React 的前奏，我研究了虚拟 DOM，并尝试使用 JavaScript 对象创建自己的虚拟 DOM。这是一个很好的练习，它帮助我理解 React 创建了浏览器的文档对象模型(DOM)的虚拟副本，并在写入实际的 DOM 之前使用它进行操作，但我不完全确定为什么这样做有意义。

经过一些思考(以及与 Code Chrysalis 的人的一些交谈)，我可以看到它的优势。

我意识到的第一件事是，操纵 DOM 的方法不止一种，不同的浏览器在调用同一个 [JavaScript](http://techandhumanity.com/javascript/creating-custom-scrollpane-using-javascript) 时会有不同的表现。无需深入细节，我可以接受更新 DOM 有好有坏的方法，其次，更新 DOM 可能是一个昂贵的操作。

或者换句话说，

更新 DOM 可能会很慢。但是虚拟 DOM (vDOM)有什么帮助呢？如果我们在 vDOM 中捕获所有的更改，然后更新 DOM，更新速度会不会同样慢？

由于我的数据库背景，它帮助我将 DOM 理解为写入磁盘，而将 vDOM 理解为写入内存。写入磁盘是一项非常昂贵的操作，在将数据提交到磁盘之前，最好使用内存来存储我们想要操作的数据。

请允许我解释使用僵尸。

我创造了一个游戏，我们可以杀死僵尸，但僵尸当然会复活。这是他们的全部。忘记游戏的机制，但在我的网页上，我只想显示还剩下多少僵尸。一开始我们有 100 个僵尸。

我们的第一个案例是一个单一的变化。我杀了一个僵尸，然后更新我的 vDOM 来存储 99 个僵尸。我检查了差异，现在我需要更新真实的 DOM 来显示这一点。

我在这里没有节省任何费用。也许 React 的黑盒比我更知道如何更新 DOM，但是对于这样一个简单的改变，不会有太多的节省。

现在我有 99 个僵尸，但我还没完。我是一个平庸的僵尸杀手，当我杀死另一个僵尸时，第一个僵尸已经复活了。当我杀死一个僵尸时，我更新我的 vDOM 来反映这一点(只剩下 98 个僵尸)，但是第一个僵尸复活了，使我的计数回到 99。我再次更新 vDOM。我检查了我的 vDOM 差异，因为没有什么真正改变，所以我不需要更新实际的 DOM。我可以让它保持原样。

我减少了 100%的 DOM 操作！

现在一个更复杂的情况是，我开始杀僵尸，我设法杀他们快一点，但随着游戏的进展，他们也更快地复活。在 vDOM 中，我的更新可能如下所示:

Kill:100 => Kill:99，Ki3ll:99 => 98，Kill: 98 => 97，重生:97 => 98，Kill:98 => 97，重生:97 => 98，重生:98 => 99，Kill: 99 => 98，重生:98 => 99，重生:99 => 100，脑浆被吃掉:100 => 101

我的 vDOM 有 11 次更新，但这一切发生得如此之快，以至于当我检查我的差异时，我只需要更新 DOM 一次。

vDOM 的另一个可能的优势是使事情变得更简单。

除了我在写入磁盘(实际的 DOM 渲染)之前更新内存(vDOM)所看到的节省之外，我还可以编写我的虚拟 DOM 对象，以便它知道僵尸以及当僵尸被杀死时该做什么。在现实世界的例子中，僵尸是特定类型的 html 元素，但我认为这也适用。

我期待着在接下来的几周里了解更多关于虚拟 DOM 和 React 的知识。当然，前提是我能在即将到来的僵尸末日中幸存下来。