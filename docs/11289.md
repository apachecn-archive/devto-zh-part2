# 了解服务人员的生命周期

> 原文:[https://dev . to/achiengcindy/understanding-the-service-worker-life cycle-47 D5](https://dev.to/achiengcindy/understanding-the-service-worker-lifecycle-47d5)

理想的用户体验是不间断地访问互联网上的信息。不幸的是，即使有了高速连接，我们仍然会遇到延迟。

让我简单解释一下，为了在屏幕上获得我们需要的信息，我们通过网络发送请求并等待响应。但是，如果网络繁忙，或者某个地方的代理配置错误，或者由于任何原因无法访问互联网，这可能是真的，我们必须等待很长时间，怎么办？

这对大多数用户来说是令人沮丧的。

但是有一个解决方案，构建 web 应用。

##### [](#but-how-do-achieve-offline-experience-)但是如何实现线下体验呢？

为了实现线下体验，我们需要注意:

1.  **缓存资产**。浏览器存储静态资产，如 html、css、图像。以便在下一次需要时，从浏览器缓存中取出它们。网络故障时的大问题。
2.  **在客户端存储数据**。Html 5 带来了离线技术的好消息，如网络存储、索引数据库等，使您可以在用户设备上本地存储数据。

##### [](#application-cache)应用缓存

[应用程序缓存](https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache)(警告:它已被否决)
尝试解决**缓存**的问题，允许您指定您希望浏览器缓存的资源集并享受离线浏览，通过缓存资源提高速度`locally`(不需要网络旅行)，并降低服务器负载(浏览器只下载服务器上已更改的资源)。)

当用户与网络断开时有用，但是它实现了它的承诺吗？阅读 [API 是一个混球](http://alistapart.com/article/application-cache-is-a-douchebag)

### [](#service-workers)服务人员

服务工作器是一个脚本(javascript 文件)，浏览器在后台运行，充当应用程序和网络之间的代理。

服务工作器使应用程序能够拦截请求，然后修改响应，缓存这些请求以提高性能，并提供对缓存数据离线访问，这使数据变得可靠。

Service worker 是一种类型的 [web worker](https://html.spec.whatwg.org/multipage/workers.html) ，运行在独立于网页和 UI 的线程上，使它们能够在没有活动浏览器会话的情况下工作。

它不能访问 DOM，而是通过`post message`与页面通信，如果需要，这些页面可以操作 DOM。

它让你完全控制你的应用程序的行为，特别是当网络不可用或速度慢。

这种控制是服务工作者只在 https 上运行的原因，以避免中间人攻击，尽管本地请求是一个例外——在开发期间没有必要

*   预期用途是创建离线的第一次体验
*   拦截网络请求并根据网络可用性处理响应，
*   体验慢速连接时的在线优势
*   允许访问推送通知和后台同步

服务工作者让您以不同于缓存的方式处理网络请求。
服务人员围绕着最新的 WebAPI

1.  获取当通过网络请求资源时，触发一个**获取**事件。执行标准请求，即让我们能够在发出网络请求之前查看缓存。在服务工作器内部，允许拦截请求，然后修改请求对象以外的内容。使用`respondWith()`告诉浏览器我们将处理请求
2.  缓存 API。**缓存 API** 独立于网络状态或浏览器缓存。它让您可以控制如何以及何时进行缓存。除非明确请求，否则它不会更新缓存中的项目。缓存中的项目不会过期，它们会在您删除旧缓存时消失。

### [](#service-worker-lifecycle)服务人员生命周期

*   登记
*   安装
*   使活动

##### [](#registration)登记

要使用服务人员，您必须注册并定义其范围。

注册将告诉浏览器服务人员的位置，并开始在后台安装它。

放置在`sw.js`中的服务人员注册代码

```
 navigator.serviceWorker.register('/sw.js').then(function(){
      console.log('Registration worked!');
    }).catch(function() {
      console.log('Registration failed!');
      });
    }; 
```

一个服务人员回报了一个承诺。如果承诺得到解决，则注册成功，否则新服务工作者的注册失败。

**浏览器支持**

由于一些浏览器还不支持服务人员[服务人员准备好了](https://jakearchibald.github.io/isserviceworkerready/)，通过将服务人员包装在`if statement`中来执行特性检查。

```
if (!navigator.serviceWorker) return;
navigator.serviceWorker.register('/sw.js').then(function() {
    console.log('Registration worked!');
}).catch(function() {
    console.log('Registration failed!');
});
};
```

**范围**

范围定义了服务人员控制的页面。默认范围由服务工作者脚本的位置定义。这意味着如果你在根文件夹中注册一个服务人员，没有必要定义它的范围，因为它控制所有的页面。

```
navigator.serviceworker.register('/sw.js', {
    scope: '/'
});
```

> 浏览器不会重新注册现有的服务人员，但会返回一个现有注册的承诺

##### [](#installation)安装

一旦浏览器注册了服务人员，如果浏览器认为服务人员是新的，则立即`downloaded`

1.  该服务人员以前从未注册过。或者
2.  你修改了服务人员的脚本，字节差异。

`install event`被开除。

这是一个从网络获取资源并缓存它们的绝佳机会，这些资源构成了应用程序外壳。非常适合我们网站所依赖的静态资源，如 Html、Css、字体、Javascript 等。

如果有先前版本的服务工作程序已经在运行，它仍将继续为页面提供服务。在安装阶段完成之前，浏览器不会让新的服务人员接管控制权。相反，它变成了等待的下一个版本。

为了**延迟**的安装过程并确定其**成功**，我们通过一个**承诺**到`event.waitUntill`的方法。

如果承诺兑现，浏览器知道安装已经完成。如果它失败了，那么它就被丢弃了。无需担心，因为先前版本的服务人员仍在工作。

这确保了在任何给定时间只有一个版本的脚本在运行。

```
self.addEventListener('install', function(event) {
  event.waitUntil(
     );
   }); 
```

##### [](#activation)激活

一旦服务人员成功完成安装阶段，就会进入激活阶段。

在浏览器第一次遇到服务人员的情况下，服务人员在成功完成安装阶段后变得活跃，并且将能够控制新的页面加载。然而，它不能控制已经被加载的页面。为了控制已经加载的页面，需要重新加载。

在服务工作者被更新的情况下(不是浏览器第一次与服务工作者交互)，新安装的服务工作者不能取得控制，直到先前安装的服务工作者的所有页面被关闭。

一旦使用旧的(以前安装的)服务工作器的所有页面都消失了，新的服务工作器就被激活，触发一个激活事件。

> 一旦被激活，你可以通过在你的服务人员中调用`clients.claim()`来控制不受控制的页面

```
self.addEventListener('activate', function(event){
});
```

由于以前的版本已经过时，现在是删除旧缓存的最佳时机，这样所有用户都可以使用我们站点的当前版本。

**抓到你了**

我们一直在换文件！当我们在我们的文件(比如 css 文件)中进行更改时，这可能会成为一个“问题”。页面重新加载不会有太大帮助，因为我们仍然使用旧 css 的缓存。

尽管我们的 css 文件发生了变化，我们的网站仍然保持不变。也就是说，为了看到变化，我们对服务人员脚本进行了更改，您可以简单地添加注释，记住这只是一个字节的差异，浏览器会将其视为“新的”

### [](#notes)备注

1.  服务工作者不提供仅用于脱机使用的缓存数据，但在联机连接缓慢时也有效。
2.  服务工作者是可编程的 JavaScript“仆人/工作者”
3.  它们不能直接访问 DOM，而是通过`postmessage`响应消息与它控制的页面进行通信。
4.  要求网站通过 https 提供服务。这一点很重要，因为它们可以拦截请求并修改响应，从而避免被第三方劫持
5.  不使用时保持空闲，下次需要时重新启动
6.  大量使用承诺

**延伸阅读:**

1.  [服务人员介绍](https://developers.google.com/web/ilt/pwa/introduction-to-service-worker)

2.  [Jake Archibald](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)

### [](#conclusion)结论

感谢您的阅读，希望您准备好给用户一个在线和离线的惊人体验。让我知道如果喜欢这篇文章，或者如果我错过了什么！

[在 twitter 上与我联系](https://twitter.com/achiengcindy1)