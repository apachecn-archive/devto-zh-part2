# 解释负载平衡器

> 原文:[https://dev.to/slavius/explaining-load-balancers-from-30cb](https://dev.to/slavius/explaining-load-balancers-from--30cb)

## [](#preface)前言

这原本是作为对**[# Explain Like im Five](https://dev.to/t/explainlikeimfive)**-[的评论，解释了像我五岁这样的负载平衡器](https://dev.to/slavius/comment/500e)，但是我决定把它转换成一篇小的解释文章。

## [](#load-balancers-are-all-about-scaling)负载平衡器都是关于扩展的

一般来说，有两种缩放类型:

*   **垂直** -您不断向您的*单系统*添加资源，直到您耗尽空间——例如，直到您没有更多空闲内存插槽来扩展您的 RAM 或 SATA/SAS 端口来连接另一个硬盘。这类似于在一个孤立的地方堆积资源——它们都长到了屋顶。
*   **横向** -你不断增加*更多的小型自治系统*，每个都有自己的一部分资源，总的来说给你所需的能力和性能。只要你有物理空间(和足够可靠运行的电力),你就可以做到这一点，这对未来的发展是非常有效的。想象一个大架子，当你用完资源时，你把新的服务器放在最后一个服务器旁边——它会增长`horizontally`。

## [](#load-balancers-come-in-play-when-you-scale-horizontally)当你水平缩放*时，负载平衡器开始发挥作用*

 *部署在负载平衡器后面的单个系统称为*节点*。

通常，您会在这些节点前放置负载平衡器来处理管理工作。负载平衡器决定如何在所有节点之间分配负载，以及如何支持节点，并尝试从节点上卸载尽可能多的任务。

## [](#features-of-the-load-balancer)负载均衡器的特性

我们可以总结为:

*   跨可用节点平衡负载——显然
*   保存所有节点的健康信息，以防止将请求路由到失效节点。这是通过实现定期的健康检查来实现的——通常是 HTTP 探测特制的 API，该 API 以应用程序的内部状态作出响应。例如，这提供了一种非常棒的维护方式——因为您可以将节点标记为非活动状态(在维护和/或重启时),而 web 应用程序仍然通过处理来自其他活动节点的请求而工作。同样，您可以在不停机的情况下，通过一个接一个地更换功能更强大的节点来慢慢更换所有节点！
*   保存每个节点上的负载信息(CPU 负载、RAM 使用情况、活动连接数、每个节点的每秒连接数),以防止已经大量使用的节点进一步过载
*   跟踪会话(基于源 IP 地址+端口或 HTTP cookie ),将相同的客户端始终路由到相同的节点(如果其余节点不支持会话，则有必要——假设您登录到一个为您的已验证会话生成 cookie 的应用程序中。然后，您的下一个请求将被重定向到一个不同的节点(负载平衡器决定，例如负载较低的节点)，该节点不知道您已经通过了身份验证，因为它没有 cookie -您将最终被重定向回登录屏幕，可能会以循环结束。
*   卸载-负载平衡器可以接管压缩资源并将它们发送到最终客户端的责任，从而将更多 CPU 能力留给节点上的应用程序代码。同样的方式，它可以终止和协商 HTTPS 会话，这也是昂贵的，因为 SSL/TLS 加密发生在每个客户端。类似地，负载平衡器还可以在内存或快速存储中缓存经常使用的资源，以防止一直从节点检索它们，这样您的节点就不必占用更多内存和快速 SSD。

## [](#additional-things-you-can-do-with-load-balancers)负载平衡器可以做的其他事情

*   基于路由(URL 的一部分)划分负载——您可以决定将 4 个节点用于`/rest/api`上下文，2 个节点用于`/[css|js|img]`，其余的用于应用程序代码。

## TL；速度三角形定位法(dead reckoning)

负载平衡器[可以]让你的服务更可靠，更容易扩展，更高的性能和对中断的弹性。*