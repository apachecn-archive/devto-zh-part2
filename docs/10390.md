# 你管这叫简化？

> 原文:[https://dev.to/ferricoxide/you-call-that-simplified-4lbo](https://dev.to/ferricoxide/you-call-that-simplified-4lbo)

看啊。我明白了。技术可能很难。这种困难是我们许多人有工作的原因:我们让那些关注数据而不是用来存储和操作数据的东西的人更容易做事。使技术固有的困难进一步复杂化的是，它在不断变化。因此,“简化”的想法似乎很有吸引力...至少在脸上*。*

如果你看了我的简介总结，你会发现我从事这种无聊的工作已经很长时间了——如果算上我的大学预科和业余爱好的话，时间会更长。如果说我见过很多东西来来去去(带着新的标签回来)，这是一种保守的说法。年复一年，让我印象深刻的一件事是，一项特定的技术经常被视为“太复杂”，导致一个“简化的”替代方案或覆盖层被创建出来。具有讽刺意味的是，就像经常发生的那样，事物的简化版本被越来越多的东西(缓慢而无情地)附加到它上面，以返回最初以简单的名义牺牲的功能。

所有这些都很好，真的。不太好的是所有这些“简化”的综合影响。也许我的用例是相当独特的:我的工作要求意味着，在一个任意的时间段内，我使用了许多技术。有时这种用法是连续的，有时是并发的...但是，大多数情况下，它是重叠的。每个自动化工具似乎都有自己特定领域的语言——通常是一种更广为人知的语言的“简化”,针对特定自动化工具的主要用例进行了优化。类似地，每一个专注于文档服务或者包含文档服务作为一个组件的工具都包含自己的简化标记语言。

无论如何，孤立地看，这些简化都是好的。然而，当您不得不处理一组重叠的和快速发展的简化时，您开始问自己，“知道一个给定的‘太复杂’的技术的半打部分重新实现是否节省了我的任何学习努力?”至少对于源代码技术，我不必担心由简化过程产生的特性和限制。我不必担心，“这种对我所记得的底层技术的逃避对于*这种*简化或者我使用的其他简化之一来说是正确的吗？”我不用担心如何保护分层逃生。我不必哀叹“如果我只是使用底层技术，我可以做‘X ’,但不能用这个简化的构造。”我不必担心，“我是否适当地优化了这个简化的代码，或者我是否让其他简化的方法溜了进来。”这样的例子不胜枚举。

问题到处都是:定制的“外壳”可以保护你免受赤裸裸的 CLI 的攻击；各种口味的“降价”；特定领域的语言；等等。

是任何人没有其他人遇到这个“问题”，还是只有我公开抱怨这个问题？