# 对递归的解释比如你五岁

> 原文：<https://dev.to/cathodion/an-explanation-of-recursion-like-youre-five-2b0m>

*或:重组是一个快照*

*这篇文章改编自我对[的评论，解释递归就像我五岁](https://dev.to/sloan/explain-recursion-like-im-five-5c6)*

假设你想把一堆数字加起来。你有一叠索引卡片上的数字，每张卡片上有一个数字。有人让你把它们加起来，然后告诉他们结果。那听起来像是一大堆工作。我是说，拜托，加几个数字没问题，但是这副牌里可能有 50 个数字。所以你策划了一个计划...

你拿着最上面的卡片，把剩下的交给你的同学，让他们把剩下的卡片加起来。你没有告诉他们这应该是你的工作。

你的同学说很好，但随后意识到这副牌里肯定有 49 张牌，这听起来像是一堆牌。所以他们策划了一个计划。他们自己留一张牌，让别人把剩下的牌加起来...

如此下去(幸运的是，你的学校相当拥挤，你有很多同学)，直到有人拿到一张卡片，被要求把“他们”加起来。

“你说把‘他们’加起来是什么意思，不过是一张卡。”

“但它们意味着什么？”

好吧，不管怎样，最后一个人只要说出卡片上的号码。

倒数第二个人把这个数字加到他们保存的卡片上，然后告诉问他们的人。

倒数第三个人把倒数第二个人告诉他们的数字加到他们保留的卡片上，依此类推....

你得到第二个人告诉你的号码，并把它加到你保留的那张卡片上。简单的柠檬汽水！然后你告诉问你的人。

在代码中，这将类似于:

```
def sumof(deck):
    if len(deck) == 1:
        return deck[0]
    else:
        mycard = deck.pop()
        return mycard + sumof(deck) 
```

一个问题是，这破坏了甲板。我们可以让每个人在说出结果时把卡片还给他们(`deck.push(mycard)`)，但在代码中，只传递剩余的一张卡片会更干净:

```
def sumof(deck):
    if not deck:
        return 0
    else:
        return deck[0] + sumof(deck[1:]) 
```