# 带 Dock extras 的 Go 和 JXA 应用程序中的 OBS 客户端

> 原文：<https://dev.to/progrium/obs-client-in-go-and-jxa-apps-with-dock-extras-3n9o>

这里有一个我今天在[工作台](https://www.twitch.tv/progrium)上做的事情的快速更新，我在那里流式传输我的开源创新工作。

我想构建一个 Go 客户端来与大多数流媒体工具选择的 [OBS](https://obsproject.com/) 进行交互。有一个插件为 OBS 提供了一个 websocket 服务器，通过简单的 JSON 消息来发出请求和获取事件。plugin 项目还为所有请求和事件消息提供了一个 JSON 模式，所以我认为这对于在 Go 中生成类型会很方便。然而，在生成任何东西之前，我想制作一个可以使用地图的基本客户端。

用插件运行 OBS 实例花了 45 分钟。直到我的流开始时，我才意识到我可能必须重启 OBS，这会杀死流。我可以运行第二个实例，但它不能加载插件，所以 Josh，一个经常查看的人，建议在另一台机器上运行它。我这里确实有一台 windows 机器，所以我把它安装在那里，并通过远程桌面访问它。我几乎走上了在 Docker 中运行它并通过 X11 访问它的道路。这要容易得多。

我花了一些时间使用现有的 [Python 客户端](https://dev.tolink),以确保 websocket 插件正常工作。这也花了一点时间，因为库有点粗糙。但这很有效，所以我继续前进。

然后，我从一个演示 Go 脚本开始，这个脚本建立了一个连接，并手动完成了他们的复杂到令人讨厌的验证挑战。然后我用 Python 做了同样的请求。它成功了，所以我将代码重构为一个实际的客户端。客户端跟踪消息 id，并将消息路由到等待响应通道或事件通道。如果服务器需要，它还会处理身份验证。

这让我清理了原始的演示脚本，尽管我们还没有
消息类型，但这已经是一个非常有用的库了。

显然，下一步是生成类型，但我可能会推迟到以后，因为我宁愿开始使用客户端。我们将在下周左右看到我用它做什么。

今天早些时候，我花了很多时间做的另一件完全不相关的事情是理解 MacOS 应用捆绑包、插件，以及用 JXA 脚本捆绑包打包插件的方法。插件用于各种与 MacOS 集成的东西。如果你用 [osacompile](https://ss64.com/osx/osacompile.html) 做一个 app 捆绑，它不会加载插件。我试着用一个扩展来设置 Dock 中的应用程序运行前的徽章和菜单。显然，Dock 动态地将扩展加载到一个进程中，为一个应用程序提供额外的 Dock 功能，即使它没有运行。这就是为什么我不能在 JXA 实现扩展，但我至少让它在 JXA 的应用程序中工作。

我还获得了一个示例应用程序，可以在不使用 XCode 的情况下构建所有的部分和技巧。我也将在未来的项目中使用它。

[https://www.youtube.com/embed/C0wAbBEJDiw](https://www.youtube.com/embed/C0wAbBEJDiw)