# 列表的去喉:SC4K 部分

> 原文：<https://dev.to/robinheghan/de-throning-the-list-part-sc4k-4e3n>

在[的上一篇文章](https://dev.to/skinney/de-throning-the-list-part--44dl)中，我们研究了如何让`Array`更具表现力。我的意思是我们为人们增加了一种扩展数据结构以支持更多用例的方法。但是，尽管第三方现在可以添加缺少的功能，但出于性能和方便的原因，某些功能应该是开箱即用的。

Elm 有四个内置的集合类型:`List`、`Array`、`Dict`和`Set`。除了`Dict`，从鸟瞰的角度来看，这些类型都很相似。您可以将一个项目插入到集合中，将其取出，甚至可以对存储的每个项目执行一些任务。当然，它们有不同的权衡，这使它们适合不同的情况。

在集合的开头(左侧)添加和检索项目时，`List`非常有用。当您需要快速访问任何元素时，`Array`非常有用，当您需要一个没有重复的有序集合时，`Set`非常有用。

这些集合的 API 也是不同的。有时这是有意义的，但并不总是如此。例如，`Set`没有`sort`函数，这是合理的，因为`Set`是一个排序的集合。然而，`Array`也没有一个`sort`函数，这意味着你必须把它转换成`List`或`Set`，然后如果你想排序的话再转换回来。

从一种集合类型转换到另一种集合类型是一项开销很大的操作。如果您使用一个`Array`是因为它在大多数时候适合您的用例，那么您不希望仅仅为了执行那个操作而转换到另一个集合。

让我们看看如何改进`List`、`Array`和`Set`的 API，以减少从一种集合类型转换到另一种集合类型的需求，从而支持您需要的功能。

## 应保留的差异

集合类型不支持某些操作是有原因的。例如，`List`上没有`get`或`set`操作，因为性能会很差。如果需要`get`或`set`集合中的任意一个项目，应该使用`Array`。同样，`union`、`intersect`和`diff`应该只支持`Set`。以下是三种集合类型都不支持的一些函数，我认为它们也不应该被支持:

`get`、`set`、`insert`、`remove`、`::`、`push`只有各自的集合才能有效支持。如果你需要这些功能中的一个，这是你应该使用哪个集合的信号。然而，通过我在之前的文章中提到的改进，`Array`可以有效地支持所有这些函数，这也是为什么`Array`应该是默认集合类型的另一个原因。

`indexedMap`和`toIndexedList`对`Set`没有意义，因为它不通过索引操作，也不保留插入顺序。`repeat`对`Set`来说也没什么意义，因为它不能包含重复项。

`union`、`intersect`、`diff`只有通过`Set`才能高效执行。

其他集合可以有效地支持`head`，但是操作本身只对`List`有意义。`Array`会用`get 0`，不太清楚`Sets`的`head`是什么意思，是第一/最低/最小元素还是根/中间元素？

`sort`、`sortBy`、`sortWith`对于`Set`来说没有意义，但是`Array`绝对应该得到这些功能。

`reverse`对于`Array`可以高效实现，对于`Set`意义不大。

## 我们可以在哪里弥合差距

以下是所有三个系列都能轻松支持的功能列表:

*   一个
*   初始化
*   范围
*   串联
*   散布
*   成员
*   地图 2，地图 3，地图 4，地图 5
*   串联图
*   过滤器地图
*   划分
*   拿
*   滴
*   拉开…的拉链
*   薄片
*   总和
*   产品
*   最高的
*   最低限度
*   全部
*   任何的
*   scanl

虽然所有三个集合都支持这些功能，但这意味着它们应该支持吗？既然我们已经在瞎搞了，让我们问问自己，是否有某些功能一开始就不应该放在核心中。

`sum`和`product`本质上是`List.foldl (+) 0`和`List.foldl (*) 1`的快捷方式。这些操作是否足够常见，足以授予它们核心库中的专用功能？如果三个系列都引入`slice`，还需要`take`和`drop`吗？

人们真的会用`map4`和`map5`吗？`scanl`和`unzip`怎么样？我的意思是，可能有，但这些操作是如此普遍，人们期望在核心中找到它们吗？这并不一定会有什么坏处，但是有一个小而强大的软件包可以让你在短时间内阅读完整的文档。

无论如何，这是一个我个人认为没有理由在核心中使用的功能列表。我希望人们会告诉我，这些功能肯定属于，但我认为至少有讨论是很好的。

*   散布
*   地图 4
*   地图 5
*   串联图
*   拉开…的拉链
*   总和
*   产品
*   scanl
*   拿
*   滴

## 点睛之笔

下面是一些我认为不应该被 API 革新忽略的小事情:

`List`和`Array`有`length`功能，`Set`有`size`。这可能是因为`Set`是在`Dict`之上的一个抽象，所以只是复制了它的名字。如果没有别的原因，出于一致性，我会将`Set.size`重命名为`Set.length`。

既然我谈到了这个话题，既然`Set`是在`Dict`之上的抽象，也许到目前为止讨论的一切也适用于`Dict`？

`List`有`::`和`tail`。`Array`的类比是`push`和`pop`。`pop`是 API 中缺少的，所以我会添加它。

我会为所有三个系列添加`find`。`List`和`Set`已经支持`member`，它本质上是`find`，除了它返回一个布尔值，而不是谓词函数返回 true 的值。总的来说，这是一个更有用的函数，所以如果`member`应该是 API 的一部分(我相信它应该是),那么`find`也应该是。

对于`Set`和`Dict`，我会抛出`min`和`max`来检索最小/第一个和最大/最后一个元素。

我认为`Stack`是一个比`List`更好的名字，所以我会重命名这个类型。这个名称更清楚地解释了该集合类型擅长什么。

最后，正如上一篇帖子提到的，我认为`stoppableFoldl`和`stoppableFoldr`，或者功能相同但名字更好的东西，应该加入到`Array`的 API 中。我认为`Dict`和`Set`也可以很好地实现这个功能。

## 你怎么看？

我试图达到的目标是使`Array`类型更通用，但是在改进`Array` API 时，看看其他集合类型也是有意义的。这篇文章展示了我认为这些 API 应该是什么样子。

首先，我想说我并不是 Elm 的权威。如果我真的将这篇文章中的建议编码并作为一个提议提交，所有的建议都有可能被采纳，或者一个都没有。

第二，所有这些建议都是基于我自己的经验。我需要的是你的经验。这些建议有意义吗，还是我疯了？在 [Elm Discourse](https://discourse.elm-lang.org/t/de-throning-the-list/997/32) 上的讨论帖中让我知道。

## 而现在，情况完全不同了

那么，这是这个系列的结尾吗？不完全是。还有一份摘要要发表，但那要等到我们看完最上面之后(你不会认为我已经忘记了吧？)在[下一篇](https://dev.to/skinney/de-throning-the-list-part-boron-185)里，讲的是`List`和`Array`的字面意思。