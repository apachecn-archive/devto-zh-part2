# 百事通，一人通

> 原文:[https://dev.to/maikon/jack-of-all-trades-master-of-one-c0n](https://dev.to/maikon/jack-of-all-trades-master-of-one-c0n)

***本帖原载于[第八轻博客](https://8thlight.com/blog/makis-otman/2018/10/30/master-of-one.html)。***

> 万事通，无所不能

以上是一个众所周知的说法，人们倾向于在提到博学的人或多面手时使用。这通常是开玩笑说的，尽管潜在的假设更加悲观。如果你注意到它在其他语言中的用法，尤其如此:

> 多才是无才
> 
> - *日文版*

相当不祥的权利？

如果你是个多面手，不要绝望。在这篇博文中，我将证明多面手的本质是塞翁失马焉知非福，事实上，他们是一项特殊且非常重要的技能的真正大师:解决问题。

## [](#mastering-problem-solving)掌握解题技巧

几个月前，我参加了 Dan North 举办的关于更快交付高质量软件的研讨会。在研讨会期间，Dan 提出了以下问题:*“代码是负债还是资产？”*。他问我们在这个问题上的立场，非常直接，从*“所有代码都是负债”*到*“所有代码都是资产”*。最后他说*“所有代码都是责任”*。不可避免地，有人提出了这个问题:“我的工作怎么办？”丹回应道:“你的工作不是写代码。你的工作是解决问题。你是一个解决问题的人。”

作为第八光公司的顾问，我们经常遇到这种情况。切换项目通常意味着必须学习新工具和新领域。不管技术如何，剖析问题并迅速摆脱困境的能力是至关重要的。我们天生是多面手。

考虑到这一点，多面手拥有和使用的使他们成为伟大的问题解决者的一些技巧是什么？

## [](#narrowing-scope)缩小范围

> 问题越小，就越容易解决

当处理未知的事情时，很少有事情能像*范围*那样放大问题。你试图在脑子里保存的信息越多，挑战就越大。尺寸可以是你的朋友，也可以是你最大的敌人。

### [](#divide-and-conquer)各个击破

这个过程的第一步是把一个大问题分解成可以单独关注的小问题。让我们看看下面的例子:

“在 Go 中构建一个命令行应用程序，它接受命令行参数并将其打印回控制台。”

让我们假设你从未使用过围棋，或者至少做得很少。以下是我们面临的一些问题:

1.  学习围棋
2.  在 Go 中构建可执行文件
3.  在 Go 中打印到控制台
4.  将命令行参数传递给 Go 可执行文件
5.  在 Go 中解析命令行参数

起初，这看起来像是一个大任务，但是分解它可以帮助你看到更小的部分，你可以一次专注于一件事。你可以用谷歌搜索每一行，他们会给你结果，或多或少会给你想要的答案。

### [](#learning-a-new-tool)学习新工具

我们列表中的第一个是**“学习围棋”**。从表面上看，这似乎是一个非常大而广泛的挑战。你从哪里开始？你应该先掌握什么？你需要学习多少东西？

这些都是合理的问题，但对你没有帮助。对你最有帮助的问题如下:

> 我怎么能放心地把 ***忽略*** 换成 ***现在*** ？

这一点非常重要。这只是缩小范围的另一种机制。你不需要掌握 Go 的每一个方面来构建一个可执行文件或者打印到控制台。你需要学习足够多的来完成手头的任务。

## [](#effective-searching)有效搜索

知道如何寻找东西本身就是一门艺术。在搜索时，你希望让搜索引擎更容易为你找到东西，同时让搜索过程更高效。比较以下两个搜索字符串:

> 演示如何构建 Go 可执行文件

**对**

> 构建 go 可执行文件

尽管其中一个需要较少的击键次数，但两者产生的结果大致相同。你节省的击键次数并不是这里的主要目标。目标是训练自己从本质上解决问题。这不仅有助于你搜索东西，也有助于你构建东西，因为它可以帮助你识别子问题。

## [](#debugging)调试

当处理未知的事情时，你几乎肯定会面临错误。有些可能很容易，有些则不那么容易。他们也可以非常令人沮丧。我每天都面临着许多错误和挑战。多年来帮助我坚持下来的是以下信念:

> 每一个错误都是某个地方某个动作的结果*并且*可能*是可解决的*

 *作为这种信念的一部分，我在寻找能帮助我解决问题的信息时产生了一种直觉。下图试图使这种直觉更加具体:

[![debugging](../Images/2a9b40de956928acc9960d77e328cca8.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--BCeFdott--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://makis.dev/assets/searching.png)

如果你内化了以上几点，那么任何问题都是可以解决的。当你相信这一点并遵循类似的方法时，那么真正的问题是你试图解决的事情是否值得你花费时间。

## [](#short-feedback-loops)短反馈循环

上述流程的一个关键要素是短反馈回路。无论您试图在控制台上打印一个字符串、调试一个错误，还是做其他任何事情，您都希望确保有一个简短的反馈循环。那是什么意思？这意味着尽快从你的行动中获得反馈。

> 最小化你的行动(输入)和结果(输出)之间的距离

短反馈循环机制的一个很好的例子是[回复](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop)。您键入一些输入，按回车键，然后立即得到输出(反馈)。在我们的 Go 示例中，过程中的第二步是构建可执行文件的原因是，当您尝试填充其余部分时，这将为您提供一个非常快速的反馈循环。首先打印一个`hello world`，然后开始解析参数。对于这两种情况，你都有一个带有`./run-my-executable`的极快的反馈回路。

另一种机制是 TDD 和单元测试。如果您不知道从哪里开始，传统的打印语句也可以为您提供极快的反馈——尽管您需要格外小心，因为您必须在代码中战略性地放置它们。添加太多会导致信息过载。太少了，你得不到足够的信息。甚至添加或删除它们的顺序也有所不同。

我们举个例子。您面临以下问题:您的代码返回一个错误，您没有测试，并且您不确定从哪里开始。第一步是确定执行的是哪条代码路径，即*“啊，是 A 类，method-B 从 D 类调用 method-C 和它自己的私有方法-e”*。然后继续缩小范围:

[![debugging](../Images/db733576271374b59312948d25a381e4.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--OMidhWiq--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://makis.dev/assets/debugging.png)

## [](#resetting)复位

如果以上都失败了，有时候最好的办法就是扔掉一些东西，重新开始。一旦你进入兔子洞，继续下去比后退一步要容易得多。如果你使用 Git，你可以用一个`git reset`退出兔子洞。这会给你时间重新调整心态，用全新的视角来处理问题。

## [](#reframing-polymathy)重构多病

希望这篇博文给你留下了一些提高自己解决问题能力的技巧。我同样希望，如果你是一个多面手，我给了你一个不同的视角来看待自己和他人；一个让你感到骄傲的人。我们也可以稍微改变一下原来的引语，让人们更加好奇，让你展示自己最大的技能:

> 万金油，独一无二的大师。*