# NPM 热点和平凡化的陷阱

> 原文:[https://dev . to/dubyabrian/NPM-hot-take-and-the-trapped-of-trivialization-3n9l](https://dev.to/dubyabrian/npm-hot-takes-and-the-pitfalls-of-trivialization-3n9l)

## 臭名昭著的左派论战

大多数人现在可能都知道了关于左垫的争议。如果没有，我会让你跟上进度:

一个流行的 NPM 软件包的维护者删除了他们的软件包以示抗议，破坏了数以千计依赖它的其他软件包。这个问题很快得到补救，解决方案也已到位，以防止它再次发生，然而，在争议之后是大量的博客帖子和文章，询问我们为什么要依赖解决如此琐碎问题的小型图书馆。“我们忘了如何编程了吗？”一篇博文问道，说明了当时的普遍情绪。

## 左补 redux

左垫争议仍然不时出现，通常是作为笑话的笑柄。我最近偶然看到一篇媒体文章，指出[是奇怪的](https://www.npmjs.com/package/is-odd)包的荒谬，在我写这篇文章的时候，这个包在过去的七天里已经有超过*300 万次下载*。事实上，从表面上看，依靠一个包来确定一个数字是否是奇数似乎是矫枉过正的缩影。其中一个最受推崇的评论提出了如下主张:

> 如果你不能在 10 秒内编写一个函数来判断一个给定的整数输入是否是奇数，你要么是一个蹩脚的打字员，要么你不应该编程。

这是一个相当大胆的主张，而且是对 boot 不必要的侮辱。真的有*这么简单吗？典型的 10 秒钟解决方案可能是这样的:* 

```
function isOdd(i) { return i % 2 === 1; } 
```

Enter fullscreen mode Exit fullscreen mode

让我们写一些单元测试，只是为了好玩:

```
expect(isOdd(-2)).toBe(false);
expect(isOdd(-1)).toBe(true);
expect(isOdd(0)).toBe(false);
expect(isOdd(1)).toBe(true);
expect(isOdd(-2)).toBe(false); 
```

Enter fullscreen mode Exit fullscreen mode

嘣！完成了。今天到此为止吧。

## 开玩笑。我们还没完呢。

当我们最初考虑这个问题时，我们假设所有的输入都是整数。然而，没有办法强制将特定的类型传递给函数。不仅如此，javascript 中的所有数字实际上都是双精度浮点数。让我们添加一些单元测试来确保我们的函数能够处理浮点输入:

```
expect(isOdd(1.5)).toBe(true); // FAIL! 
```

Enter fullscreen mode Exit fullscreen mode

好，所以我们的函数不适用于浮点数。在这一点上有几个选择:

*   我不打算向函数传递除了整数之外的任何东西，所以我不在乎它是否返回错误的结果。

*   如果它不是一个整数，我就返回 true。

*   如果不是整数，我会抛出异常。

这些解决方案都不一定是错的，因为最好的解决方案可能包含许多考虑因素。不管怎样，*它仍然值得考虑*。这不是我们最初认为的 10 秒解决方案。

## 好了我们完成了。结束了。

开个玩笑，这里我们还需要考虑最后一件事:Javascript 是动态类型的，我们需要确定如何处理非数字输入。同样，我们面临几种不同的解决方案:

*   我不打算向函数传递非数字输入，所以我不在乎如果我这样做了会发生什么。

*   我会让 javascript 做它想做的任何古怪的隐式转换，并接受结果。

*   我会抛出一个异常。

同样，这些都不一定是错的，但这是我们最初没有想到的另一个考虑因素。普通的库处理这些问题，所以我们不需要这么做。

## 行为不猥琐

平凡的库不仅仅解决平凡的问题。他们考虑所有我们可能忽略的小边缘情况，并提供一致和健壮的行为。这对于像 javascript 这样的语言尤其重要。

作为一般的经验法则，我尽量不把表面上看起来微不足道的事情变得琐碎。编程就像现实世界一样，不是琐碎的，充满了细微差别。