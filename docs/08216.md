# 在测试驱动的 angular 应用程序中开发 redux 存储时的测试策略(返工和扩展)

> 原文:[https://dev . to/_ maimart _/test-strategies-when-developing-redux-stores-in-angular-apps-driven-by-tests-2700](https://dev.to/_maimart_/test-strategies-when-developing-redux-stores-in-angular-apps-driven-by-tests-2700)

[![TDD Angular](../Images/4e42f2723e5e80b26255955af02830bb.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--CkFGw5vE--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://i0.wp.com/maimart.de/wp-content/uploads/2018/07/TDD__Angular.png%3Fw%3D1280)

我通常开发由测试驱动的角度应用程序。这很好，但是当在我的项目中使用 redux 时(目前是 ngrx，但也有 angular/redux)，在测试和开发商店和功能/分形商店时，需要考虑几个不同的方面。

## [](#intend)打算

问题是找到一个好的测试和测试驱动的开发策略。

有 e2e 测试、集成测试和单元测试，其中最后一种主要测试静态功能和静态反应变量。

我的主要意图是通过测试从商店和子商店的集成级别，向下到商店的单个组件来驱动开发。

我希望能够最初开发的商店没有集成在其余的角度应用程序。

因此，从非 redux 数据管理迁移或者从一个 redux 框架迁移到另一个 redux 框架的场景可以顺利完成，而不会发生大爆炸。

## [](#different-perspectives-and-strategies)不同的视角和策略

我尝试了不同视角的不同策略。

当写商店的组成部分时，我指的是它的减少者、效果、动作和动作创建者。

对我来说，选择器不是存储的一部分，而是帮助访问其状态子集的便利功能。

### [](#1-treat-the-store-and-its-components-as-a-whole)1。将商店及其组成部分视为一个整体

当我们将商店的组件视为整体商店的外包功能和变量时，在封装商店中测试它们的集成就足够了。

**+** 商店的技术功能是整体规定的

**+** 商店作为一个集成组件被明确测试，因此它们的功能不仅仅在 e2e 测试中得到保证

**+** 动作的直接效果和副作用在一个单点上指定。

**-** 封装成商店只是虚构的。实际上，每个商店都没有明确的类，只有一个大的商店对象。

**-** 这是一个更加实用的世界中非常面向对象的视角

**-** 可以产生非常全面的集成测试套件

**-** 没有“真正的”单元测试

### [](#2-treat-the-store%C2%B4s-components-strictly-as-separate-components-that-are-tested-isolated)2。将商店的组件严格视为经过隔离测试的独立组件

我们将商店的组件视为独立且完全独立的组件，并对它们进行隔离测试。

**+** 关注各自功能和反应变量的小型精简测试套件

**+** 行动的影响由不同组件的责任分别规定

**+** 真实单元测试

**-** 不同组件的相互作用仅在 e2e 测试中进行测试

**-** 动作影响的规范被分散到多个测试套件中

**-** 商店组件的高度内聚性仅在文件结构及其在 ng 模块中的配置中可见

### [](#3-treat-the-store%C2%B4s-components-as-separate-components-that-are-tested-separate-but-integrated)3。将商店的组件视为单独测试但集成的独立组件。

我们将商店的组件视为单独的组件，也单独测试它们，但集成在商店中。

**+** 关注各自功能和反应变量的小型精益测试

**+** 动作的影响被指定为不同组件的责任

**+** 商店的组件经过集成测试，因此它们的功能不仅仅在 e2e 测试中得到保证

**+** 在集成测试中也可以看到属于特定商店的

**-** 动作影响的规格被展开成多个规格

乍看起来，规范名称似乎是单元测试，但却是集成测试

**-** 没有“真正的”单元测试

### [](#4-treat-the-store-and-its-components-as-a-whole-that-is-developed-and-tested-depending-on-its-actions)4。视商店及其组成部分为一个整体，根据其行动进行开发和测试

我们将商店及其组成部分视为一个整体，通过其行动来开发和测试它们。

这个视角类似于第一个视角，但是更侧重于 Redux 的核心概念和思想，并且还支持更好的子结构。

这个想法是，在 Redux 和它的商店是所有关于行动。

触发动作以更改数据并触发副作用，副作用又会触发服务。所有的行为都是由行动驱动的。

所以在这种方法中，测试是根据动作来构建的。由此在商店中集成测试动作。

在更复杂的存储中，动作应该被分组为不同种类的动作，并且每组应该有一个测试套件。

具有简单行为的动作测试，比如仅仅操作状态，可以直接在测试套件的顶层指定。

导致一些更复杂行为的动作测试应该在嵌套测试套件中进行子结构化。

**+** 一个动作的所有影响都是在一个点指定和测试的，而不是分散在不同技术组件的测试中

**+** 商店的技术功能是整体规定的

**+** 商店作为一个集成组件被明确测试，因此它们的功能不仅仅在 e2e 测试中得到保证

**-** 没有“真正的”单元测试

## [](#conclusion)结论

首先，我开始混合使用第一种和第二种方法，但很快商店的集成测试和单一组件测试之间的冗余使我坚持并重新思考我的观点和这种方法。

我的第二个想法是将商店的组件仅仅视为外包的功能和反应变量，并且只测试封装在集成测试中的组件。

不对商店组件进行单元测试仍然感觉有点不寻常，但是 redux 商店的测试驱动开发现在感觉非常好。

此外，由于为每个动作构建嵌套的测试，测试的输出也非常好。我一眼就看出了每一个动作引发的效果和副作用。

但至少当我用多种不同的副作用扩展商店时，集成测试变得非常大。

第二种方法我只是在理论上进行评估，因为对于 TDD，我错过了集成测试，而且这将导致大爆炸，特别是在迁移场景中。

一段时间以来，第三种方法被认为是一种很好的妥协，我认为这是一种很好的方法，但它仍然困扰着我，因为一个动作的行为分散在商店组件的不同测试中。

测试驱动的开发和测试的可读性仍然感觉不到流畅和连续。

所以最后我采用了最后一种方法，这种方法中，开发是由行为驱动的，测试依赖于行为。在 Redux 中，一切都是关于动作的，而在这种方法中，测试也是如此。

我将非常高兴阅读您对此问题的意见和方法。

在测试驱动的 angular 应用中开发 redux 商店时的 post [测试策略](http://maimart.de/test-strategies-when-developing-redux-stores-in-angular-apps-driven-by-tests)最早出现在 [maimArt](http://maimart.de) 上。