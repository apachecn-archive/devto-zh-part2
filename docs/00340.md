# 我希望在 C 的容器中看到什么

> 原文:[https://dev.to/noah11012/containers-in-c-34pi](https://dev.to/noah11012/containers-in-c-34pi)

与 C++不同，c++有各种各样的容器用于基本和要求更高的用途，标准没有提到 C 的容器。大多数时候，您必须创建自己的库或找到一个库来满足您项目的所有需求。

如果您需要一个简单的映射来保存来自输入(如文件或网站内容)的单词的频率，那么一个专门针对从字符串到整数的键值的简单实现就足够了。

相反，假设您需要一个不仅仅是字符串到整数映射的映射。您需要一些更通用的东西，或者至少需要更多类型的映射，例如，反过来:一个整数值到一个字符串的映射。

这篇文章是一篇固执己见的文章。这些建议就是我希望看到的容器库。我在随后的段落中可能会说的内容可能与您对容器库的想法不一致。

话虽如此，我们还是开始吧。

## [](#generic-vs-type-safety)泛型与类型安全

什么更重要？允许用户创建自定义映射或类型安全容器以保证用户安全的通用映射？每种方法都有自己的优点和缺点。

### [](#type-safety)类型安全

如果我们要走安全路线，一个实现是创建几个预定义的映射，用户可以从中选择。从用户的角度来看，明显的缺点是他们只能选择这么多。如果他们需要自己类型的映射，那么不幸的是，他们必须为自己的特定需求创建一个映射。

从库维护者的角度来看，它也不怎么样。为了节省时间，使用了复制和粘贴的方法，并根据需要对代码进行了细微的修改。

这很容易出错，并且不可伸缩或维护。如果你还没有听说过，那么我现在告诉你:如果你正在复制和粘贴代码，很可能你的代码有问题。

如果您需要更改一个映射的代码，那么为了保持一致，您需要更改所有的实现。这本身就可能让 bug 潜入您的代码库。

选择让您的用户更安全并不是您不应该做的事情，但是您需要知道这种方法肯定有缺点。

### [](#generic)通用

使用通用方式做事的容器库有其直接的吸引力:我可以将任何类型映射到另一个任何类型。

对于库的维护者来说，大部分负担都放在他们的肩上，以确保库是通用的，并且使用起来不是完全不安全的。可以实现的一个方法是使用空指针。C 语言中的指针是语言的一个重要方面。不管花多少时间在 C 语言上，在某个时候，你都会用到指针。

简单地说，C 语言中的指针是一个变量，它保存着某个内存的地址。指针关于它所指向的类型的唯一信息是星号前的基类型。

```
int *ptr = ...; 
```

在这个例子中，指针指向的内存是一个整数。

如果有人告诉过你这些，他们要么是在保护你远离关于指针的更挑剔或混乱的部分，要么是在对你撒谎，不管是不是故意的。

指针声明的基类型不一定是实际被指向的对象。据我们所知，它可能是一个浮点数。当我们考虑指针时，基类型告诉编译器如何解释内存。

```
double number = 123.45;
int *ptr = &number;

printf("%d", *ptr); 
```

现在我敢肯定，这个启示会引起你使用的下一个指针之间的一些不信任。

大多数情况下，基类型是被指向的实际类型。然而，这不是一个保证。

空指针有什么特别之处？首先，它没有基类型。这通常意味着我们不关心内存的类型。第二，因为我们事先不知道类型，我们可以利用这一点来创建通用容器。

使用空指针的一般容器的问题是我们需要知道我们所指向的对象的大小。这可能意味着添加一个额外的变量来保存这些信息。

继续使用地图主题，保存这些信息的简单结构可能如下所示:

```
typedef struct
{
     int size_of_a_key;
     int size_of_a_value

     void *keys;
     void *value;
} Map; 
```

在用户方面，有一点不方便。在创建 map 实例时，他们必须提供键和值的大小。这是获得通用容器的小小代价。

## [](#final)最终

就我个人而言，我更喜欢什么？对于一个统计网站上一个词的频率的项目，可能会选择一个专注于类型安全的容器库。其他人可能需要从一个自定义类型映射到另一个自定义类型，这是面向类型安全的库所不具备的。这是通用容器的工作。

也就是说，不管我在做什么，我都会选择通用容器库。

## [](#api-design)API 设计

除了拥有一个高效的容器实现，您还需要有一个直观的 API 供您的用户使用。在创建 API 时，易用性不仅仅是你应该考虑的一个因素。

在决定如何向调用代码报告错误时，会想到几个问题。如果你有一个返回类型，一个特殊的值可以被指定为一个错误代码，用来表示发生了错误，请小心处理。

你不能总是这样。例如，如果你有一个函数返回一个与特定键匹配的值，那么就不可能有一个错误代码的特殊值。

创建 API 时要记住的另一个重要因素是一致性。从一个函数返回一个错误代码，但不对另一个函数做同样的事情，这有点烦人。一致性很重要。

输出参数可能对我们有用。有一个指向整数的指针，如果发生错误，用错误代码填充，如果成功，用零填充。

```
void map_get(void *key, void *value, int *error); 
```

传入 NULL 或 0 可能表示对发生的错误漠不关心。

但是用于构造容器的函数呢？第一个选择可能如下:

```
Map *map_new(int size_of_key, int size_of_value); 
```

这没什么特别的。接受几个参数并返回值。你会注意到这个函数返回一个指针，而不是一个实际的对象。大多数时候，特别是对于构造函数，这是用来指示堆分配内存的使用。在堆栈上创建一个 map 对象，然后返回一个指向它的指针，当函数返回时，用于保存函数的局部变量的堆栈帧被破坏时，会产生垃圾结果。

与简单的推入和弹出堆栈帧相比，堆分配的开销很大。在没有必要的情况下，我想在堆栈上构造一个对象。为了实现这一点，构造函数的接口可能看起来像这样:

```
void map_new(Map *map, int size_of_key, int size_of_value); 
```

在这个版本中，我们有一个 map 对象的输出参数。我们处理如何创建对象，函数负责内部状态和其他必要的分配。

这有另一个我们可以利用的好处。现在函数的返回部分被释放了，我们可以用它来返回一个错误代码。

```
typedef enum
{
    M_OK,
    M_BAD_MEM_ALLOC
} MapCode;

MapCode map_new(Map *map, int size_of_key, int size_of_value); 
```

# [](#summary)总结

每个项目都有自己的需求，需要不同的库，这些库提供与其他项目相同的特性，但有不同的理念。由库维护人员来做出满足项目所有需求的决定。