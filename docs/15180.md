# 为什么要减少通量？

> 原文:[https://dev.to/luke/why-redux-over-flux-58pi](https://dev.to/luke/why-redux-over-flux--58pi)

[![CHRISTMAS TREE](../Images/0afb754646ff7cbd167a99a2fe675126.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--QK9EFdy4--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/cqq2h8gqoibzfw7lax1i.JPG)

所以对我来说，现在写关于圣诞节的文章有点晚了，这会迫使你回想起肉馅饼、火鸡和许多你不想要或不想要的礼物的时代。

嗬哼。怎么才能解决这个问题？你可能从来没有问过自己...我已经问过你了，我的答案是“编码和算法”。

## [](#where-im-coming-from)我从哪里来

不是去年，而是前年，圣诞节已经变成了我父母之间的亚马逊链接交换。魔力消失了，打开礼物平淡无奇，几乎是超现实的。所有的当事人都很清楚每个礼物是什么，是谁送的，大概多少钱。

快进到 2017 年 11 月；在此期间，我策划了一个补救这个问题的计划，至少对我来说是这样的(我知道这很自私)。

我的解决方案很简单——用户创建一个他们想要的物品列表(可能是圣诞节、生日，也许只是因为是“他们”)存储在数据库中(未加密)，每个物品都有一个标志，指示是否有人为用户购买了所述物品。

用户生成一个链接，并与朋友和亲戚分享，声明“给我买这些东西吧——不需要和别人商量，网站会处理的”。共享链接后，用户必须避免访问所述链接，以免他们发现哪些商品已经被购买！该链接显示尚未购买的商品列表，供其他人购买。

就是这样，这就是整个系统。

## [](#why)为什么？

主要是因为我喜欢做一个 Redux 支持的 React 应用程序，因为我以前没有做过。我想了解 Redux 以及为什么有些人更喜欢它而不是其他框架。我也一直在和我在 New Vector 的同事讨论 [Riot.im](https://about.riot.im) 应该基于 Redux 还是基于 Flux 还是基于任何东西，所以我想遵循这个调查路线。

在网络应用中，我们目前使用一些流量商店，但相当随意。因此，我们犯了许多罪，例如:

1.  使用 Flux 作为组件之间的消息传递系统(一些操作由存储和视图共同处理)。
2.  使用 Flux Stores 作为美化的全局变量，将状态暴露给多个组件。我们很多店就是因为这个原因而存在的！
3.  管理 React 组件中的“状态”,它在渲染过程中使用，但并不实际存储在组件状态中，而是作为成员变量。
4.  使用“异步”调度程序来解决 Flux 在调度处理程序中对调度的限制。

带着所有这些想法，我在几个月前开始学习更多关于 Redux 的知识，结果非常有收获:我不仅发现了 Redux 的用法，还意识到它本质上实现了 Flux 实现的一些功能，甚至更多。不仅如此，我还获得了如何使用 Flux 的洞察力。

有了这个新发现，我比较了两者，意识到为什么上面列举的每一个罪都是罪，并决定 Redux 本质上更优越，原因很简单，它*阻止了*犯罪的行为(在某些情况下)。

## Flux 和 Redux 的比较

### [](#1-using-flux-as-a-glorified-messagepassing-system)1。使用 Flux 作为一个美化的信息传递系统

#### [](#why-is-it-bad)为什么不好？

在组件*和*商店中处理一个动作只是自找被误解。是的，组件和存储可以处理相同的动作，但是在引入这种复杂性之前，您真的应该问一下为什么。

#### Redux 如何缓解这种情况？

在 Redux 土地上，只有才能被减速器接收到*动作。如果您正在调试调度某个操作时会发生什么，那么您只需要检查响应于该特定操作而改变状态的 Reducers。*

### [](#2-using-flux-stores-as-glorified-globals-for-exposing-state-to-multiple-components)2。使用 Flux Stores 作为美化的全局变量，将状态暴露给多个组件

#### [](#why-is-it-bad)为什么不好？

当需要一个全新的对象类来允许基于同一状态呈现两个视图时，你真的应该质疑你的架构。这种开销鼓励将共享状态放在父组件中，增加了子-父耦合和泄漏状态，违反了关注点分离。

#### Redux 如何缓解这种情况？

Redux 只有一家店，是的，它是全球性的。那这怎么更好呢？默认情况下，所有状态都是全局的(尽管希望以一种合理的方式命名——这是我将来想在博客上写的另一件事)。有了这个已经存在的全局状态，我们只需要对状态做一个新的引用，就可以跨组件共享相同的状态。

> 旁白:在穿过通往 Val Thorens(或任何山脉的任何地方)的山路的公共汽车上打字是一种很好的触摸练习。我的直觉是不要感到恶心，这个过程是自我限制的。

无论如何...

### [](#3-managing-state-in-react-components-but-not-using-raw-thisstate-endraw-)3。管理 React 组件中的状态，但不使用`this.state`

#### [](#why-is-it-bad)为什么不好？

React 组件的渲染函数应该只基于它的`state`和`props`。使用其他任何东西都是自找麻烦，通常以组件的过时渲染的形式出现。

#### Redux 做什么来缓解这种情况？

Redux 实际上并不关心 React，它和 Flux 一样，是一个完全独立于 React 之外的框架(或者至少它可能是)。

> 好了，自我限制开始起作用了...我会坚持下去。

一个好的通用经验法则是将所有呈现的状态保存在`state`中，并从存储中获取。当面对非 T1 状态时，一个很好的问题是为什么我们不能把这个状态放在 T2。

例如，答案可能是性能。有可能在应用程序中发现了一个瓶颈，它的某些部分的统计数据更新非常频繁，导致许多重新渲染。为了减轻这一点，我们很想根本不在`state`中使用它——特别是如果它没有被显式呈现的话(也就是说，它被用于决定呈现什么的过程中，但是没有“关于”它被呈现)。

这种诱惑是邪恶的，性能优化应该在别处寻找。

但无论如何，正如我所说，Redux 并没有给出一个飞行通量。

### [](#4-using-an-asynchronous-dispatcher-and-dispatching-when-handling-dispatches)4。处理分派时使用“异步”分派器和分派。

#### [](#why-is-it-bad)为什么不好？

处理派单时的派单实际上是一种副作用。不再有“此调度将导致状态改变”的简单性。而是“此调度将导致另一个调度，这将导致……”。

没有理由在派单期间执行派单。没有。零。让我解释一下为什么...

当处理一个动作时，通量存储能够修改它自己的状态。但是假设我们想改变它的状态，做一些异步工作，然后再改变它的状态。

我们不能简单地异步改变它的状态——我们只能在处理分派时改变状态。所以我们使用异步调度程序进行调度。然后由存储处理第二个分派，结果是状态发生了另一个变化。

虽然这可能行得通，但要跟踪和维护却非常困难。没有理由让异步工作在商店中完成，在启动异步调度时有更好的概念可以使用，即[异步动作创建者](https://redux.js.org/docs/advanced/AsyncActions.html#async-action-creators)。

#### Redux 做什么来缓解这种情况？

我学习了 Redux 如何工作，以及为什么理解 Flux 在处理调度时不允许调度是为了达到什么目的。

Redux 中与此类似的情况是，在根据以前的状态计算新状态时会产生副作用。这在 Redux 中从根本上来说显然是一件坏事，令人痛苦。除了计算下一个状态之外，根据处理的动作将前一个状态转换到下一个状态的 reducer 究竟为什么要做其他事情呢？

## [](#repenting-for-my-sins)为自己的罪恶忏悔

在 Riot 上引入了专门的 Flux stores 之后，我渴望展示它在可读性、可维护性等方面的优势。然而不幸的是，很难理解通量是如何或为什么防止副作用的。这导致了一个相当混乱、难以维护(坦率地说，有很多错误)的 Flux store 的实现。

我知道我们误解了 Flux，需要学习 Redux 来理解它。

希望今后我们可以继续使用 Flux，并对它执行的规则有新的认识。也许从长远来看，我们将能够轻松地转向 Redux。