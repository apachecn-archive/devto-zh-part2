# 干净、干燥、坚固的意大利面

> 原文:[https://dev.to/codemouse92/clean-dry-solid-spaghetti-1lgm](https://dev.to/codemouse92/clean-dry-solid-spaghetti-1lgm)

看看你，带着你现成的项目！你对你的风格和标准的一致性，以及你对干燥和坚实的严格坚持感到非常自豪。您已经进行了测试，您的错误被消除，您的用户和 API 文档被润色。你的代码太干净了，闪闪发光！

我有坏消息。你的代码库可能仍然很糟糕。

## 那么，有什么意义呢？

澄清一下，我并不反对我所描述的任何事情。TDD、DRY、SOLID(以及一大堆其他 fancypants 缩写词)的原则都有它们的位置。文档、标准和风格很重要。如果你真的做到了所有这些，你应该受到表扬。

也就是说，我们很容易被吸引人的首字母缩略词和“编写干净代码的十大方法”所吸引，忘记了我们为什么要做这些事情。如果你没有专注于这个目标，以上所有这些最终都会变成`null`。

不管目的、语言或方法如何，所有软件都必须满足两个标准:

1.  软件必须完成它的既定目标。

2.  软件必须对未来的开发者是可维护的(因此是可读的)。

问题是，要完成#1，代码只需要编译，通过测试，并按预期工作。即使设计糟糕的代码也能做到这一点。我们在第一点上花了太多时间，我们经常把第二点留到事后再考虑。充其量，我们阅读了一些关于`dev.to()`的文章，将一切归结为几个易于遵循的规则，让我们在可维护性方面自动驾驶。毕竟，让软件*做事情*要有趣得多。

但是干净、干燥、坚实的意大利面仍然是意大利面。其实是最坏的那种！你可能知道我在说什么:你煮意大利面，沥干水分，然后把它放在锅里，天知道放了多久。它当然是干净的，而且当你记得它的时候，它也是一种不能食用的干物质。你不能用意大利面条做下蹲。

同样，不可维护的代码库从一开始就注定了。新功能很难添加。bug 几乎不可能修复。新的贡献者被吓跑了。任何被迫维护代码的人都要承受数天或数周的痛苦，因为他们要从混乱的堆中一条一条地挑出程序逻辑。

在我们的代码遭遇这种令人倒胃口的命运之前，让我们看看我们善意的可维护性原则变坏的几种方式。

## 干旱遇上荒地

[![Desert](../Images/27810222c853058a951c8048c1491ca3.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--bWl34_3x--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/gdhmnh5po6c6fhh195bf.gif)

> 干:不要重复自己

这个方便的首字母缩略词被自由传播。这是一个非常明显的概念。不要把同一个代码写十六遍，甚至六遍，而是放到一个函数里调用！

然而，必须有一个界限。我见过这样的代码库，为了找出一个单一目标函数做了什么，我不得不跨越多个文件跳转到不少于 24 个其他函数和宏。更糟糕的是，我甚至不确定数百个链接文件中的哪一个包含调用堆栈的下一部分。一切都被抽象到了第 n 个程度，使得代码库完全不可读。

SOLID 的“依赖倒置原则”也有同样的风险。我们可以将事情抽象到几乎每个函数都只调用其他函数的程度。

在这一点上，没有人会赢。性能受到影响(听说过“指令缓存未命中”吗？)可读性急剧下降。破解代码花的时间比预期的长得多。

这里的修复并不简单。干燥是重要的，但它需要仔细的辨别。在你抽象出一些东西之前，你需要考虑成本。然后，你需要仔细确定抽象功能的最佳方式。让追踪变得容易。

## 清理犯罪现场

我明白了。你想要一个*一尘不染的*代码库，谁能怪你呢？它看起来很舒服，让你看起来像一个名副其实的编程天才。然而，在清理的过程中，我们往往会犯一些可怕的错误。

[![Vacuum Catches Fire](../Images/7fbd417c5242d9e18dca5c295d3dc9dc.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--FeWuUwR8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/8mjq22kr2feua7r4kaqc.gif)

### 评论太少

也许最糟糕的是删除(或永远不放入)**意图评论**。许多人认为“注释与代码不同步”。有几个标准自豪地宣称注释应该很少，如果有的话。“写自注释代码！”他们规劝。

问题是，对于不熟悉代码的人来说，没有一个代码能够回答自己的“为什么”。我坚信并积极实践[评论表明意图(CSI)](https://standards.mousepawmedia.com/en/latest/csi.html) 的原则。总之，**每一个逻辑块都应该有一个注释描述它的意图，它的“为什么”。在这一点上，我们不能相信我们的直觉，因为在写作的时候，几乎所有的事情对我们来说都是显而易见的。事实是，没有人能读懂你的心。**

对于那些声称评论不同步的人，我认为只有在你放任的情况下才会发生。实现像 CSI 这样的注释标准意味着您将这些注释作为代码评审过程的一部分。声明的意图和实际功能之间的不匹配应该*总是*被视为 bug 并得到解决。在大多数情况下，没有意图注释的代码甚至不应该被允许进入代码库。

请注意，这并不意味着你要全力以赴，用重复代码的多余注释来搅乱你的代码。我发现通常最好是先对所有事情进行评论，提交，然后让这些评论搁置几周或几个月。一旦你对代码的熟悉逐渐消失，你将能够澄清和/或删除多余的“什么”风格的注释。

### 太多可怕的名字

自文档化代码是一件美妙的事情。它允许我们从名字中看到函数或变量的用途。我们需要遵循这个事实是不言而喻的。

但是当它走得太远的时候呢？

```
RtlWriteDecodedUcsDataIntoSmartLBlobUcsWritingContext(); 
```

Enter fullscreen mode Exit fullscreen mode

如果我不得不维护这样一个函数的代码库，我宁愿辞职，成为一名全职音乐家。([胃强的话还有更多](http://ashutoshmehra.net/blog/2010/02/long-function-names/)。)

在描述性名称和*可读性强的*名称之间找到平衡。

当我们谈到这个话题时，如果你在代码中使用匈牙利系统，你需要马上停止。在你做任何事情之前，使用 Find & Replace 并去掉那些无用的类型前缀。这从来都不是查尔斯·西蒙尼想要的。(相比之下，Apps Hungarian 实际上是自我记录命名。查一下。)

### 太少...一切

第二，干净的代码通常是“简洁”的代码，但是在这里很容易走极端！虽然您可以在三元运算符中将整个条件语句折叠成嵌套的 lambda 表达式，但是其他人能读懂吗？

太多时候，我们试图以牺牲真正好的代码为代价来表现自己的才华。仅仅因为你*能*并不意味着你*应该*。在简洁和易读之间取得健康的平衡。

### 空白太少

最后，请不要缩小你的工作代码库。永远不会。句号。那不干净，那是可维护性自杀。事实上，除了特定的、客观的、可验证的商业案例(例如优化或混淆)，它在任何情况下都是一个坏主意。迟早有人需要通读代码来诊断错误或复制功能。要善良——不要缩小。

## 当固体变成了愚蠢

[![Hitting A Wall](../Images/675c499d87faffe0db7eaaccd8777c7a.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--yU1EDE0s--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/lcr9bx0x1wdvha48vto8.gif)

在面向对象编程中，坚实的原则非常有用。但是，都不能盲目套用。

你将要读到的故事是真实的。为了保护这些白痴，名字被改了。

我曾经与一个相当流行和广泛的网络平台合作过。我可以相当坚定地说，这个代码库完全遵循了坚实的原则。然而，我也坚持认为，整个规范的来源应该被用作一个无人驾驶的太阳任务的测试载荷。这是迄今为止，我见过的最糟糕的代码。然而，从固体的角度来考虑它...

*   单一责任原则:每个类都有一个特定的责任。还有很多课。成千上万。

*   开闭原则:每一个添加到代码库中的额外特性都是以*扩展*的形式出现的，并且总是通过继承。是的，*永远是*的传承。

*   Liskov 替换原则:每个类都可以被一个父类替换，一直到链的顶端。没有例外。

*   接口分离原则:你只需要使用你需要的特性。一切都是基于单继承的，所以你永远不需要仅仅因为使用 y 就导入 X。

*   依赖倒置原则:一切都是抽象的。几乎所有的东西。它被数据驱动到了极致。

哇，100%符合固体！然而，这是一个无法维持的噩梦。每一个类最终都是从同一个家谱中继承出来的，有时有几百层。要写一个类，你必须先通读其他 99 个类。然后，如果一个 bug 修复或优化发生在链的高层(请注意，没有人会费心记录下来)，它会破坏它下面的所有东西。因此，在 3.2 版本中运行良好的代码在 3.3 版本中将会完全崩溃。

结果，贡献者害怕在继承链的更高层改进可怕的代码，害怕他们会破坏一切。文档在完成之前就已经过时了。平台上写了几十本书，出版的时候马上就没用了。

是固体公司的错吗？绝对不行！这表明，SOLID 并不是可维护性的灵丹妙药。它的原则必须以常识和敏锐的洞察力来应用。任何有 OOP 经验的程序员都知道，我描述的这种继承结构是糟糕的设计，但是负责这个项目的大型开源团队正是这样做的。他们有一个完全坚实、完全枯燥的代码基础，然而我认为它是计算机历史上最差的产品代码的候选。

## TDD:测试驱动的灾难

[![Three Stooges Doing Chemistry](../Images/0f1d4d9998a82a906635930538a794b9.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--BWydHMiX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/ao4xjxrvlat1t7sj1qge.gif)

老实说，任何能够为他们的测试管理 100%代码覆盖率的人都是天才。我不认为我接近了。然而，虽然我通常编写测试，但是我害怕采用 TDD 是有原因的:我已经看到太多的代码库在悬崖上跟随它。

测试的目标应该是检测产品代码中的错误，但是代码的目标应该是通过测试，而不是通过测试！我认为 TDD 特别容易混淆这两个目标。如果你已经编写了测试，你会本能地开始编写通过测试的代码，而完全忽略其他事情...比如功能性、可读性和可维护性。可能会变得如此短视地专注于单元测试，以至于你简单地编写代码来检查它们是否“通过”，甚至从来没有看到你的代码正在变成一个可怕的散列，直到为时已晚。

和往常一样，这不是对 TDD 的猛烈抨击，而是对它的实践者(以及其他编写测试的人)的警告。为了防止这种狭隘的观点，我建议如下:

在你的代码已经写好并且看起来功能正常之后，盲目地写你的生产测试。我所说的“盲目”是指“在你写代码的时候不要去看它们”。在纸上，分解你记得你的代码应该做什么，不应该做什么。列一个清单，并为每个部分写一个测试。确保每个测试都有明确的通过和失败条件。不要宽恕。[对你的代码做可怕的事情](https://blog.codinghorror.com/doing-terrible-things-to-your-code/)。

实际上，这为我做了两件事:

1.  在知道我的生产测试还不存在的情况下，我专注于编写好的代码，而不是欺骗我的小预定看门人。

2.  我用这种方法捕捉到了很多错误和设计缺陷...我指的是*很多*。在我的盲测中，超过一半的致命错误和边缘案例浮出水面。

如果你全心全意地拥抱 TDD，并且在编写代码之前编写测试，我推荐超越一步。删除你的原始测试，然后盲目重写。只允许你自己记录他们在测试什么功能，而*不要*记录他们是如何测试的。

## 样式超过功能

[![Pointless Lightsaber Twirling](../Images/7bb70dcb6232ab5c009cf619030dbf88.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--t2OZlx9r--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/h2hvodh9jk452o7g7lbh.gif)

样式标准非常棒，它们让代码读起来更加愉快。然而，即使这样也可能走得太远。虽然我们应该遵循我们的风格标准，但是当可读性或可维护性要求时，我们需要准备好打破它们。这里有几个例子，以及它们揭示的原理:

*   在 80 或 120 个字符处断开会使该行更难解析吗？(是的，这些很少见，但确实发生过。当这样做会提高可读性和/或可维护性时，请允许自己的样式异常。

*   喜欢一行无括号的条件句吗？编程错误也是如此。小心你使用时尚快捷方式的地方。有时候括号就是比较安全。

*   你必须修改代码来保持你的风格吗？(是的，这种情况会发生！)*住手！* **风格本身永远不需要对你的代码进行功能性的修改。**

*   你是在讨伐三元条件句吗？反过来说，你爱他们是因为他们让你看起来像一个阿尔法黑客吗？使用可读性、可维护性和功能性最佳结合的工具。将你的观点放在一边。

## 不包括常识

有很多非常有用的原则和标准可以帮助我们写出好的代码...但是不要相信炒作！它们都不是可维护代码的唯一正确答案。你总是需要积极地投入到制作好代码的过程中。

在编程中，意大利面已经够糟糕了，但坚实、干燥、干净的意大利面呢？这是最难解开的！