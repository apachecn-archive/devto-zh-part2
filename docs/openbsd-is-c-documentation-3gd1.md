# OpenBSD 是 C 文档

> 原文：<https://dev.to/apotheon/openbsd-is-c-documentation-3gd1>

当你作为一个程序员需要知道如何做某事时，StackOverflow 是事实上的标准去处。在网上搜索有关如何使用 C 编程语言检查文件行数的信息，可能会得到最相关的搜索结果。不幸的是，虽然编写好的、干净的、可靠的 C 并不需要很难，但是找到关于如何做好它的信息肯定是困难的，并且在 StackOverflow 上回答这些问题的人并没有被他们的技能或良好实践的知识所过滤。有时，排名最高的答案或被接受的答案甚至是针对该问题的最差答案。

我见过的最简单的行计数算法的例子是在事后看起来很明显的地方:`wc`命令行实用程序的源代码。弄清楚在一个好的`wc`实现中，如何处理`-l`选项，剩下的就是根据您的需要对其进行调整。理想情况下，您找到的解决方案应该简短、简单、仔细(例如检查错误条件)、健壮、经久耐用且格式良好。

OpenBSD 社区的 C 编码标准是您所能找到的最高和最实用的标准之一，当有人做出关于实现的决定，而其推理在代码本身中并不明显时，您几乎可以肯定地看到该推理清楚地记录在代码注释中，这也可以从总体上教会您如何成为一名优秀的程序员。根据我的经验， [OpenBSD 源代码树](https://github.com/openbsd/src)是这类问题的最佳起点，也是我最近检查自己如何计算行数的地方。

OpenBSD 是一个很好的起点，如果您需要的只是一些关于使用什么函数的指导。你可能听说过`atoi()`不是一个你应该使用的函数。如果你以前没听说过，现在你听说了。互联网上有一些很棒的资源描述了为什么在优秀的 C 编程中使用`atoi()`是一个糟糕的想法，以及大量其他被否决的函数。你应该用什么来代替？

这是一个好问题，事实证明 OpenBSD 在几乎所有情况下都有答案，在联机帮助页中。在 OpenBSD 系统上使用`man atoi`命令，您会发现文件的一个警告部分谈到了`strtol()`、`strtoul()`和`strtonum()`作为替代；有关更多详细信息，请查看他们的联机帮助页。(剧透:`strtonum()`几乎总是你想要的。)这同样适用于为什么通常应该使用`snprintf()`而不是`sprintf()`(在关于这两个函数和一系列相关函数的注意事项一节中有解释)，为什么应该使用`strlcat()`而不是`strcat()`(在`man strcat`的描述一节中)，以及为什么应该使用`strncmp()`而不是`strcmp()`(它们共享一个联机帮助页，其中包括关于为什么选择一个而不是另一个的信息)。如果您不容易访问 OpenBSD 系统，您也可以随时在线查看 [OpenBSD 手册页](http://man.openbsd.org/cgi-bin/man.cgi)。

“检查 OpenBSD”技术对于在所有情况下找到做事情的最佳方法来说并不完美，但是这是获得比您可能找到的更好的习语或函数选择的最快、最容易的方法。在大多数情况下，OpenBSD 代码库或 OpenBSD 的联机帮助页中的内容是您可能得到的最好的内容。一个小缺点的例子是，虽然`malloc()`和`calloc()`的联机帮助页在“注意事项”一节中给出了在大多数情况下选择`calloc()`的很好的指导，但它没有明确说明最重要的原因之一:自动清空您刚刚分配的内存，以保护剩余的数据不受系统上以前运行的软件的影响(例如)。该联机帮助页还谈到了`calloc()`的初始化开销，但是由于晦涩的实现细节的原因，`calloc()`通常比`malloc()`快*。*

 *然而，在网上搜索 C 语言中分配内存的最佳方式时，你可能根本找不到这种东西，可能除了搜索所有关于`malloc()`和`calloc()`如何工作的血淋淋的细节。事实上，StackOverflow 的答案会在`calloc()`会更好的地方给出`malloc()`的解决方案，这有助于说明我的观点。有很多关于 StackOverflow 的信息，但是请读者注意。对照 OpenBSD 源代码和文档检查答案。

总之，当你需要写 C 的时候，OpenBSD 就是优秀的 C 文档。*