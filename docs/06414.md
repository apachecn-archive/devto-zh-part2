# 榆树 0.19 打破了我们💔

> 原文:[https://dev.to/kspeakman/elm-019-broke-us-卡恩](https://dev.to/kspeakman/elm-019-broke-us--khn)

昨天发布了 Elm 0.19。每个层次都有大量的突破性变化:配置、工具、库、语言。但是这些并不是这篇文章的主要内容(编辑:Elm 提供了一个升级工具来自动修复这些东西)。对我的团队来说，这次发布伤透了我们的心。

两个变化导致了众所周知的“压垮骆驼的最后一根稻草”:移除自定义操作符和本机模块。起初我只看到了自定义操作符的移除，我在这里发布了我对此的反应[。在](https://gist.github.com/evancz/769bba8abb9ddc3bf81d69fa80cc76b1#gistcomment-2685482) [0.19 发行说明](https://github.com/elm/compiler/blob/master/upgrade-docs/0.19.md)中没有提到移除原生模块，所以我直到今天才发现。我只是碰巧想起来了，于是搜索了一下[这个帖子](https://discourse.elm-lang.org/t/native-code-in-0-19/826)。

关于原生模块的帖子是在三月份发布的，我怎么会不知道呢？

## [](#community)社区

不久前，我退出了榆树社区。我当时没说太多，但我会分享原因。我喜欢 Elm 平台并使用它，但是觉得社区的管理方式太令人沮丧了。Elm Github 问题的处理方式决定了基调。他们中的许多人被锁定，以防止不愉快的反馈，或者因为他们是只有少数几个受祝福的贡献者的个人物品，即使他们是在公共场合。如果你发布了一个问题，你很可能会因为没有“正确地”做事情而受到惩罚。恰当地意味着对错误进行严格的 SSCCE，或者参与公共论坛的角斗士竞技场以寻求想法/请求/建议，或者如果你做了额外的额外的努力以被信任为贡献者，你可以忘记这两件事。我说角斗士竞技场，但是**榆树社区总体来说真的很好**，尤其是帮助新人。然而，有不少人已经拿出了他们的统治者，并准备拍击那只手来执行埃文(榆树的创造者)说过或没说过的话。因此，在论坛上发表“想法”或“反馈”很有可能会遭到指责。反过来，这也证明了社区中并没有对你的帖子达成一致，所以可以忽略它。所以“先在论坛上发帖”规则是忽略反馈的有效方法。

显然，自从 Elm 论坛转移到(编辑:Reddit 和)话语，那里的线程也可以被锁定。当 mods 知道 Evan 不想听到你在某个特定问题上的不同意见时，他们可能会先发制人地将帖子锁定在可能出现的地方。最后，感觉 BDFL 的 D 在那边被看得太重了。所以我很欣赏这个产品，但大部分时间都远离社区，也没有注意到透露变化的帖子。

平心而论，我自己也有过不好的经历，在这方面也有过错。但作为旁观者，我在 Elm 的旧 github 和谷歌团队中多次观察到这种不受欢迎的模式。在我参与的其他项目中，情况并非如此。

## [](#control)控制

取消定制运营商表面上是为了 Elm 的利益。然而，在解释删除它们背后的原因的帖子中，估计有 5%的用户有它们。使用它们的几个原因和其他语言一样(任务链接、解析)。最后，特定的自定义操作符得到了 Evan 的支持，被允许作为例外保留下来。但是普通 Elm 用户认为对他们的用例有效的定制操作符对 Elm 来说是“坏”的。好的...

理论上我还是可以在 0.19 通过 monkey 补丁注入原生模块。(Javascript，对！)然而，通过消除死代码，除非您关闭优化，否则猴子修补可能会有点困难。但是真正的问题是原生模块仍然存在。它们只是为少数 Elm 贡献者保留的。我们其他人不应该访问这个专家功能。显然，我使用的总共 40 行本机代码将彻底破坏 Elm 社区。即使没有其他合理的方法来做我需要的。好的...

微小但具有指示性:Evan 多次发帖告诉用户改变他们谈论或思考 Elm 的方式。(公平点:他对这件事很好，也有合理的地方。但是仍然...象征性的。)例子:不要用组件这个词。不要说“原生”；改为说“内核”。联合类型现在应该称为自定义类型。但是你千万不要回复他的帖子——总会有一个结尾部分告诉你只有几个可以接受的回复，或者干脆不回复。好的...

考虑到上述所有情况，我们正在形成一幅图景:作为 Elm 用户，我们可能会受到过分的微观管理。反馈(嗯，不同意)不受欢迎或考虑，即使它是决定性的和大量的，像在本机模块上。Evan 决定他只是不喜欢他看到的 Elm 用户所做的事情(即使它在类似的语言中有可信度，比如自定义操作符)，它在下一个版本中会被禁用。要么接受，要么滚。尽管 Elm 为我们做了很多令人惊奇的事情，但对于一个工具链来说，这是非常激烈的行为。我的团队不希望出现这种情况。

## [](#what-now)现在怎么办？

在我看来，我们有几个选择。

### [](#keep-using-018)保持使用 0.18

我对 0.18 没有任何大问题。我们可以避免变更日志中指出的损坏的东西(比如数组)。然而，这不是一个长期战略。看起来 0.18 不太可能再出现一个错误修正。旧版本的工具(比如 Create Elm App)最终会停止维护。与此同时，计算机科学和网络也在不断进步。

### [](#monkey-patch-019)猴子补丁 0.19

由于死代码消除，通过 monkey 修补将以前的“本机”代码放入有一些未知因素。但是更深层次的问题是，通过迁移到 0.19，我们仍然对我们工具链的未来感到不稳定。

### [](#wait-for-an-elm-fork)等一个榆树叉

许多树的名字可能仍然可用(如金合欢、白杨等)。不幸的是，我们没有资源来维持一个分叉。但似乎很可能有人会得出与我们相似的结论，并在一个地方，他们想创造一个。即便如此，这条路还有很多未知。

### [](#wait-for-elm-to-solidify)等待榆木凝固

大多数项目都到了固化的阶段。这意味着要努力保持向后兼容性。如果 Elm 决定在某个时候这样做，我们可以评估最新的版本在哪里。也许到那时，就不再需要被剥夺的自由了，所以这将是一个有争议的问题。然而，可能只要编码器和解码器是处理 JSON 的唯一官方方式，我们就需要原生代码。20 行本机代码为我们节省了数百行编码器和解码器。

### [](#switch-to-something-else)切换到别的东西

我所知道的另外一个模型-视图-更新平台是寓言-Elmish。它使用 F#，反正我们已经在 API 中使用了。不幸的是，F#不是一门纯粹的语言。所以写纯函数需要纪律。鉴于 Elm 在最近的一些改变中已经将 purity 带得太远了，F#对于前端来说还不够远。但是 F#对于 API 来说很棒，因为它们是关于集成外部系统的(例如 UI、数据库、电子邮件、文件等)。如果 F#有很多开销来执行副作用，那么在那里使用它会更困难。*为用例找到合适的平衡点很重要。*反正还是摆在桌面上的一个选项。

在某个时候，还可能出现另一个 MVU 平台。我相信 ClojureScript 有一个类似于 MVU 的库。我不太想回到基于组件的系统。(没错，纯函数 MVU 就是这么好。)

## [](#conclusion)结论

团队一致认为坚持 0.18 是我们目前最好的选择。我们有一些应用程序即将推出，我们将用 0.18 创建，忽略 0.19。我们将尝试寓言。我们将会看到另一个 MVU 风格的平台是否会出现。最终 0.18 将开始腐烂，我们将需要切换到其他东西向前发展。

我们认为这种情况确实令人沮丧。我们爱榆树，从来不想用别的。但是我们已经开始觉得和 Elm 的关系不稳定了。💔