# UX API 和定制微服务

> 原文:[https://dev . to/peibolsang/UX-APIs-and-custom-micro services-54af](https://dev.to/peibolsang/ux-apis-and-custom-microservices-54af)

还记得一周前[我谈到 UX 原料药的概念](https://dev.to/peibolsang/they-call-it-backend-for-frontend-51nh)吗？或者换句话说，后端对前端模式似乎解决了 REST-API 驱动的 spa 中的一个常见问题:资源表示在语义上不知道 UX 需求。

嗯，在与我的同事们进一步讨论和实验之后，我在这里列出了一些关于这种方法的不太积极的结论。让我解释一下。

# [](#first)第一

前端模式的后端在其最纯粹的解释和实现中，倾向于耦合 FE 和 BE。更不用说你可能最终需要每个频道(网络、手机、聊天机器人)和每个应用都有一个 BFF。你明白重点了吗？可维护性地狱。

所以你开始寻找一个解决方案，使你的 API 适合你的 UX 需求，结果你又得到了另一个整体；一个组件，在这里你开始为一个具体的应用程序的具体通道编写所有的获取和修改专用逻辑**。我们需要小心。如果它像反模式一样说话，像反模式一样走路，那么它很可能就是反模式。**

# [](#second)第二

[GraphQL](https://graphql.org/learn/) 。围绕它有很多大惊小怪，我相信这是当之无愧的。但是要小心你在哪里和如何使用它。在我们的例子中，我们考虑使用 GraphQL 作为 REST APIs 的门面，这似乎引发了一些问题:

1.  **获取**:的确，通过使用 GraphQL，我们解决了一个常见的资源提取不足(UI 中所需的数据来自各种 REST 资源，因此您必须执行多次获取)和过度提取(当您只需要几个属性时，下载一个完整的资源)的问题。但是有一个折衷，因为所有的 GraphQL 通信都是通过 POST 隧道传输的，其中过滤标准嵌入在主体请求中。这使得所有的服务器调用更加繁重，并可能导致性能下降。
2.  **适配**:当你想实现一个伪装成 REST 级 API 的 GraphQL API 时，会有一个问题，这与 [HATEOAS](https://es.wikipedia.org/wiki/Hateoas) 有关。简而言之，您可能最终不得不在您的 facade GraphQL API 中复制完整的原始资源网络，即使是那些没有受到改编影响的资源。这是 API 消费者所需要的:我们的 API 驱动的 spa 依赖 HATEOAS 来实现资源的可发现性，因此需要保留资源之间的所有超媒体链接。

# [](#simplest-solution)最简单的解决方案

经过几次漫无边际的讨论，解决方案一直摆在我们面前。我们正在推动将我们的 monoliths 转变为微服务，因此显而易见的方法是构建一个由 REST API 实现的简单的**定制**微服务。

*   这就像一个代理 API，它将基于客户端请求实现所有的获取和适配逻辑。
*   它可能不会在应用程序之间重用，但肯定可以在同一个应用程序内的频道中重用。
*   它有助于通过替代实现来创建用于测试的模拟资源。

我仍然喜欢将这个定制微服务提供的 API 标记为 UX API 的想法。如果只是因为他们在语义上知道 UX 的需求，那么组件在语义上耦合到 UI 也是可以的。

叹气...