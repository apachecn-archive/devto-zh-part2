# 架构决策记录

> 原文:[https://dev . to/tsalikispk/architecture-decision-records-14b 1](https://dev.to/tsalikispk/architecture-decision-records-14b1)

在[之前的一篇文章](https://www.droidship.com/posts/branch-by-abstraction/)中，我们解决了在你的系统中逐步进行大的改变的问题。在重构过程中，你可能会遇到很多问题，但最大的问题之一是，你如何应对你无法理解的过去的决定？您是否接受它，并承担继续支付相关技术债务的风险？还是丢弃它，冒着丢失一些不应该丢失的重要语义的风险？

如果你足够幸运，做出这个决定的人会在一两张桌子之外。另一方面，上面的决定很有可能是很久以前做出的，而且那个人早就离开你现在工作的公司了。保持技术决策不丢失的唯一方法是记录它们。但是在哪里，怎么做呢？

大多数情况下，将决策保存在某种维基中是行不通的。大型文档文件很少与代码一起更新，当大多数开发人员不得不离开代码并过滤大型文档时，他们就会失去注意力。更重要的是，由于它们的大小，您不能将这种文件保持在版本控制中。

## [](#documenting-with-architecture-decision-records)用架构决策记录进行文档化。

拥有成功文档的关键是在小文件的版本控制中保持更新。这是迈克尔·尼加德在他的[架构决策记录](http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions)(从现在开始 *ADRs* )中提出的。ADR 是保存一段时间内所做的架构决策的文本文件，具有以下格式:

*   **标题:**决策的小型描述性标题。
*   背景:对做出决策的约束条件的描述。
*   **决定:**实际决定。
*   **状态:**该决定是否被提议/接受，或被另一个决定修正/取代。
*   **后果:**这个决定会产生的后果。

保存 ADR 是一项强大的技术，因为它不仅记录了决策，还记录了决策是在什么情况下做出的，并记录了决策实际做出时的后果。

即使当一个决定被另一个决定取代或修改时，迈克尔·尼加德建议你永远不要删除它，而是将其标记为被新决定取代。通过这种方式，您可以看到代码是如何随着时间的推移而发展的，并且您还可以从版本控制中检查做出决策的提交，并查看是什么力量驱使作者做出决策。

在展示适当的工具来成功地记录我们的决策之前，让我们问自己，我们应该记录什么样的决策？如果我们最终保存了每一个小细节，那么保持文档尽可能小并且切中要点的目标就失败了。正如迈克尔·尼加德自己所说，我们应该做出的决定是:

> 影响结构、非功能特性、依赖性、接口或构造技术的那些

## [](#tools-for-using-adrs)使用 ADR 的工具

所以，假设你现在确信保存 ADR 是一项值得一试的技术。你应该如何实施？幸运的是，Nat Pryce 提供了他的 ADR 工具。ADR 工具是在 markdown 中创建 ADR 的一组命令行。安装说明可在[这里](https://github.com/npryce/adr-tools/blob/master/INSTALL.md)获得。安装后，你只需输入以下命令:

```
adr init your/documentation/directory 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这将创建第一个 ADR，保存在 markdown 文件中。同样值得注意的是，记录的第一件事是你开始使用 ADR 的决定。

当您要添加一个新的 ADR 时，您只需给出以下命令:

```
adr new Name of the decision 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

关于如何使用 ADR 工具的更详尽的描述可以在这里[找到](https://github.com/npryce/adr-tools)或者你可以使用命令行:

```
adr help 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

除了上面的 help 命令之外，Nat Pryce 还将工具开发过程中做出的决策记为 [ADRs](https://github.com/npryce/adr-tools/tree/master/doc/adr) 。这是 ADR 在现实生活中使用的一个有用的例子，它可以在我们(老实说，并不那么吸引人)进行有意义的文档记录的过程中指导我们。

## [](#final-thoughts)最后的想法

保留 ADR 似乎是保存决策的好方法，这些决策将在以后的重构过程中提供良好的洞察力。很有可能你不是重构的负责人，或者即使你是，伊格尔森法则也会适用:

> 伊格尔森定律:任何你自己的代码，如果你已经六个月或者更长时间没有看，那也可能是别人写的。
> 
> —编程智慧([@ code Wisdom](https://dev.to/codewisdom))[2017 年 12 月 10 日](https://twitter.com/CodeWisdom/status/940007477642432514?ref_src=twsrc%5Etfw)

在开始对影响系统架构的决策进行编码之前，我认为最好将它作为 ADR 写下来(就像在 TDD 中的实际实现之前首先添加一个测试一样)。

通过这种方式，你有义务记录你做出决策时的约束条件，作为 ADR 的*背景*，并记录*后果*，这样你就可以验证你即将引入的变革是建立在坚实的基础之上的。

更重要的是，即使你改变了主意，想用另一个决定来修改它，你也已经把它记录下来了。下一个看到文档的人将会看到一连串的想法，而不是跳过一些步骤的梯子。决策会更有意义，那个人会更好地理解它们，并接受或修改它们。