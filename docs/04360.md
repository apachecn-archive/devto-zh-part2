# 原子文件修改

> 原文:[https://dev . to/martinhaeusler/forward-atomic-file-modifications-2a9n](https://dev.to/martinhaeusler/towards-atomic-file-modifications-2a9n)

这篇文章将与我以前的文章大不相同，原因有二:

1.  我们将讨论一个相当具体的低级主题
2.  我还在研究细节，所以欢迎任何意见，如果我哪里错了，请纠正我。

# [](#introduction)简介

你们中的一些人可能知道，[我对数据库](https://github.com/MartinHaeusler/chronos/tree/master/org.chronos.chronograph)情有独钟。特别是提供 **ACID** 交易的数据库:

*   tomic:要么应用一个事务中的所有操作，要么什么都不应用。没有中间(不一致)状态会持续存在。
*   **C** 一致:一个事务将数据库从一个一致状态带入另一个一致状态。这具体意味着什么取决于数据库范式，但通常涉及到数据与一些预定义模式的一致性。
*   隔离:当事务处于活动状态时，您看不到其他事务执行的任何更改。您是孤立的，就好像您是数据库中唯一的用户一样。
*   **D** urable:当一个事务`commit()`调用返回时，数据被写入磁盘，因此是持久的。

最近，我在研究事物的原子和 T2 持久的一面。让我们后退一步，暂时忽略我们正在构建什么样的数据库。如果我们想拥有原子性和持久性，这意味着我们最终需要**原子性地更新文件系统中的一个文件**。这个文件可以包含任何内容，从 B 树到非结构化的二进制数据块到元素列表——我们不在乎。我们想要做的就是以持久的方式自动更新它。

事实证明:说起来容易做起来难。

# [](#requirements-amp-assumptions)要求&假设

让我们快速回顾一下我们要去的地方:

*   我们有一个包含任意二进制数据的文件(让我们称之为**数据文件**)。我们希望对这个文件应用原子的和持久的更新。

*   为简单起见，我们假设在任何时间点只有一个进程和一个线程会同时访问它(即我们使用全局锁)。

*   我们必须断言，对文件的任何一系列更改要么被完全应用，要么被完全拒绝。即使在系统突然断电的情况下也是如此。

# [](#but-what-about-the-raw-file-endraw-apis)但是`File`API 呢？

人们很容易相信原子地修改文件就像下面这样简单:

1.  从文件系统 API 获取一个`File`指针/句柄/对象
2.  打开它(例如 C 中的`fopen(...)`)
3.  改变内容
4.  关上它
5.  释放文件指针/句柄/对象

实际上，操作系统(或者更确切地说:操作系统提供的文件系统)会干扰我们的计划。当你改变一个文件的内容时，**它们实际上并没有被写到磁盘上**。所有现代文件系统都有一个**写后缓冲区**。所以如果你修改了文件内容，实际发生的是文件的修改版本会在**主内存**的缓冲区中结束。如果在数据尚未写入磁盘时突然断电，**更改将会丢失**。

# [](#-raw-fsync-endraw-to-the-rescue)`fsync()`前来救援

几乎所有广泛使用的操作系统都有一个命令，强制操作系统**将**写后缓冲区刷新到磁盘。在不同的操作系统中，该命令的命名略有不同，但是为了本文的目的，我们将简单地将其称为`fsync()`(“文件同步”的缩写)。`fsync()`的约定是，当对`fsync()`的调用返回时，所有的文件修改都被写入实际的磁盘。因此，在`fsync()`之后，功率损失不再是一个问题。

所以我们执行我们的修改，然后添加一个`fsync()`？要是有那么简单就好了...可悲的是， **`fsync()`本身并不是原子**。

# [](#memory-pages)记忆页面

在操作系统的底层，所有文件都被分成**页面**。通常，所有页面都有相同的固定长度。一个页面的长度因操作系统而异。作为参考，在 Linux 中，默认情况下一页是 4KB。因此，如果我们的数据文件大小为 3GB，那么将会有相当多的页面。现在考虑一个传入的修改需要我们**触摸不止一页**。我们调用`fsync()`，当`fsync()`刚刚将前 20 页刷新到磁盘时，剩下的 80 页仍然在内存中。现在电源被切断了。结果是我们的数据文件现在被破坏了:它已经被部分地改变了，并且违反了原子性。

现在让我们再考虑一件事(好像前景还不够黑暗):我们在这一点上处理的是物理硬件。更新单个页面可能不是即时的。将会有一个时间帧(即使是非常小的时间帧),在这个时间帧中，硬件刚刚开始向磁盘写入内存页面的内容，但是还没有完成该页面。电源被切断。我们在磁盘上有一个写了一半的页面更新，还有另一个需要处理的损坏场景。

# [](#wal-logging)沃尔测井

解决上述问题的核心思想是拥有一个**预写日志** (WAL)。WAL 本质上只是一个驻留在磁盘上的文件，通常就在我们的数据文件旁边。WAL 文件跟踪所有需要应用到我们的数据文件的修改。例如，在键值存储的情况下，WAL 可能如下所示:

```
Transaction 1 start
Insert: "Hello" -> "World"
Insert: "Foo" -> "Bar"
Transaction 1 end

Transaction 2 start
Delete: "Foo"
Transaction 2 end 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

在将每个事务应用到数据文件之前，我们将它缓冲到 WAL 文件中。我们定期地**刷新**WAL 文件内容，并将它们应用于数据文件。这里最大的优势是我们提前知道将会发生什么变化。我们可以**复制**将受到交易影响的数据文件的所有部分，并保留这些页面的备份。如果出现任何问题(例如断电)，在系统下次启动时，我们可以通过用我们的备份替换(潜在的)损坏页面来**回滚**事务，然后一切又恢复正常。

# [](#case-closed)结案？

不幸的是，这不是原子文件更新的答案。虽然我们通过应用 WAL 方法解决了很多问题，但是还有一件事:WAL 存储在一个文件中。文件可能已损坏。断电时，文件更改可能驻留在操作系统的写后缓冲区中，导致我们丢失数据。

这就是我目前的困境。`fsync()`是一个相当昂贵的操作(即需要相当长的时间来完成)，因此我们无法负担对每个交易的数据文件执行`fsync()`。幸运的是，我们可以在 WAL 文件中对它们进行批处理，并定期刷新。然而，由于 WAL 也是一个文件，我们如何确保我们对 WAL 文件的更改确实被写到磁盘上呢？我们还必须**调用沃尔文件**上的`fsync()`。令我震惊的是，我发现主流数据库(例如 [PostGreSQL](https://www.postgresql.org/docs/8.4/static/runtime-config-wal.html) )会定期调用 WAL 文件**中的`fsync()`。这意味着:即使你在交易中成功地调用了`commit`，在断电的情况下，你的数据仍然可能会丢失**。这显然违反了持久性方面，但这似乎是数据库工程师被迫在性能和安全性之间做出的权衡。****

尽管如此，仍有许多悬而未决的问题。例如，由于 WAL 只是一个文件，您如何保护自己免受 WAL 本身的损坏？我见过利用校验和的方法:如果提交的校验和不匹配，那么提交将被完全丢弃，因为 WAL 文件的相关部分可能已经损坏。不用说，这又违反了持久性原则，因为我们丢弃了由成功提交的事务写入的数据。

# [](#what-now)现在怎么办？

我发现关于这个话题的任何信息都很难得到。也许我用错了搜索词。任何指向这个方向的更多研究材料的指示，或者任何建议(如果我们这里有数据库工程师的话)都将受到高度赞赏。