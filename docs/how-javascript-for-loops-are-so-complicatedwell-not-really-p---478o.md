# Javascript For 循环为何如此复杂(其实不是:p)

> 原文：<https://dev.to/naveenkarthick/how-javascript-for-loops-are-so-complicatedwell-not-really-p---478o>

有没有想过，如果你深入了解实际发生了什么，你认为编程中最简单的事情怎么会变得如此复杂？是的，像 for 循环这样简单的东西可能有如此多的复杂性，今天我将解释一下。嘿，伙计们，我是纳文·卡厚，这是我在网上发表的第一篇文章。因此，最近我看到了一个来自谷歌 chrome 开发者的视频，解释了 Javascript for loops 可以变得多么复杂，以及我们如何不太注意所有“引擎盖下发生的事情”。然而，我个人觉得视频中没有很好地解释这种复杂性，所以我想为什么不写一篇文章，尽可能用最简单的方式来解释。就像他们会说的“如果你不知道简单地解释它，你就没有理解得足够好”。所以现在开始

让我们从一个简单的 for 循环开始

对于(var I = 0；i++中的{/3

console.log(一)；

}

现在上面是一个理想的 for 循环，输出应该在这里

0
1
2

但是让我们来看看这个 for 循环实际上是如何工作的。我们对 for 循环的一般理解是
Step 1 == >声明 var I；
步骤 2 == >赋值 I = 0；
步骤 3 == >检查条件
步骤 4 == >执行体；
第五步== >执行表达式；从那里开始，步骤 3，4，5 将重复，直到步骤 3 返回假。现在，上面的 for 循环就像我们想象的那样执行。但是现在让我们改变代码来使用闭包。

闭包:用最简单的术语来说，闭包是 javascript 中的一个概念，当函数 A 的定义是返回函数 B 时，即使被调用的函数 A 的执行已经结束，返回的函数 B 仍然可以访问在函数 A 的作用域中声明的变量。我知道我让这个闭包概念变得复杂了，但是再读一遍上面的句子，直到它变得有意义，或者如果事情仍然不清楚，我会推荐查看 youtube 视频解释闭包，因为那里有很多闭包，而闭包不在这篇文章的范围之内。

回到 forloop，让我改变 for 循环来添加闭包

for(var x = 0；x < 3；x++) {

setTimeOut(() => console.log(x)，1000)；

}

如果我执行上面的 for 循环，你认为我会得到什么？。好吧，如果你只是说
0
1
2
好吧，即使我也是这么想的，但是让我解释一下我们是怎么错的，但是如果你是对的，那么“做得好，你已经理解了闭包、var 的范围以及异步 javascript 是如何一起工作的”。

现在回来，你会在控制台上看到的输出将是
3
3
3

但是等等，我知道你会想，当 x 增加到 3 的时候，它甚至不会进入循环，那么 3 怎么会被记录到控制台。让我们先来看看什么是风险值。

Var :-
将一个变量声明为 Var 使其成为函数作用域，这意味着变量
1。)可以在声明它的整个函数中读取。
2。)在声明变量的函数中对变量所做的任何更改都会反映到整个函数中。
但是这里它没有被声明为函数的一部分，所以它只是指脚本运行的全局函数。

现在，既然我们已经理解了 var，如果我们回到 for 循环，下面是正在发生的事情。for 循环将如我们预期的那样运行三次，每次调用 setTimeout 函数来调用我们编写的回调函数，该函数只是在 1 秒钟的延迟后将 x 的值记录到控制台。setTimeOut 函数在一个单独的线程中异步执行，作为 chrome 浏览器中 web api 的一部分。

[![Just a "it's finally over meme" ](../Images/dcc35bb2f3e600d9bb2a336306befdbc.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--mpptDHYf--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://yt3.ggpht.com/a-/ACSszfGmrB0oTbIlFyyQmcptPL7pOUorV00x-EeOww%3Ds900-mo-c-c0xffffffff-rj-k-no)

(等什么？以前人们都说 Javascript 是单线程的！youtube 上有一些精彩的视频解释了为什么 Javascript 不是单线程的，或者至少解释了 Javascript 运行的环境，我现在不打算讨论这些东西，因为这已经超出了本文的范围。回来了....正如你现在看到的，因为变量是 var(函数作用域),当回调函数执行以打印出 x 的值时，x 应该已经增加到 3，循环应该已经结束。既然 x 是 var 范围的，那么即使在循环中打印 x，也会打印出 3，因为在函数中的某个地方 x 已经增加了，还记得我说过对 var 所做的任何改变都会反映在整个函数中吗？这就是为什么 3 会被记录三次而不是 0..一..2.希望这能解释为什么 var 在函数范围内对 for 循环有副作用。

现在我们仍然可以让上面的代码按照我们想要的方式执行。这里的问题是 x 是函数范围的，但是如果我把 for 循环改成这样呢

for(设 x = 0；x<3;x++) {
setTimeOut(()=>console . log(x)，1000)；
}

在这种情况下，上面的循环将输出

0
1
2

但是为什么呢？让我们来看看 let 的范围

let :-
将变量声明为“let”

1.)使其块作用域为
{
设 I = 0；
}
console.log(一)；

上面的代码会抛出一个错误，因为我不是 console.log()作用域的一部分；被处决了。
2。)与 var 不同，let 不能在其相同范围内声明

我们可以这样做

function(){
var I = 0:
var I = 1；

}
并且它将在 I 的值被重新分配的情况下工作良好，然而
{
让 I = 1；
设 I = 2；
}
会抛出‘我已经定义了错误’

现在，既然我们已经了解了 let 和 var 的区别，让我们来看看 for 循环到底是什么，相信我，发生了很多我们不知道的事情

/**现在读两遍
,因为 console.log 语句输出 0..一..2，即使 x 的值已经增加到 3。所以我们知道 setTimeout 回调函数执行的地方，那个块作用域内 x 的值和它被调用的时候是一样的对吗？。
**/
下面是 for 循环如何执行我们的 let 声明，
1。)for 循环为每次迭代创建三个独立的词法范围(块范围)。
2。)每当另一次迭代发生时，for 循环将值从一个词法范围复制到另一个词法范围。

为了更好地解释以上两个语句，让我们将代码分解成最简单的术语
,上面 for 循环的三次迭代如下

首次迭代:-

{
设 x = 0；
if(你的条件){
setTimeOut(()=>console . log(x)，1000)；
}
}
和 x 将递增，现在 x 的值被复制到下一个词法范围，用于第二次迭代，这将是

第二次迭代:-

{
设 x = 1；
if(你的条件){
setTimeOut(()=>console . log(x)，1000)；
}
}
x 的后递增运算符将再次执行，最终

第三次迭代:-

{
设 x = 2；
if(你的条件){
setTimeOut(()=>console . log(x)，1000)；
}
}

我们得到了为什么它输出 0 的答案..一..2 而不是 3..3..3 与 var 相反。但是问题仍然是后递增操作符是在哪个词法范围下执行的....哈哈，我们完全忘记了，对不对？。

后递增运算符是上述三个词法范围的一部分，还是在单独的词法范围内执行？答案是这样的

/**读两遍
"我们编写的表达式(在本例中是后递增操作符)在除第一个词法范围之外的每个词法范围的开头执行！"。
**/

等待....我知道你在想什么，for 循环在每次迭代中都是一样的，除了变量的值，对吗？不是这样的，我可以用一个简单的例子证明 javascript 以这种方式运行 for-loop，就在一个简单的 for-loop 后面，对吗？哈哈让我们开始吧！

第一次迭代打印的是 0，而不是 1，因此我们很确定表达式不是第一次迭代的一部分，但是等等？为什么表达式不能在每个词法范围的底部而不是顶部？这正是我所想的，但是仔细想想，x 是块作用域右
所以
{
让 I = 0；
setTimeOut(()=>console . log(I)，1000)；
i++；
}

如果上述代码发生了...正如我们所知，setTimeout 函数在这里是一个闭包，所以当 setTimeOut 函数执行时，I 的值将是 1，我们应该得到 1，但我们得到 0，这就是为什么它不是第一次迭代的一部分。

因此，将表达式执行添加到三次迭代中会是

首次迭代:-

{
设 x = 0；
if(你的条件){
setTimeOut(()=>console . log(x)，1000)；
}
}

x 从第一个词法范围复制到第二个词法范围

第二次迭代:-

{
设 x = 0；

/**表达式* */
x++；

if(你的条件){
setTimeOut(()=>console . log(x)，1000)；
}

}

类似地，x 从第二个词法范围复制到第三个词法范围

第三次迭代:-

{
设 x = 1；

/**表达式* */
x++；

if(你的条件){
setTimeOut(()=>console . log(x)，1000)；
}

}

和“tadaaa”我们现在完全知道 for 循环的每一部分在哪里执行，以及在哪个范围下执行。如果你从一开始就跟着做了，请给自己一些信任。现在让我将上面的代码修改为 let scope 概念的最终测试

for(设 x = 0；x < 3；x++) {

setTimeOut(()=>console.log(x)，1000)；
x++；
}

输出会是什么？那会是...

1
3

如果你做对了，你就掌握了 javascript for 循环执行！:)但还是让我解释一下这里的幕后发生了什么

作为每次迭代的一部分，我们自己的增量应该是这样的

首次迭代:-

{
设 x = 0；
if(x<3){
setTimeOut(()=>console . log(x)，1000)；
x++；
}
}

现在 x 在上面的词法范围中是 1，所以
x 从第一个词法范围复制到第二个词法范围

第二次迭代:-

{
设 x = 1；

/**表达式* */
x++；

if(x<3) {
setTimeOut(()=>console . log(x)，1000)；
x++；
}

}
x 现在应该是 3 了
类似地，x 从第二个词法范围复制到第三个词法范围

第三次迭代:-

{
设 x = 3；

/**表达式* */
x++；

/**这里的 if 语句将返回 false * */
if(x<3){
setTimeOut(()=>console . log(x)，1000)；
}

}

现在说得通了吧？至于它为什么打印出 1..我们自己的增量有一个主要的副作用。对于那些一直在阅读这篇文章的人来说，这里有一些不是视频的一部分，那就是“如果我写这段代码会发生什么”

for(设 x = 0；x<3;x++) {
setTimeout(()=>console . log(I)，1000)；
设 x = 2；
x+=2:
}

现在，这两种情况中的一种也可能是真的

1.)它应该抛出一个错误，因为我们在同一个块范围内声明了“let ”,而且因为我们知道 let 不能在同一个范围内重新声明，所以它应该显示“x 已经定义”错误。

2.)或者，如果将“let”声明移到词法范围的开始，那么 for 循环就变成了一个无限循环，因为每次它进入 for 循环时，我们都要重新分配 x 的值。

上面两条语句是最合理的，但是 javascript 甚至在这里也让我们感到惊讶
上面的循环会执行三次而没有任何错误，我们的“let”声明没有任何副作用，除了它将记录的日志记录部分

4
4
4

在所有三次迭代中。听起来很困惑？这是在树林下发生的事情

无论我们在 for 循环中写什么，都会在 if 块中执行。三次迭代如下所示

首次迭代:-

{
设 x = 0；

if(x<3) {
setTimeOut(()=>console . log(x)，1000)；- >在调用回调函数
时，当 x 到

变成 4 时，控制台记录 4。
设 x = 2；
x+= 2；
}
- >这就是我们要注意的地方，如果 x 没有在 if 块内声明为 let，那么 if 块内的 x 将引用 if 块外声明的 x。但是在这里，x 在一个新的块范围内被重新声明，这个新的块范围就是 if 块，因此无论我们对这个变量做什么操作，都不会对 if 块之外的变量产生影响，因此 for 循环只是照常运行三次。

}

第二次迭代:-

{
设 x = 0；

/**表达式* */
x++；

if(x<3) {
setTimeOut(()=>console . log(x)，1000)；
设 x = 2；
x+= 2；
}

}

第三次迭代:-

{
设 x = 1；

/**表达式* */
x++；

if(x<3) {
setTimeOut(()=>console . log(x)，1000)；
设 x = 2；
x+= 2；
}
}

这就是为什么尽管我们被记录，for 循环还是执行了 3 次

4
4
4

在所有三次迭代中。

是的，我们终于完全理解了 javascript for 循环！耶！！！！等待..还有更多

[![Just a "wait what Meme" ](../Images/7ca16dba3e4bced2fbbfee7255dba920.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--2AVbBp7W--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/m9whn5d55zpm8o68iw0y.jpg)

这整个难题的最后一个部分是“赋值操作符是第一个词法作用域的一部分吗?”?嗯不....事情是这样的

让我们试试这个循环

for(
let x =(setTimeOut(()=>console . log(x))，0)；
x<3；
x++) {

setTimeOut(()=>console.log(x)，1000))；
x++；
}

首先，让我们弄清楚赋值操作符，因为它可能看起来令人困惑。我所做的只是在赋值操作中添加一个闭包，找出赋值操作的范围是 All，并将 x 赋值为 0；

如果我们认为第一次迭代或者第一个词法范围有赋值操作

第一次迭代:-
{
/**我们的赋值操作**/
设 x =(setTimeOut(()=>console . log(x))，0)；- >我们的赋值语句作为 for 循环的一部分

，它不会
成为第二个和第三个
词法范围或迭代
if(x<3){
setTimeOut(()=>console . log(x)，1000))的一部分；
x++；
}

}

错误但合理的输出:-

输出应该是
1 - >这对应于 assingment 操作的 console.log

1
- >剩下的两个语句对应于 for 循环的主体
3

但这不是正在发生的事情，它实际记录的是

右侧输出:-

0 ->这对应于 assingment 操作中的 console.log

1
- >剩下的两个语句对应于 for 循环的主体
3

现在很清楚，即使对于赋值操作，for 循环也只是为赋值操作创建了一个新的词法范围。是的，javascript 做到了，而且这个作用域不同于所有其他的词法作用域，是每次迭代的一部分。

现在你可以庆祝你已经完全理解了 javascript 中的 for 循环，这可以帮助你理解 javascript 总体上是如何工作的，以及闭包是如何在其中发挥作用的。

[![Just a "it's finally over meme" ](../Images/6eb81fc67ff04b2db0068e0d9ac9d0f0.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--eNTZwMX6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://media.makeameme.org/created/its-over-its-q96aop.jpg)

请再读一遍这篇文章，如果我对某些部分解释得不够好，请发表评论。因为这是我写的第一篇帖子，如果事情没有像应该的那样表达清楚，我道歉。希望你们都学到了一些东西，我没有浪费你们的时间。下次再见！