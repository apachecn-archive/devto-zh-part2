# 本周#1:最大的不

> 原文:[https://dev.to/alexs1305/this-week-1-the-big-o-no-2k7a](https://dev.to/alexs1305/this-week-1-the-big-o-no--2k7a)

## 大教训

上周，我听了一个关于算法复杂性的播客。在播客中，他们谈到了 Big-O 符号，以及这意味着什么，通过例子来描述有什么不同(性能方面)。我没有上过计算机课程，也从未被教授过这方面的知识，在我之前的所有工作中，这也从未真正出现过。尽管我听说过这个术语，但我总是避免花时间去学习它。我已经说服自己，这是一个复杂的问题，我没有时间去了解它，毕竟没有人真正提出过这个问题，那么它为什么会是一个问题呢？

但是在听了一个小时后，我对大 O 符号有了一个简短的体验，真的没有我在脑海中建立的那么难(当然，这要归功于播客的主持人，他们成功地将它分解成易于消化的片段)。我已经开始思考我的代码中哪些地方会产生潜在的 O(n^2 问题，并想办法解决它们。

## 零钱

因此，本周我花了一些时间来回顾我最近写的一些代码，我知道这将是一个潜在的问题。十分钟后，一个更好的解决方案出现了，更重要的是，我获得了足够的信息和术语来解释问题是什么以及代码更改如何解决它

问题是我有两个收藏。一个我不得不迭代的，所以这已经是一个 O(n)问题。但是对于其中的每一个，我都在第二个数组中迭代，找到所有匹配相同 id 的实例，然后取该操作返回的第一个实例。

<figure>

```
collection1.map(c1=>collection2.filter(c2=>c2.id===c1.id)[0]) 
```

Enter fullscreen mode Exit fullscreen mode

<figcaption>example code only!</figcaption>

</figure>

好吧，所以这不是 O(n^2 的问题，但它仍然感觉像一个问题。这当然不再是一个 O(n)问题了。我能感觉到这正在慢慢进入“红色”区域。

解决办法？将第二个数组更改为标准的 js key:value 对象，然后将该值作为属性进行查找。

<figure>

```
collection1.map(c1=>collection2[collection1.id]) 
```

Enter fullscreen mode Exit fullscreen mode

<figcaption>example code only!</figcaption>

</figure>

这并不多，但我知道这现在更像是一个 O(n)问题，我们应该只检查每个数组一次。由于第一个和第二个集合可能每个都包含数百个项目，因此它很可能会更快。

## 下周及以后？

我计划继续提高我对大 O 符号的理解。至少现在我理解了它的目的，也突破了我设置的精神障碍。我还计划得到大 O 小抄(已经在我的圣诞清单上了)

p.s podcast 是由[编码块](https://www.codingblocks.net/podcast/what-is-algorithmic-complexity)制作的，如果你还没有看过它们，它们也很值得一听，它们贯穿了这个和更多的编程概念！