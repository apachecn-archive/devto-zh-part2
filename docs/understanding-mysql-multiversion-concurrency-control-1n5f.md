# 了解 MySQL 多版本并发控制

> 原文：<https://dev.to/awj/understanding-mysql-multiversion-concurrency-control-1n5f>

InnoDB 存储引擎下的 MySQL 允许对同一行的读写互不干扰。这是我们经常使用的功能之一，它似乎被认为是理所当然的，但如果你想一想你将如何构建这样一个东西，它比看起来要详细得多。在这里，我将谈谈这是如何实现的，以及该设计的一些分支。

# 允许并发修改

不出所料，鉴于这篇文章的标题，MySQL 允许您同时从同一行读取和写入的机制被称为“多版本并发控制”。他们(当然)[有文档](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)在上面，但是很快就进入了内部技术细节。

反而让我们在稍微高一点的层面上来谈。这个概念已经存在很长时间了(我能找到的最好的起源是 1979 年的一篇论文)。允许并发读写的总体答案非常简单:写操作创建新版本的行，读操作看到的是它们开始时的当前版本。

# 版本跟踪

显然，如果我们要跟踪版本，我们需要一些东西来区分它们。这个工具需要区分不同的版本，但是理想情况下，它也可以很容易地决定读操作应该看到哪个版本。

在 MySQL 中，这个“版本使能”是一个事务 id。每个交易都有一个。甚至您在控制台中的一次性更新查询也会得到一个。这些 id 以一种允许 MySQL 确定一个事务在另一个事务之前开始的方式递增。InnoDB 下的每个表本质上都有一个“隐藏列”,用于存储更改行的最后一次写操作的事务 id。因此，除了您可能已经更新的列之外，写操作*也用它的事务 id 标记行。这使得读操作可以知道它们是否可以使用行数据，或者行数据是否已经被更改，它们是否需要查阅旧版本。*

# 阅读旧版本

如果您的读取操作碰到了已更改的行，您将需要一个旧版本的数据。交易 id 在这里也发挥了作用，但是还需要更多的信息。每当 MySQL 将数据写入一行，它*也会*将一个条目写入回滚段。这是一种数据结构，存储用于将行恢复到其先前状态的“撤消日志”。它被称为“回滚段”，因为它是用于处理回滚事务的工具。

回滚段存储数据库中每一行的撤消日志。每一行都有另一个隐藏列*,用于存储最新撤销日志条目的位置，这将把该行恢复到上次写入之前的状态。当这些条目被创建时，它们用*外发*事务 id 标记。通过遍历撤消日志中的一行，并在读取事务之前找到最近的事务*，数据库可以识别出要呈现给事务的正确数据。**

# 处理删除

删除由行中的标记来处理，以指示记录已被删除。删除操作*还将行的事务 id 设置为它们的事务 id，因此上面的过程可以呈现行的删除前版本，以读取在删除之前开始的操作。*

## 版本什么时候被删除

MySQL 显然不能永远记录数据库中发生的每一次变化。虽然不需要。一旦可能需要撤消日志的最后一个事务完成，就可以删除撤消日志。

类似地，一旦最早的活动事务在删除后启动，已经被标记为删除的行可以被彻底放弃。这些行和撤消日志被物理地删除，以通过在后台自己的线程中发生的“清除”操作来回收它们的磁盘空间。

# 指数呢

因此，概括地说，MySQL 通过保持行不断更新和存储差异来处理版本，只要当前运行的查询需要它们。不过这只是故事的一半，索引还需要支持一致读取。主键索引的工作方式非常类似于上面对实际数据库行的描述。次要索引稍有不同。

MySQL 以两种方式处理这种情况:索引条目的页面由写入其中的最后一个事务 id 标记，单个索引条目有删除标记。当更新更改索引列时，会发生三种情况:当前索引条目被标记为删除，写入更新值的新条目，以及新条目的索引页被标记为事务 id。

在事务 id 之前的页中找到未标记删除的条目的读取操作直接使用该索引数据。如果该操作找到删除标记或较新的事务 id，它将查找该行并遍历撤消日志以找到要使用的适当值。

类似于从过期的事务中清除已删除的行，标记为删除的索引条目最终也会被回收。因为在索引中的某个地方总会有新的条目需要处理，所以 MySQL 可以更积极地清理这些条目。

# 我该如何处理这些信息？

那么，鉴于上述情况，我们可以带什么回家让我们的生活变得更好呢？一些事情。请记住，数据库性能可能很难分析。下面的每一点都是您的数据可能发生的事情的一个潜在部分。

*   大型事务是痛苦的:长时间运行的事务不仅仅会束缚连接，它们还会迫使数据库将历史保存更长时间。如果该事务正在读取数据库的大部分，后续的写操作将迫使它读取回滚日志，该日志可能在内存的不同页面中，甚至在磁盘上。
*   多语句事务需要快速提交:这是“大事务令人痛苦”的另一种形式，但值得一提。MySQL 不会“杀死”活跃的事务。如果您打开一个事务，查询出数据，然后在提交前花两个小时编写应用程序代码，MySQL 将忠实地保留两个小时的撤消历史。每一个打开的事务都会产生更多的撤销历史。尽可能快地提交，尽可能在事务之外进行处理。
*   写入会降低索引扫描的有用性。索引的全部意义在于回答关于数据的问题，而无需实际查看数据。删除索引条目上的标记和索引页上的事务戳记，强制数据库读取您的数据。仔细考虑对不查询的列使用复合索引。无论如何，您的查询将为更新这些列付出代价。
*   快速的写操作放大了读操作的损失。如果你有很多数据要写，特别是要写到*的同一行*，要分块写，不要一个一个写。每次写操作都会生成一个事务 id、相关的撤消日志，并产生一堆二级索引。将写操作分块在一起增加了读操作找到有效索引数据的机会，并降低了它们必须费力处理的撤销日志的大小。有一个相反的极端，一个大的写操作可能有太多的数据，所以在这里寻找中间地带很重要。
*   “热”行对于所有列都是热的，而不仅仅是更新的列。存储频繁更新的计数器的行会强制更多的行事务 id 更新和撤消日志条目。在计数器递增之前开始的查询，即使它们不使用计数器，也仍然必须遍历撤消日志以获得它们开始时的行状态。同样的逻辑也适用于极其频繁更新的时间戳，这些时间戳汇总了与一行的关系之间的更改时间。如果可能的话，预先批量处理这些更新，或者考虑将它们存储在一个单独的表中，以便在需要时可以连接到该表中。
*   考虑将报告与直接/应用程序使用读取分开。报告查询倾向于扫描数据库的大部分。它们需要很长时间，因此迫使保存和消耗更多的撤消历史。大多数应用程序行为更加直接:它知道要检索的特定记录，并直接获取它们。如果您已经在使用读取副本，请考虑将一个副本专用于报告，这样您的应用程序查询就不会因为报告而付出撤销存储的代价。

# 最后的想法

值得注意的是，这不是实现 MVCC 的唯一途径。PostgreSQL 通过在一行应该可见的地方存储最小和最大事务 id 来处理这项任务。在这种模式下，更新一个行会在其上设置最大事务 id，并通过复制原始行并在该副本中执行更新来创建一个全新的行条目。这避免了对撤销日志的需要，但代价是每次更新都要复制所有行数据。

这里的要点是，对于真正试图提升数据库性能的情况，理解一些更大的内部细节是有好处的。我列出的许多要点只适用于极端用例，但是在这些情况下，了解数据库如何对数据进行版本控制可以使理解性能问题变得更容易。