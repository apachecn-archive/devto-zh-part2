# 码头工人指南-第 1 部分

> 原文：<https://dev.to/drminnaar/docker-guide---part-1--57c8>

## 总结

我在 Github 上开始了一个新项目，叫做 *[【指南】](https://github.com/drminnaar/guides)* 。这是一个由我编写的技术指南库。我创建这个项目的原因是，当我写一个主题时，我会学到更多。它也有助于巩固或澄清概念。我会不断更新这些指南，它们永远不会完整。目标是使指南尽可能准确。然而，我不会总是 100%正确，我会依靠社区的反馈来改进或改正。

我开始的第一个指南是 Docker 上的[指南。我选择 Docker 作为我的第一个指南，因为我认为在 2018 年左右的所有趋势技术中，Docker 是对软件开发/部署相关人员最有趣、最重要和最适用的技术之一。因此，无论你是编写软件(前端还是后端)还是管理软件部署的操作方面，Docker 都可以帮助你做得更好。](https://github.com/drminnaar/guides/tree/master/docker-guide)

在这篇文章中，我将介绍我的 *Docker 指南*的第一部分，概述。在这第一部分中，我讨论了 Docker 及其相关技术的背景。

请在以下位置找到原始作品:

*   [码头工人指南](https://github.com/drminnaar/guides/tree/master/docker-guide)
*   [码头概述](https://github.com/drminnaar/guides/blob/master/docker-guide/1-overview.md)

所有未来的更新都将在 github 项目库中进行。

* * *

## 概述

了解 Docker 及其成功的背景和最终原因非常重要。因此，在本指南中，我将解释几个与应用程序生命周期挑战相关的主题，以及 Docker 如何帮助解决这些挑战。首先，我将讨论一些与应用程序生命周期相关的问题，以及为什么我们需要一种更好的方式来运行应用程序。其次，我将讨论 Docker 及其相关技术，以及 Docker 如何帮助我们更好地运行和管理应用程序。

### 软件部署的挑战

在这一节中，我将讨论一些与部署和运行应用程序相关的挑战。

计算机的全部意义在于能够在其上运行应用程序。在虚拟化之前，通常会有一个物理计算机系统，如可以安装所有应用程序的服务器。每个物理计算机系统都有自己的操作系统(OS)。所有的应用程序都需要与安装它们的操作系统兼容。操作系统需要通过拥有多个运行时、框架、库、配置和安全实现来支持多个应用程序。此外，操作系统还需要是所有应用程序都支持的特定版本。操作系统上的任何补丁、升级或安装都有可能破坏其他应用程序。尽管所有应用程序都在各自的进程中运行，但与每个进程相关联的默认隔离不足以帮助确保操作系统及其底层应用程序的完整性和可靠性。操作系统不再是一个支持所有应用程序运行的可靠、干净的运行时，而是变成了一个[大泥球](https://en.wikipedia.org/wiki/Big_ball_of_mud)。这基本上意味着操作系统变得不那么内聚，越来越多地耦合到其他依赖项，导致一个类似于*“意大利面条”*的系统，其中没有清晰的关注点分离。因此，当一个人考虑将一个应用程序投入生产时，他就开始意识到这实际上是多么困难。当支持多种部署环境(开发、测试、试运行)时，这更具挑战性。因此，我们面临的挑战是如何以自动化、一致和无错误的方式将应用程序从开发一直部署到各种部署环境中。这一挑战可以进一步分解为更具体的挑战，即分发、安装和管理。我称之为*“DIM(分发、安装、管理)”*模式。在下面的段落中，我将讨论 *DIM* 和任何相关的问题。

我想指出，以下挑战与规模成正比。作为一个只有几个小应用程序的小团队，下面的挑战可能看起来根本不是挑战。然而，随着部署架构复杂性的增加，与 *DIM* 相关的复杂性也在增加。复杂性要么是有意的，要么是偶然的。如果是故意的，那是因为你对问题的理解还不够。通过寻找更好的方法来做 *DIM* ，我们通过更好的实践和设计来帮助降低整体复杂性。

#### 分布

应用程序的分发既复杂又困难。有一个完整的流程或工作流，需要根据如何将应用程序从开发交付到测试、试运行和生产来确定。每个软件开发和操作环境的过程都是不同的。这里有一些你应该问的问题:

*   应用程序将如何打包？
*   应用程序需要可被发现吗？
*   需要下载应用程序吗？
*   分发是简单地将文件复制到下一个目的地吗？
*   分发会带来哪些安全隐患？例如，是否有任何敏感数据需要作为应用程序分发的一部分进行分发？应用程序和/或配置是否应该加密？是否需要哈希代码来帮助确保分发的应用程序的完整性？
*   不同应用程序的更新和补丁是如何分发的？
*   需要将应用程序部署到多少个环境中？
*   可以使用持续集成(CI)和持续交付(CD)吗？如果是，那看起来像什么，需要什么技能？
*   我们如何进行变更控制？我们如何使变更控制更简单、更容易？

考虑到所有的事情，从开发人员的机器(实际上应该是从您的分布式版本控制系统)获得一个应用程序进入测试或生产的简单任务可能会变得令人生畏。组织规模越大，申请数量越多，这个问题只会变得更具挑战性。

#### 安装

即使作为一名开发人员，我也不得不在软件/应用程序安装的战壕中忍受相当长的时间。不用说，应用程序的安装可能是一项缓慢、容易出错、乏味且令人沮丧的任务。在软件开发界，有一个拿着香蕉的大猩猩的比喻，通常用来解释与 ORM(对象关系映射器)相关的*[【n+1】](https://stackoverflow.com/questions/97197/what-is-n1-select-query-issue)*问题。我将在这里使用这个类比，因为我认为它也适用。把应用程序想象成香蕉。对于安装，我们想要的只是“香蕉”。但是我们没有得到香蕉。相反，我们得到的是香蕉，拿着它的巨大的愤怒的大猩猩，所有的大猩猩部落，以及它生活的整个丛林。我想你明白了。本质上是一个*“n+1”*安装问题。大多数应用程序都有大量的依赖关系(每个都有自己的依赖关系集)。

以下是更多与安装相关的问题:

*   并非所有的应用程序都是跨平台的，这意味着并非所有的应用程序都可以在所有或多个操作系统上运行。这导致需要具有不同操作系统的多个物理计算机系统来运行相关的应用程序。

*   通常，应用程序需要在相似的端口上运行，从而导致端口冲突。这些冲突也只有在应用程序安装并启动后才能被检测到。

*   部署应用程序后，通常需要进行一些配置，以确保正在安装的应用程序正常运行。这个额外的配置步骤很容易出错(如遗漏一个步骤或配置错误)和出现安全问题(如明文密码)。

*   所有应用程序在依赖关系方面都有不同的需求。因此，为了正确安装和运行应用程序，需要安装大量的库和框架。这通常会导致库和框架的冲突，而唯一的解决方案通常是将应用程序安装在它自己的物理计算机系统上，使用它自己的一组库和框架。

*   这种模式中的安全性充满了漏洞(任何有可能损坏或丢失的东西)。一个例子是，作为环境变量所需的敏感信息通常会以纯文本形式存储，任何试图访问计算机的人都可以看到这些信息。

*   当部署新的应用程序时，或者当计算机系统需要打补丁(软件和安全更新)时，几乎总是会有与之相关的停机时间。

此外，安装面临的最大问题之一是，所有应用程序都带有包袱和要求，这些通常与部署目的地不一致。这就是为什么我们都太熟悉“但它在我的机器上工作”的借口。此外，应用程序往往是分散的，而不是内聚的。这也是为什么安装文档/指南需要详细说明每个步骤的原因。但是这些安装文档通常写得很差和/或不完整。文档也很少更新。

#### 管理(操作)

至此，我们已经分发并安装了我们的应用程序。但是，我们如何管理我们的应用程序及其不断增长的资源需求呢？有人可以写这方面的书。但是，我将只提到我认为在管理应用程序时最常见的几个问题。这些也是虚拟化技术可以帮助解决的问题。

以下是在测试、试运行和生产等不同环境中管理应用程序时可能会遇到的一些操作问题。

*   应用程序资源需求会随着时间的推移而增长。这意味着应用程序可能需要更高的处理能力、更多的内存(RAM)或更多的硬盘空间。因此，可以使用*垂直可伸缩性*或*水平可伸缩性* ( [可伸缩性](https://en.wikipedia.org/wiki/Scalability))来扩展系统。在很大程度上，由于大多数应用程序无法以分布式方式工作，采用垂直可伸缩性变得更加容易。结果将是增加太多或太少的资源，最终导致金钱和/或计算资源的浪费。

*   水平扩展(没有虚拟化)的问题是需要构建单独的物理机。这需要时间(通常是令人疲惫的准备时间)和大量资金来执行。通常，应用程序可能只在高峰时间需要额外的计算能力(例如黑色星期五)。然后，当流量减少时，你只剩下一台优步计算机器，除了浪费资源和金钱，什么也不做。

*   启动、暂停、停止和重启应用程序等简单的应用程序生命周期操作要么非常困难，要么根本不可能。

*   例如，有时一个应用程序可能会因为它的一个进程进入无限循环而失控。如果不加检查，恶意应用程序可以使整个计算机系统停止运行。

*   可以通过物理机实现冗余，但这非常昂贵，并且再次受到利用率不足的困扰。即使用户正在使用虚拟机，启动新的虚拟机也需要很长时间。离线超过几秒钟是不可接受的，在某些情况下，生命垂危。

当需要设置多个环境(如开发、测试、试运行、生产)时，上述所有问题都会变得更加复杂。如果在多租户环境中，每个客户端都需要自己的设置，情况会变得更糟。再加上大量具有各种依赖关系的应用程序，就有了完美风暴。

现在我们已经了解了与应用程序部署生命周期相关的一些挑战，在下一节中，我将讨论 Docker 以及它是如何成为我们这个时代最热门的技术之一的。

* * *

### 码头工人

克服上述挑战的解决方案是使用虚拟化技术，如虚拟机(通过虚拟机管理程序实现)。然而，虚拟机是实现部署乌托邦的第一步。容器是部署发展的下一步。这也是 Docker 出现并永远改变我们使用容器的方式的原因。

通常，术语*码头工人*和*集装箱*可以互换使用，就好像它们是同一个东西。然而，Docker 不是容器，也没有发明容器的概念。容器已经存在了十多年，容器的概念更早([容器的历史](https://rhelblog.redhat.com/2015/08/28/the-history-of-containers/))。Docker 是 *[【站在巨人的肩膀上】](https://en.wikipedia.org/wiki/Standing_on_the_shoulders_of_giants)* 的经典例子。容器本来就很难处理和管理。因此， *Docker* 出现了，并采用了一种难以理解(并与之合作)的技术，并把它放在普通人能接触到的地方。Docker 是一个容器管理系统，使容器管理变得容易。

要进一步了解 Docker 是什么，了解以下关键主题很重要:

*   虚拟计算机
*   图像
*   容器
*   虚拟机/容器比较
*   登记处
*   贮藏室ˌ仓库

#### 虚拟机

在上一节中，我讨论了一些与应用程序生命周期相关的挑战。问题的很大一部分是不得不在物理计算机限制的范围内工作。这些挑战催生了虚拟机管理程序技术，使我们能够创建虚拟机。因为容器经常被比作虚拟机，所以我想解释一下它们之间的区别，以帮助减少或避免两者之间的混淆。

如果人们可以创建一种物理机器的“垂直切片”会怎么样。每个片将被分配一定百分比的物理机资源。因此，可以为每个存储片安装特定的操作系统，以满足应用程序的要求。这在理论上听起来很棒，但是你不可能把一把刀子拿到一台物理机器上，把它分成几部分，然后期望它还能工作。反正在现实世界里不会。进入虚拟化和虚拟机管理程序。虚拟机管理程序帮助我们将物理机划分为虚拟计算“切片”。尽管虚拟机管理程序技术绝不是灵丹妙药，但它对帮助解决上述一些挑战大有帮助。虚拟机管理程序帮助我们创建虚拟机。虚拟机是对物理计算机系统的模拟，因为它虚拟化了物理计算资源，如 CPU、RAM、网络和磁盘。

我们来看一个虚拟机技术的概念图。

**虚拟机图**
[![docker-guide-vm](../Images/08d42b21555183d782df6e58821c7ef1.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--jn9bOukY--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://user-images.githubusercontent.com/33935506/36017635-3e3e2324-0d81-11e8-8e24-c533b913c4e8.png)

从上图中可以看出，我们有 3 个物理机“切片”,每个切片都是一个虚拟机。重要的一点是，虚拟机需要自己的客户操作系统。在该图中，我还展示了一个 *[“第二类托管的管理程序”](https://en.wikipedia.org/wiki/Hypervisor)* 。这意味着虚拟机管理程序运行在传统的操作系统上。另一种虚拟机管理程序是*[【1 型裸机虚拟机管理程序】](https://en.wikipedia.org/wiki/Hypervisor)* 。这些虚拟机管理程序直接在主机硬件上运行，不需要主机操作系统。

#### 图像

图像是一个文件(容器外观的二进制表示)。从概念上讲，图像是创建容器的模板(蓝图)。事实上，很多时候提到容器时，实际上指的是图像。然而，容器是“运行时”的东西，而图像是“构建时”的东西。我喜欢使用的类比是来自面向对象编程(OOP)的一个概念。在 OOP 中，需要理解的两个最重要的概念是类和对象。类是一个模板(蓝图),它们用于在运行时创建对象。一个对象展示了一个类的所有属性和行为，除了它只存在于运行时。像类一样，图像用于创建表示该图像的运行实例的容器。

因此，如果想在您的主机上运行 MongoDB 或 Elasticsearch 的实例。为什么不使用一个现成的图片，可以通过官方的 Docker 注册表获得(更多关于注册表的信息请见下文)。图像可以位于以下位置:

*   [MongoDB](https://hub.docker.com/_/mongo/)
*   [弹性搜索](https://hub.docker.com/_/elasticsearch/)

记住，图像是用来运行容器的。因此，一个 *MongoDB* 映像将用于运行一个 *MongoDB* 容器。

#### 容器

想象一个运行着一大堆进程的操作系统。这些进程共享几乎所有的东西(CPU、内存、网络等)，并且每个进程都知道其他进程。但是，如果您想在一个隔离的“沙箱”环境中运行一个或多个进程，该怎么办呢？沙箱将提供隔离，并允许每个进程拥有自己的进程名称空间。此外，沙箱将能够控制和限制进程可以使用多少资源的能力。

正是“沙箱”中独立进程的概念催生了容器技术。我一直在讨论的“沙盒”就是我们所知道的容器。容器是虚拟化操作系统的独立进程。使这成为可能的机制被称为*“名称空间”*和*“控制组(cgroups)”*。

**集装箱概述**
[![docker-guide-container-overview](../Images/87299c8e648ddc366c769b63235665bd.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--jGHEa_Ei--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://user-images.githubusercontent.com/33935506/36032845-f16234dc-0db7-11e8-9f91-d0ffc3746e74.png)

从上图可以看出，我们最初是从 Linux 操作系统开始的。我使用 Linux 是因为容器技术的起源都发生在 Linux 操作系统上。每个过程没有(或很少)隔离。通过使用*命名空间*和*控制组*，我们现在能够将每个进程作为一个独立的进程在它自己的容器中运行。

##### 命名空间

*[名称空间](http://man7.org/linux/man-pages/man7/namespaces.7.html)* 的官方文档陈述如下:

> 名称空间将全局系统资源包装在一个抽象中，使名称空间中的进程看起来拥有自己的全局资源的独立实例。对全局资源的更改对作为命名空间成员的其他进程可见，但对其他进程不可见。名称空间的一个用途是实现容器。

因此，*名称空间*通过允许每个进程在它自己的独立工作空间中运行来提供进程隔离。因此，当运行一个容器时，下面的*名称空间*是为容器的各个方面创建的。

*   IPC -隔离和管理对 IPC 的访问
*   网络-隔离和管理网络设备、堆栈、端口等。
*   Mount -隔离文件系统挂载点
*   PID 名称空间-提供进程隔离
*   用户名称空间-隔离用户和组 id
*   UTS 命名空间-隔离主机名和 NIS 域名

##### 控制组(CGroups)

*[c 组](http://man7.org/linux/man-pages/man7/cgroups.7.html)* 的官方文档说明如下:

> 控制 cgroups，通常称为 cgroups，是 Linux 内核的一个特性，它允许将进程组织成层次化的组，然后可以限制和监视这些组对各种类型资源的使用。内核的 cgroup 接口是通过一个叫做 cgroups 的伪文件系统提供的。分组是在核心的 cgroup 内核代码中实现的，而资源跟踪和限制是在一组基于资源类型的子系统(内存、CPU 等)中实现的

因此， *cgroups* 都是关于组织进程，以便资源可以被分配给它们。

#### 虚拟机/容器比较

容器不是小型虚拟机，也不像虚拟机。这一点从我上面的讨论中应该很清楚了。然而，为了帮助进一步阐明容器的含义，我提供了虚拟机和容器之间的进一步比较，如下所示。

**虚拟机/容器比较**
[![docker-guide-vm-vs-container](../Images/e17f8c77040665004a6adc957e64fca1.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--yiYvgX5_--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://user-images.githubusercontent.com/33935506/36058292-e9406996-0e24-11e8-9b95-1c4236e77093.png)

根据上图，虚拟机和容器之间的差异可以总结如下:

*   管理程序虚拟化物理计算系统(硬件)，而容器虚拟化操作系统。
*   管理程序从硬件中抽象出操作系统，而容器从操作系统中抽象出应用程序。
*   虚拟机需要自己的客户操作系统，而容器共享主机操作系统。这就是为什么，为了运行 Linux 容器，您需要一个 Linux 主机操作系统。你需要一个 Windows 操作系统来运行 Windows 容器。

此外，虚拟机和容器也不是对立的技术。事实上，它们可以用作补充技术。这就是 Windows 和苹果如何设法在其平台上提供 Linux 容器的。Windows 和 Apple 操作系统都需要一个管理程序来运行带有 Linux 操作系统(Alpine)的虚拟机，以便人们可以使用 Docker 这样的技术来托管 Linux 容器。尽管如此，Windows 已经在容器产品方面取得了显著的进步。在撰写本文时，人们可以选择在 Windows (Windows 10 Pro)操作系统上使用 Windows 还是 Linux 容器。

容器也不能取代虚拟机。尽管在很多情况下使用容器会更好(例如微服务)。如上所述，这两种技术有很大的不同。请记住，虚拟机是关于虚拟化硬件的，而容器是关于虚拟化操作系统的。

#### 注册表

最基本的注册表是一个可以存储和检索 Docker 图像的地方。Docker 提供公共和私有注册，可以在这里找到。如果你曾经和像 [NPM](https://www.npmjs.com/) 或者[努格特](https://www.nuget.org/)这样的软件开发包经理一起工作过。或者如果你曾经和 linux 包管理器一起工作过，比如 DPKG[或者 RPM](https://en.wikipedia.org/wiki/Dpkg)或者 T8。那么使用 Docker 注册中心的概念应该很熟悉。

Docker 并不是唯一一个提供 Docker 注册表的平台。微软 Azure、亚马逊网络服务、谷歌云平台、数字海洋只是可供选择的 Docker 注册表中的几个。例如，用户还可以使用 [Docker 可信注册中心](https://docs.docker.com/datacenter/dtr/2.4/guides/)托管内部注册中心。

关于 Docker 注册表的更多信息，请点击查看 Docker 官方文档

#### 储存库

存储库是在 Docker 注册表中可以找到特定图像的实际位置。下图进一步阐明了这一点。

[![docker-repository](../Images/69f3dceeeff4e45dd06717ef75f7a94c.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--ApYSdtH3--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://user-images.githubusercontent.com/33935506/36072808-259a842a-0f2f-11e8-8b3f-ac1790d8c39e.png)

* * *

### 总结

我已经讨论了我认为与软件部署相关的主要挑战。从讨论中得出的关键结论是，我们需要一种更好的方法来部署软件应用程序。我所说的部署是指与软件应用程序的分发、安装和管理(操作)相关的一切。我们希望软件应用程序具有更好的可移植性、内聚性、独立性，并且与其他应用程序/进程相隔离。这使我们能够减少与软件部署相关的复杂性和错误。这使得软件应用程序更加健壮、安全、易于扩展。

虚拟机管理程序技术允许我们创建虚拟机(VM ),借此我们可以隔离我们的应用程序并独立管理我们的应用程序。与虚拟机相关的一个问题是，它们会消耗大量主机资源。这部分是因为每个虚拟机都需要有自己的客户操作系统。与启动(或准备)物理机相比，启动虚拟机相对较快。然而，例如，与容器的启动时间相比，容器要快得多。与虚拟机相关的另一个问题是，它们不像容器那样可移植。

正如我之前在本指南中提到的。容器是应用程序部署发展的下一步。然而，容器很难理解和使用。因此，Docker 作为一种简化容器管理的技术出现了。容器允许我们将应用程序打包成单一的内聚的、隔离的、可移植的包，这些包可以很容易地在不同的部署环境之间移动。