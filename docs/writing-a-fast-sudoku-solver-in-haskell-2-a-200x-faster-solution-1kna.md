# 用 Haskell #2 编写一个快速数独求解器:一个快 200 倍的解决方案

> 原文：<https://dev.to/abhin4v/writing-a-fast-sudoku-solver-in-haskell-2-a-200x-faster-solution-1kna>

在这个系列文章的第一部分中，我们在 [Haskell](https://www.haskell.org/) 中写了一个简单的[数独](https://en.wikipedia.org/wiki/Sudoku)解算器。它使用了一个带[回溯](https://en.wikipedia.org/wiki/Depth-first_search)的[约束满足](https://en.wikipedia.org/wiki/Constraint_satisfaction_problem)算法。该解决方案运行良好，但速度非常慢。在这篇文章中，我们将改进它，使它变得更快。

*这篇文章最初发表在[我的博客](https://abhinavsarkar.net/posts/fast-sudoku-solver-in-haskell-2/)上。*

## 目录

1.  [快速回顾](#quick-recap)
2.  [约束和推论](#constraints-and-corollaries)
3.  单身、双胞胎和三胞胎
4.  [向前一点，向后一点](#a-little-forward-a-little-backward)
5.  [专门修剪细胞](#pruning-the-cells-exclusively)
6.  比飞驰的子弹还快！
7.  [结论](#conclusion)

## 快速回顾

[数独](https://en.wikipedia.org/wiki/Sudoku)是一种数字放置拼图。它由一个 9×9 的网格组成，用 1 到 9 的数字填充，这样每行、每列和 9 个 3×3 的子网格都包含所有的数字。网格中的一些单元格是预先填充的，玩家必须填充其余的单元格。

在上一篇文章中，我们实现了一个简单的数独解算器，但没有过多关注它的性能特征。我们通过我们的程序运行了 <sup id="fnref1">[1](#fn1)</sup> 部分 [17 道谜题](https://abhinavsarkar.net/files/sudoku17.txt.bz2) <sup id="fnref2">[2](#fn2)</sup> 来看看它有多快:

```
$ head -n100 sudoku17.txt | time stack exec sudoku
... output omitted ...
      116.70 real 198.09 user 94.46 sys 
```

所以，解决一百个谜题大概花了 117 秒。以这样的速度，解决文件中包含的所有 49151 个谜题需要大约 16 个小时。这太慢了。我们需要找到让它更快的方法。让我们从头开始。

## 约束和推论

在一个数独游戏中，我们有一个部分填充的 9x9 网格，我们必须在遵守游戏限制的同时完全填充它。

```
+-------+-------+-------+
| . . . | . . . | . 1 . |
| 4 . . | . . . | . . . |
| . 2 . | . . . | . . . |
+-------+-------+-------+
| . . . | . 5 . | 4 . 7 |
| . . 8 | . . . | 3 . . |
| . . 1 | . 9 . | . . . |
+-------+-------+-------+
| 3 . . | 4 . . | 2 . . |
| . 5 . | 1 . . | . . . |
| . . . | 8 . 6 | . . . |
+-------+-------+-------+
    A sample puzzle

+-------+-------+-------+
| 6 9 3 | 7 8 4 | 5 1 2 |
| 4 8 7 | 5 1 2 | 9 3 6 |
| 1 2 5 | 9 6 3 | 8 7 4 |
+-------+-------+-------+
| 9 3 2 | 6 5 1 | 4 8 7 |
| 5 6 8 | 2 4 7 | 3 9 1 |
| 7 4 1 | 3 9 8 | 6 2 5 |
+-------+-------+-------+
| 3 1 9 | 4 7 5 | 2 6 8 |
| 8 5 6 | 1 2 9 | 7 4 3 |
| 2 7 4 | 8 3 6 | 1 5 9 |
+-------+-------+-------+
    and its solution 
```

之前，我们遵循一个简单的剪枝算法，从固定单元的邻居中删除所有已解决的(或*固定*)数字。我们重复修剪，直到网格中的固定值和非固定值停止变化(或者网格*稳定*)。这里有一个修剪前网格的例子:

```
+-------------------------------------+-------------------------------------+-------------------------------------+
| [123456789] [123456789] [123456789] | [123456789] [123456789] [123456789] | [123456789] 1           [123456789] |
| 4           [123456789] [123456789] | [123456789] [123456789] [123456789] | [123456789] [123456789] [123456789] |
| [123456789] 2           [123456789] | [123456789] [123456789] [123456789] | [123456789] [123456789] [123456789] |
+-------------------------------------+-------------------------------------+-------------------------------------+
| [123456789] [123456789] [123456789] | [123456789] 5           [123456789] | 4           [123456789] 7           |
| [123456789] [123456789] 8           | [123456789] [123456789] [123456789] | 3           [123456789] [123456789] |
| [123456789] [123456789] 1           | [123456789] 9           [123456789] | [123456789] [123456789] [123456789] |
+-------------------------------------+-------------------------------------+-------------------------------------+
| 3           [123456789] [123456789] | 4           [123456789] [123456789] | 2           [123456789] [123456789] |
| [123456789] 5           [123456789] | 1           [123456789] [123456789] | [123456789] [123456789] [123456789] |
| [123456789] [123456789] [123456789] | 8           [123456789] 6           | [123456789] [123456789] [123456789] |
+-------------------------------------+-------------------------------------+-------------------------------------+ 
```

这是重复修剪后的同一个网格:

```
+-------------------------------------+-------------------------------------+-------------------------------------+
| [    56789] [  3  6789] [  3 567 9] | [ 23 567 9] [ 234 6 8 ] [ 2345 789] | [    56789] 1           [ 23456 89] |
| 4           [1 3  6789] [  3 567 9] | [ 23 567 9] [123  6 8 ] [123 5 789] | [    56789] [ 23 56789] [ 23 56 89] |
| [1   56789] 2           [  3 567 9] | [  3 567 9] [1 34 6 8 ] [1 345 789] | [    56789] [  3456789] [  3456 89] |
+-------------------------------------+-------------------------------------+-------------------------------------+
| [ 2   6  9] [  3  6  9] [ 23  6  9] | [ 23  6   ] 5           [123    8 ] | 4           [ 2   6 89] 7           |
| [ 2  567 9] [   4 67 9] 8           | [ 2   67  ] [12 4 6   ] [12 4  7  ] | 3           [ 2  56  9] [12  56  9] |
| [ 2  567  ] [  34 67  ] 1           | [ 23  67  ] 9           [ 234  78 ] | [    56 8 ] [ 2  56 8 ] [ 2  56 8 ] |
+-------------------------------------+-------------------------------------+-------------------------------------+
| 3           [1    6 89] [     6  9] | 4           7           [    5   9] | 2           [    56 89] [1   56 89] |
| [ 2   6789] 5           [ 2 4 67 9] | 1           [ 23      ] [ 23     9] | [     6789] [  34 6789] [  34 6 89] |
| [12    7 9] [1  4  7 9] [ 2 4  7 9] | 8           [ 23      ] 6           | [1   5 7 9] [  345 7 9] [1 345   9] |
+-------------------------------------+-------------------------------------+-------------------------------------+ 
```

我们看到与固定值相冲突的可能性是如何被消除的。我们还看到，当所有其他可能的值被消除时，一些不固定的细胞如何变成固定的细胞。

这个简单的策略直接来自数独的限制。但是，是否有更复杂的策略是间接隐含的呢？

## 单身、双胞胎和三胞胎

让我们来看看这个从正在进行的解决方案中捕获的示例行:

```
+-------------------------------------+-------------------------------------+-------------------------------------+
| 4           [ 2   6 89] 7           | 3           [ 2  56  9] [12  56  9] | [    56 8 ] [ 2  56 8 ] [ 2  56 8 ] |
+-------------------------------------+-------------------------------------+-------------------------------------+ 
```

注意第六个单元格是唯一一个可能包含`1`的单元格。很明显，我们应该将第六个单元格固定为`1`，因为我们不能将`1`放置在该行的任何其他单元格中。让我们称之为*单打* <sup id="fnref3">[3](#fn3)</sup> 场景。

但是，我们当前的解决方案不会将第六个单元格固定到`1`，直到出现以下情况之一:

1.  该单元的所有其他可能性被删除，或者，
2.  单元格被选为`nextGrids`函数中的枢纽，而`1`被选为要修复的值。

这可能需要很长时间，并导致更长的求解时间。让我们假设我们在修剪单元格时识别出了 Singles 场景，并立即将单元格固定到`1`。这将大大减少搜索树，并使解决方案更快。

事实证明，我们可以概括这种模式。让我们看看解决方案中间的这个示例行:

```
+-------------------------------------+-------------------------------------+-------------------------------------+
| [1  4    9] 3           [1  4567 9] | [1  4   89] [1  4 6 89] [1  4 6 89] | [1  4   89] 2           [1  456789] |
+-------------------------------------+-------------------------------------+-------------------------------------+ 
```

用肉眼很难注意到，但这里也有一些特别的东西。数字`5`和`7`只出现在第三和第九个单元格中。尽管它们在这些单元格中伴随有其他数字，但它们不会出现在任何其他单元格中。这意味着，我们可以将`5`和`7`放在第三个或第九个单元格中，而不是其他单元格中。这意味着我们可以删除第三个和第九个单元格，只有`5`和`7`，就像这样:

```
+-------------------------------------+-------------------------------------+-------------------------------------+
| [1  4    9] 3           [    5 7  ] | [1  4   89] [1  4 6 89] [1  4 6 89] | [1  4   89] 2           [    5 7  ] |
+-------------------------------------+-------------------------------------+-------------------------------------+ 
```

这是双胞胎的场景。我们可以想象，这种模式会扩展到三位数及以上的组。当三个数字只能在一个块中的三个单元中找到时，这就是*三联体*场景，如下例:

```
+-------------------------------------+-------------------------------------+-------------------------------------+
| [45 7] [45 7] [5 7] | 2 [3 5 89] 6 | 1 [34 89] [34 89] |
+-------------------------------------+-------------------------------------+-------------------------------------+ 
```

在这种情况下，三位数是`3`、`8`和`9`。和以前一样，我们可以通过将这些数字固定在它们的单元格中来修剪块:

```
+-------------------------------------+-------------------------------------+-------------------------------------+
| [   45 7  ] [   45 7  ] [    5 7  ] | 2           [  3    89] 6           | 1           [  3    89] [  3    89] |
+-------------------------------------+-------------------------------------+-------------------------------------+ 
```

我们把这三种场景统称为*独占*。

我们可以将此扩展到*四胞胎*场景，甚至更远。但这种情况在 9x9 数独游戏中很少出现。试图找到它们可能会比我们通过找到它们而获得的解决时间加速的好处在计算上更加昂贵。

现在我们已经发现了这些修剪单元格的新策略，让我们在 Haskell 中实现它们。

## 向前一点，向后一点

我们可以实现这三种新策略来修剪单元，作为每种策略的一个功能。然而，我们实际上可以在一个函数中实现所有这些策略。但是，这个函数比前面的修剪函数稍微复杂一些。首先，让我们试着用表格来理解它的工作原理。就拿这个样本行来说:

```
+-------------------------------------+-------------------------------------+-------------------------------------+
| [   4 6  9] 1           5           | [     6  9] 7           [ 23  6 89] | [     6  9] [ 23  6 89] [ 23  6 89] |
+-------------------------------------+-------------------------------------+-------------------------------------+ 
```

首先，我们制作一个表格，将数字映射到它们出现的单元格，不包括固定单元格:

| 手指 | 细胞 |
| --- | --- |
| Two | 6, 8, 9 |
| three | 6, 8, 9 |
| four | one |
| six | 1, 4, 6, 7, 8, 9 |
| eight | 6, 8, 9 |
| nine | 1, 4, 6, 7, 8, 9 |

然后，我们翻转该表，收集出现在同一组单元格中的所有数字:

| 细胞 | 数字 |
| --- | --- |
| one | four |
| 6, 8, 9 | 2, 3, 8 |
| 1, 4, 6, 7, 8, 9 | 6, 9 |

最后，我们删除表格中单元格计数与数字计数不同的行:

| 细胞 | 数字 |
| --- | --- |
| one | four |
| 6, 8, 9 | 2, 3, 8 |

瞧啊。我们已经找到了一个单个的`4`和一组三胞胎`2`、`3`和`8`。你可以检查字谜行并验证这确实是事实。

将这个逻辑翻译到 Haskell 现在相当容易:

```
isPossible :: Cell -> Bool
isPossible (Possible _) = True
isPossible _ = False

exclusivePossibilities :: [Cell] -> [[Int]]
exclusivePossibilities row =
  -- input
  row
  -- [Possible [4,6,9], Fixed 1, Fixed 5, Possible [6,9], Fixed 7, Possible [2,3,6,8,9],
  -- Possible [6,9], Possible [2,3,6,8,9], Possible [2,3,6,8,9]]

  -- step 1
  & zip [1..9]
  -- [(1,Possible [4,6,9]),(2,Fixed 1),(3,Fixed 5),(4,Possible [6,9]),(5,Fixed 7),
  -- (6,Possible [2,3,6,8,9]),(7,Possible [6,9]),(8,Possible [2,3,6,8,9]),
  -- (9,Possible [2,3,6,8,9])]

  -- step 2
  & filter (isPossible . snd)
  -- [(1,Possible [4,6,9]),(4,Possible [6,9]),(6,Possible [2,3,6,8,9]),
  -- (7,Possible [6,9]), (8,Possible [2,3,6,8,9]),(9,Possible [2,3,6,8,9])]

  -- step 3
  & Data.List.foldl'
      (\acc ~(i, Possible xs) ->
        Data.List.foldl' (\acc' x -> Map.insertWith prepend x [i] acc') acc xs)
      Map.empty
  -- fromList [(2,[9,8,6]),(3,[9,8,6]),(4,[1]),(6,[9,8,7,6,4,1]),(8,[9,8,6]),
  -- (9,[9,8,7,6,4,1])]

  -- step 4
  & Map.filter ((< 4) . length)
  -- fromList [(2,[9,8,6]),(3,[9,8,6]),(4,[1]),(8,[9,8,6])]

  -- step 5
  & Map.foldlWithKey'(\acc x is -> Map.insertWith prepend is [x] acc) Map.empty
  -- fromList [([1],[4]),([9,8,6],[8,3,2])]

  -- step 6
  & Map.filterWithKey (\is xs -> length is == length xs)
  -- fromList [([1],[4]),([9,8,6],[8,3,2])]

  -- step 7
  & Map.elems
  -- [[4],[8,3,2]]
  where
    prepend ~[y] ys = y:ys 
```

我们从`nextGrids`函数中提取`isPossible`函数到顶层以便重用。然后我们编写`exclusivePossibilities`函数，该函数在输入行中查找排他项。这个函数是用反向应用操作符 [`(&)`](https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Function.html#v:-38-) <sup id="fnref4">[4](#fn4)</sup> 代替通常的`($)`操作符编写的，这样我们就可以从上到下读取了。我们还显示了函数链中每一步之后样本输入的中间值。

该功能的核心在于第 3 步(双关语)。我们对所有非固定单元格和其中所有可能的数字进行嵌套折叠，以计算表示第一个表的映射 <sup id="fnref5">[5](#fn5)</sup> 。此后，我们过滤映射，只保留长度小于 4 的条目(步骤 4)。然后我们翻转它，创建一个新的地图，代表第二个表(步骤 5)。最后，我们过滤翻转图中单元计数与数字计数相同的条目(步骤 6 ),以得到最终的表格。step 7 只获取 map 中的值，map 是输入行中所有 Exclusives 的列表。

## 专门修剪细胞

首先，我们从前面的`pruneCells`函数中提取一些可重用的代码，并将其重命名为`pruneCellsByFixed` :

```
makeCell :: [Int] -> Maybe Cell
makeCell ys = case ys of
  [] -> Nothing
  [y] -> Just $ Fixed y
  _ -> Just $ Possible ys

pruneCellsByFixed :: [Cell] -> Maybe [Cell]
pruneCellsByFixed cells = traverse pruneCell cells
  where
    fixeds = [x | Fixed x <- cells]

    pruneCell (Possible xs) = makeCell (xs Data.List.\\ fixeds)
    pruneCell x = Just x 
```

现在我们编写`pruneCellsByExclusives`函数，它使用`exclusivePossibilities`函数来修剪单元格:

```
pruneCellsByExclusives :: [Cell] -> Maybe [Cell]
pruneCellsByExclusives cells = case exclusives of
  [] -> Just cells
  _ -> traverse pruneCell cells
  where
    exclusives = exclusivePossibilities cells
    allExclusives = concat exclusives

    pruneCell cell@(Fixed _) = Just cell
    pruneCell cell@(Possible xs)
      | intersection `elem` exclusives = makeCell intersection
      | otherwise = Just cell
      where
        intersection = xs `Data.List.intersect` allExclusives 
```

`pruneCellsByExclusives`完全按照上面的例子所示工作。我们首先找到给定单元格中的独占列表。如果没有独占性，那就没什么可做的了，我们只需返回单元格。如果我们发现任何排他性的，我们 [`traverse`](https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Traversable.html#v:traverse) 的细胞，修剪每个细胞，只有交集的可能数字的细胞和排他性的数字。就是这样！我们重用`makeCell`函数来创建一个有交集的新单元。

最后一步，我们通过合并两个函数重写了`pruneCells`函数。

```
fixM :: (Eq t, Monad m) => (t -> m t) -> t -> m t
fixM f x = f x >>= \x' -> if x' == x then return x else fixM f x'

pruneCells :: [Cell] -> Maybe [Cell]
pruneCells cells = fixM pruneCellsByFixed cells >>= fixM pruneCellsByExclusives 
```

我们从`pruneGrid`函数中提取了`fixM`作为顶层函数。就像`pruneGrid'`函数一样，我们需要使用一元绑定( [`>>=`](https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Monad.html#v:-62--62--61-) )来链接这两个修剪步骤。我们还使用`fixM`重复应用每一步，直到被修剪的细胞稳定 <sup id="fnref6">[6](#fn6)</sup> 。

不需要进一步更改代码。是时候检查这些改进了。

## 比飞驰的子弹还快！

让我们构建程序并运行与之前相同数量的谜题:

```
$ head -n100 sudoku17.txt | time stack exec sudoku
... output omitted ...
      0.53 real 0.58 user 0.23 sys 
```

哇哦。比以前快多了。现在让我们解开所有的谜题:

```
$ cat sudoku17.txt | time stack exec sudoku > /dev/null
      282.98 real 407.25 user 109.27 sys 
```

所以解决所有 49151 个谜题需要大约 283 秒。加速比约为 200x <sup id="fnref7">[7](#fn7)</sup> 。每个谜题大约需要 5.8 毫秒。

让我们快速分析一下，看看时间过得怎么样:

```
$ stack build --profile
$ head -n1000 sudoku17.txt | stack exec -- sudoku +RTS -p > /dev/null 
```

这将生成一个包含分析结果的名为`sudoku.prof`的文件。以下是五大最耗时的功能(为简洁起见，已清理):

| 成本中心 | 来源 | %时间 | %分配 |
| --- | --- | --- | --- |
| `exclusivePossibilities` | (49,1)-(62,26) | Seventeen point six | Eleven point four |
| `pruneCellsByFixed.pruneCell` | (75,5)-(76,36) | Sixteen point nine | Thirty point eight |
| `exclusivePossibilities.\.\` | 55:38-70 | Twelve point two | Twenty point three |
| `fixM.\` | 13:27-65 | Ten | Zero |
| `==` | 15:56-57 | Seven point two | Zero |

看着这个报告，我猜想很多时间都花在了列表操作上。Haskell 中的列表效率低下是众所周知的，所以也许我们应该转换到其他的数据结构？

### 更新

根据克里斯·卡辛希诺的[评论](https://abhinavsarkar.net/posts/fast-sudoku-solver-in-haskell-2/#comment-97ca7640-8531-11e8-a1d5-1fd7d3dbc496)，我运行了没有`-threaded`、`-rtsopts`和`-with-rtsopts=-N`选项的两个版本的代码。上一篇文章代码的时间:

```
$ head -n100 sudoku17.txt | time stack exec sudoku
... output omitted ...
       96.54 real 95.90 user 0.66 sys 
```

以及本帖代码的时间:

```
$ cat sudoku17.txt | time stack exec sudoku > /dev/null
      258.97 real 257.34 user 1.52 sys 
```

因此，在没有线程选项的情况下，两个版本的运行速度都提高了 10%左右。我怀疑这与本文中描述的 GHC 并行 GC 有关。所以现在，我将保持线程禁用。

## 结论

在这篇文章中，我们改进了上次的简单数独解决方案。我们发现并实施了一种新的策略来修剪细胞，并实现了 200 倍的加速。但是分析表明我们仍然有许多改进的可能性。我们将在本系列接下来的文章中讨论这个问题。目前为止的代码可以在[这里](https://code.abhinavsarkar.net/abhin4v/hasdoku/src/commit/9d6eb18229f905c52cb4c98b569abb70757ba022)找到。

*这篇文章最初发表在[我的博客](https://abhinavsarkar.net/posts/fast-sudoku-solver-in-haskell-2/)上。*

如果你喜欢这篇文章，请[留下评论](https://abhinavsarkar.net/posts/fast-sudoku-solver-in-haskell-2/#comment-container)。

* * *

1.  所有的运行都是在我 2014 年的 MacBook Pro 上完成的，配备 2.2 GHz 英特尔酷睿 i7 CPU 和 16 GB 内存。 [↩](#fnref1)

2.  在一个数独游戏中，至少要预先填充 17 个单元格，它才会有唯一的解决方案。所以 17 条线索的谜题是所有谜题中最难的。McGuire、Tugemann 和 Civario 的论文给出了相同的证明。 [↩](#fnref2)

3.  [【独生子女】](https://en.wikipedia.org/wiki/Single_child)中的“单身”。 [↩](#fnref3)

4.  反向应用操作在 Haskell 中用得不多。但在其他一些函数式编程语言中，这是函数链接的首选方式，如 [Clojure](https://clojuredocs.org/clojure.core/-%3E) 、 [FSharp](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/operators.%5b-h%5d-%5d%5b't1,'u%5d-function-%5bfsharp%5d) 和[elixin](https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2)。 [↩](#fnref4)

5.  我们使用[数据。Map.Strict](https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Strict.html) 作为 Map 实现。 [↩](#fnref5)

6.  我们需要使用`fixM`重复运行`pruneCellsByFixed`和`pruneCellsByExclusives`，因为未解决的行可能导致错误的解决方案。想象一下，有一排因为`pruneCellsByFixed`而被修复了一个`9`。如果我们不再次运行该函数，该行可能会留下一个带有`9`的非固定单元格。当我们通过`pruneCellsByExclusives`运行这一行时，它会将非固定单元格中的`9`视为单个单元格并修复它。这会导致同一行出现两个`9`，导致求解失败。 [↩](#fnref6)

7.  加速比计算:116.7/100 * 49151/282.98 = 202.7[↩](#fnref7)