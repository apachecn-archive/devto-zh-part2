# 软件设计哲学，第 0 部分:简介

> 原文:[https://dev . to/SW fisher/a-philosophy-of-software-design-4gdl](https://dev.to/swfisher/a-philosophy-of-software-design-4gdl)

***注:**这一系列文章是一个持续的、不可预测的发布周期中的活文档。有时间有灵感就修改一下。它的目的是帮助我理解和分享那些对我理解我们的工艺至关重要的想法。反馈肯定会被考虑和赞赏。*

> "在正确的时间提出正确的问题会带来自然而积极的努力."乔治·波利亚

作为软件工程师，我们喜欢在每一个时间点上朝着正确的结果不断前进。我们希望充分享受我们的工作，交付优秀的产品，并作为工匠不断成长。但是，在任何给定的时间点，我们如何提出正确的问题来激发正确的行动呢？我们如何组织我们的努力？

我们并不真正知道这些问题的答案，无论我们使用什么工具或原则来帮助我们导航。有些这样的想法被写下来，被理解；有些只是我们甚至没有意识到的潜意识把戏。

随着一代又一代的软件工程师对他们的工作进行反思，一些软件设计的全球策略已经出现并变得清晰。这些策略的代码反映了数学问题解决的普遍原则，并且在科学和工程的所有分支中都有有意义的类似物。

熟练的从业者倾向于在直觉层面上了解这些策略。对于一些人来说，很难用语言来描述那些已经很好地整合到他们的隐性知识中的工具。这意味着初学者可能要绞尽脑汁寻找有用的语言来解释为什么特定的软件设计是好是坏。

作为初学者，我们可以寻求将好的设计原则整合到指导我们日常实践的直觉中。对这些原则有一个明确的口头表述只是发展洞察力的一个指针。最终，是你的直觉在起作用。

### 好的主意

总的来说，设计软件就是研究抽象问题的自然结构，并简单而优美地表达这种结构。问题总是“我们如何对问题达成简单的理解，并在设计中反映这种理解？”但是为什么简单呢？

软件的封闭性和可预测性总是存在于开放和变化的人类环境中。简单的标准出现了，因为软件的成功或失败取决于它优雅地管理人类局限性的能力。

代码库对程序员来说直观上漂亮吗？

我们能轻易地将它的功能与一个新的想法整合起来吗？

我们能轻易地改变它的一部分是如何实现的吗？

对于最终用户来说，系统是否无缝运行？

最终用户是否能立即理解系统的功能？

等等...

下面的想法应该可以帮助我们同时实现所有这些目标。

### 优秀软件的设计原则

#### ①简朴

在这种情况下，简单意味着专注于一件事。一折。一个问题。一个责任。简单的想法容易且紧凑地符合我们的认知局限。达到简单能让你流畅轻松地思考问题。当我们很好地理解了一个主题，我们的理解就变得简单了。话虽如此，简单需要努力。

什么是复杂性？让我们决定它意味着关注许多事情。很多褶皱。很多问题。很多责任。这对我们来说是一个方便的定义。很明显，一个复杂的事物实际上是由许多简单的事物组成的。

#### (2)模块化

将任何复杂的问题分成一组最容易、最自然地表达完整图景的小想法。在编程中，每个小问题往往由系统的一个“模块”来解决。这有无数的好处，但最突出的是它允许你一次专注于问题的一个方面。作为一种解决问题的策略，这有时被称为“分而治之”

允许每个模块都有自己的身份，而不是依赖外部环境。正方形只是正方形。随机字符串生成器就是这样。故意避免模块和它们的上下文纠缠在一起，因为这会造成复杂性。这种策略被称为“脱钩”，或者把曾经绑在一起的东西拆开。

为你的模块使用好的名字，清楚地区分它们是什么。这些名称将作为一个词的总结，用于唤起对该模块的记忆。为有意义的分组创建简单的名称被称为“抽象”通过为某事创造一个词，我们可以退后一步，从鸟瞰的角度来描述它。我们现在在记忆中有了一个漂亮的衣架，当我们需要的时候，我们可以用它来回忆细节。

#### ③极小性

我们可以用许多简单模块的集合来解决复杂的问题。我们如何挑选好的藏品？

我们选择最小的模块集来实现最广泛的功能集。换句话说，我们以最小的努力寻求最大的杠杆作用。我们称这种理想状态为“极小值”一个成功的实现简单性的模块化方法是最小化的。最小化是通过在不丢失信息的情况下抛弃我们对问题理解的复杂性来实现的。

##### *(一)自相似性*

很多时候，问题包含隐藏的冗余信息。考虑将对称的形状分成两个相同的子形状的方式。当问题中的自相似性存在时，你总是可以抽象掉不变的方面来简化你的理解。

这在编程中经常以“递归对象”的形式出现，如集合、数组、图形、字符串等。所有这些通用结构都由该结构的较小实例组成，并且具有最小的可能版本。当一个递归结构或算法被选择时，程序员看着这个问题，看到自相似性在复杂性中回响。对于递归解决方案的经典示例，请查看“汉诺塔”

自相似性在计算机程序中表达的另一种方式是将计算中不变的因素从程序逻辑中折叠到数据中。这就是所谓的比例。如果计算的某些方面对于迭代过程中的每个元素都是相同的，那么将其抽象出来是有意义的。这具有双重效果，使程序更容易推理和运行更快。

最后，我们可以知道，如果我们应用于这个问题的语言和工具不能立即暗示有意义的自相似性，那么它们就是不自然的和无益的。分而治之的方法有无数种，如果我们的策略没有反映出问题的自然形态，那么它将会掩盖而不是揭示问题内在的递归结构。发现并尊重问题中的自相似性会带来“啊哈”时刻，因为它直接让我们变得简单。

##### *(b)正交性*

分离是简单性在问题分解中的表达方式。当两个空间正交时，这意味着它们彼此垂直，因此只有一个交点。

正交实体可以彼此独立地进化。它们也完美地最小化了信息冗余，因为它们没有任何共同点。最后，它们具有最大的组合“划算”,因为两个独立的事物可以以比两个依赖的事物更多的方式组合。

作为这个概念的一个粗略但有趣的类比，考虑一下我用一个杯子和一把刀比用两个杯子能做更多的事情。杯子和刀子都有有用的功能，但是杯子和刀子彼此之间的共同点比两个杯子少得多。

想象一下，我设计了一个杯子和刀的混合体，而不是一个正交的杯子和刀。我的杯型刀将充满不同关注点之间的妥协。它在促进切割和饮用两方面都不太有效。在最好的情况下，它将代表两个不相关的功能体不舒服地共享空间。这种纠结造成了不必要的复杂性。

你设计的正交模块也应该简单。一个简单的模块将有一个自然的清晰的表达，可测试性和可重用性，因为它的单一焦点。如果设计中的一个模块变得很复杂，你可以把它分成两个或多个正交的部分。这些将比两个纠缠在一起的部分更容易创造、进化和连接。

##### *(c)共性*

我们能在不增加维度的情况下扩大我们正在解决的问题吗？去掉不必要的细节是否有助于它呈现更清晰的形式？概括性就是通过这样有见地的减法和总结实现的。

我们从非常接近问题本质的角度开始思考。这可能会给我们留下一个设计，反映一个更普遍的问题的一个狭窄的情况。如果我们允许我们的问题模型摆脱它出现的领域的束缚，我们可以实现超出最初期望的功能，同时在本质上变得更简单。如果当你尝试这样做的时候，工作范围扩大了，那么你很可能给问题增加了一个额外的维度。如果它缩小了，那么你可能已经从模型中移除了一些任意的特性，并向极小化移动。

#### (4)可组合性

我们正在创建的所有这些整洁、独立的模块需要很好地沟通，否则它们不会帮助我们解决问题。此外，如果我们的模块可以与我们还没有想到的其他系统通信，我们可以获得巨大的通用性。你的模块的干净接口允许他们完成这两个目标。

可组合性是对任何给定系统模块对不同模块的输出进行操作的简单程度的度量。

针对可组合性的优化涉及耦合和解耦模块的权衡。REST 的设计是一种网络应用程序架构，它约束 API 为所有客户端应用程序提供统一的接口。这在可组合性方面创造了巨大的收益，但代价是一些性能优化，这些性能优化可能来自于将接口紧密耦合到客户机。我们能做的最起码的事情就是在可组合性方面获得免费的收益。我们所能做的最大限度包括与其他可取的品质妥协。

可能的话，支持简单和通用的输入和输出格式。在与模块交互时，提供最不令人惊讶的开发人员体验。使用简洁地描述每个模块的单一焦点的名称。好的名字是代码的起点，它使你对问题的理解立即可见。

### 迈向优秀软件的过程

这给我们留下了什么？我们已经确定了一些好的软件设计的核心原则，但是这些原则只是明确地告诉我们如何安排我们的时间和精力。

在我看来，创建软件是一门发现和分解问题的学科。在接下来的文章中，我将根据上面讨论的原则为设计软件设计一个相当通用的模型。我将从乔治·波利亚的书《如何解决》中概述的被称为“波利亚问题解决”的广义问题解决方法中得出这个过程的框架每篇文章都将处理这个过程的一个阶段。

### 为我们的过程勾勒轮廓

1)理解问题——发现并定义需求
2)设计解决方案——阐明系统设计
3)智能地实现解决方案划分工作
4)从反思中学习——使用自我评估和扩展
5)从与现实和人们的接触中学习——使用度量、延迟优化和适应意外
6)向前迭代——在变化的环境中保持健壮性和可伸缩性。

每个阶段都有不完整或持续时间过长的风险，并且需要良好的启发式方法来决定何时前进。更正式地说，我们序列中的每个相变都是一个最优停止问题的实例。工作通常永远不会完美，永远不会完成。

接下来，我们深入第 1 部分:理解问题。

### 灵感

[科学与工程中的洞察力艺术-桑乔伊·马哈詹](https://ocw.mit.edu/resources/res-6-011-the-art-of-insight-in-science-and-engineering-mastering-complexity-fall-2014/online-textbook/MITRES_6-011F14_art_insfin.pdf)
[Unix 编程艺术-埃里克·雷蒙德](http://www.catb.org/esr/writings/taoup/html/)
[务实的程序员-安德鲁·亨特和戴维·托马斯](https://pragprog.com/book/tpp/the-pragmatic-programmer)
[架构风格和基于网络的软件架构设计-罗伊·菲尔丁](https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf)
[系统设计面试-教育设计大师 io](https://www.educative.io/collection/5668639101419520/5649050225344512)
[如何解决-乔治·波利亚](https://en.wikipedia.org/wiki/How_to_Solve_It)
[一个美丽的问题](https://www.penguinrandomhouse.com/books/312435/a-beautiful-question-by-frank-wilczek/9780143109365/)

### 特别感谢

Andy Pickle，说服我在 dev.to
Ry Whittington 上写文章，指出了一个重要的错别字(见下面的讨论)