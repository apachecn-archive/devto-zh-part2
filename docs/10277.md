# 基于属性的测试简介

> 原文:[https://dev . to/jdsteinhauser/intro-to-property-based-testing-2cj 8](https://dev.to/jdsteinhauser/intro-to-property-based-testing-2cj8)

> 基于属性的测试根据输入生成关于代码输出的语句，这些语句针对许多不同的可能输入进行验证。——杰西卡·可儿([@杰西特龙](https://twitter.com/jessitron))

基于属性的测试是生成测试。与单元测试一样，您不需要提供带有预期输出的特定示例输入。相反，您定义关于代码的属性，并使用生成测试引擎(例如，快速检查)来创建随机输入，以确保定义的属性是正确的。

# 生成性测试的目的是什么？

一般来说，基于属性的测试只需要几行代码(就像单元测试一样)，但是与单元测试不同的是，它们每次测试一组不同的输入。因此，您最终会用大致相同数量的测试代码覆盖更多的领域空间。

基于属性的测试也促进了对被测函数更深入的理解。当然，我们知道加法 2 + 2 = 4，但是你怎么能说你真的用那个例子正确地实现了加法函数呢？

从商业的角度来看，更好地理解代码的功能将导致更准确地确定代码中满足的需求。

# 它能代替单元测试吗？

虽然说单元测试可以被高质量的基于属性的测试完全取代是很有诱惑力的，但是单元测试仍然在软件开发周期中占有一席之地。基于实例的测试对于 TDD 的早期阶段来说是非常棒的。这些作为锚点来确保您的开发工作按预期进行。例如:

*   您可以确保您的正弦函数正在生成正确的值(`sin(0) = 0`、`sin(π/2) = 1`等)。)
*   如果没有正确的认证头/cookie，将导致一个`401`响应代码

然而，最终这些基于实例的测试会变成被动的测试；测试成为回归套件的一部分，并且不提供关于功能的新信息。然而，基于属性的测试总是主动的测试，因为它们在每次运行测试套件时都会生成新的数据。这有助于根除开发人员忽略的问题。例如，您可能期望任何浮点表示的正弦函数的输出都在集合[-1，-1]中，但开发人员可能不会考虑测试∞或 NaN。为此，当一个失败的案例被识别时，这个意外的错误可以被用作一个未来的单元测试来验证所做的修正。仅仅这个原因就使得基于实例的测试成为增强基于属性的测试套件的有效实践。

> “不要写测试。生成它们！”-约翰·休斯，哈斯克尔的原始快速检查的合著者

# 有哪些共同的属性？

如果您将软件功能与数学功能相关联，那么您可以将一些标准的数学属性应用于一些预期的功能。然而，其中一些属性在非数学应用中并不明显。下面是几个转换为函数属性的数学属性示例(Eric Normand 提供了更新)，忽略了性能差异:

*   联想—`a + (b + c) = (a + b) + c`

    *   `hashmap1.merge(hashmap2.merge(hashmap3)) = (hashmap.merge(hashmap2)).merge(hashmap3)`
    *   `list1.append(list2.append(list3)) = (list1.append(list2).append(list3)`
    *   `Math.max(Math.max(a, b), c) = Math.max(a, Math.max(b, c))`
    *   `(bool1 && bool2) && bool3 = bool1 && (bool2 && bool3)`
*   可交换的–`a + b = b + a`

    *   `users.Sort().Filter(x => !x.IsAdmin) = (users.Filter(x => !x.IsAdmin)).Sort()`(从关联重新定位)
    *   `image.flipX().flipY() = image.flipY().flipX()`
    *   `Math.max(a,b) = Math.max(b,a)`
    *   `bool1 && bool2 = bool2 && bool1`
    *   `average(a,b) = average(b, a)`
*   分配的-`a(b + c) = ab + ac`

    *   `title.ToUpper() + author.ToUpper() = (title + author).ToUpper()`
*   幂等-`f(a) = f(f(a))`

    *   `Math.abs(x) = Math.abs(Math.abs(x))`
    *   `hashmap.merge({a:1}) = hashmap.merge({a:1}).merge({a:1})`
    *   `title.Trim() = title.Trim().Trim()`
    *   `list.Sort() = list.Sort().Sort()`
*   身份—`f(a, i) where i is identity value of f = a`

    *   `a + 0 = a`
    *   `a * 1 = a`
    *   `userNames.append([]) = userNames`
    *   `hashmap.merge({}) = hashmap`
    *   `bool1 && true = bool1`
*   零-`f(a, z) where z is zero value of f = z`

    *   `a * 0 = 0`
    *   `intersect(valueSet, emptySet) = emptySet`
    *   `bool1 && false = false`

还有一些额外的、经过普遍测试的属性，它们不一定来源于数学，但同样有用:

*   比尔博测试(又名，那里又回来了)
    *   `list = list.Reverse().Reverse()`
    *   `obj = JSON.parse(JSON.stringify(obj))`
*   没有意外的变化
    *   `list.Length = list.Sort().Length`
*   难以证明，易于验证
    *   排序:每个元素应该大于或等于前一个元素
    *   标记化:用分隔符连接标记应该等于原始字符串，标记的数量应该等于原始字符串中分隔符的数量- 1

# “现实世界”中实际使用的是 PBT 吗？

简而言之，是的。基于属性的测试绝对用于解决现实世界的问题。

## 沃尔沃

沃尔沃采用 QuviQ 的 QuickCheck 来验证符合通信总线标准的第三方组件。约翰·休斯和他的团队分析了 3000 页的需求，编写了 20000 行快速检查测试，并将这些特性应用于 1000 多行供应商代码。通过检查围绕规范生成的属性，他们发现了 200 个问题，这些问题已经通过了供应商生成的测试装置...其中 100 个问题在实际的规范中。通过细化分析的代码(以及定义的规范)，基于属性的测试拯救了生命。

## Clojure

clo jure(JVM 上的一个 LISP 变体)默认使用不可变的数据结构。但是，可变数据类型可以提高性能。使用基于属性的测试，在转换瞬态(可变的)和持久(不可变的)结构时发现了一个问题。然而，基于属性的测试能够很容易地重现这个问题。向 cogn itect(clo jure 的开发人员/维护人员)提供了一个 diff 补丁，它被合并到 Clojure 1.6 版本中。

## 亲身经历

我还在一个项目中使用了基于属性的测试，在这个项目中，我们通过各种指标(QoS、包类型、包大小等)来计算网络性能。).我必须证明我的数据包分类和匹配算法不会提供错误的匹配，所以我将 CI 服务器设置为生成 1 亿个不同的数据包，分布在我们感兴趣的不同数据包类型之间。到目前为止，我们已经随机生成了超过 100 亿个数据包，没有一个错误匹配。

# PBT 套件中有哪些很棒的零件值得期待？

## 缩小

虽然大量输入可能会产生错误，但一些基于属性的测试套件(大多数 QuickCheck 变体)会尝试将输入序列缩减到最小，以尽可能地再现错误。输入越小，越容易重现和修复。

## 竞赛条件

众所周知，竞争条件很难通过基于实例的测试来设置。一些 PBT 套件(值得注意的是，QuviQ 在 Erlang 中的 QuickCheck)可以并行执行许多操作，以便测试以任何串行组合执行的操作是否会产生相同的输出。如果并行版本不能与串行版本匹配，则竞争条件被识别并缩减到最小可能的操作集以再现错误。

## 自定义发电机

您可能希望限制正在测试的输入域，或者以特定的方式构建数据结构。大多数 PBT 套件将允许您创建定制生成器，并且通常还包括许多常见的定制生成器——将字符串限制为可打印的字符、约束浮点值等。如果您从一种算法迁移到另一种算法，可以使用一个将相同的输入传递给新旧实现的 PBT 测试套件来确保新实现产生相同的输出。

# 哪里可以了解更多？

幸运的是，在互联网上有几个很好的基于属性的测试学习资源。以下是我发现的一些非常有用的方法。

*   [假设，快速检查每种语言](https://hypothesis.works/articles/quickcheck-in-every-language/)
*   [约翰·休斯，经受考验并保持理智](https://www.youtube.com/watch?v=zi0rHwfiX1Q)
*   [弗雷德·赫伯特，适当的测试](http://propertesting.com)
*   Jessica Kerr，基于属性的测试:它是什么？
*   Scott Wlaschin，基于属性的测试简介