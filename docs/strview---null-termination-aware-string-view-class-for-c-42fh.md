# C++的支持空终止的字符串视图类

> 原文：<https://dev.to/reg__/strview---null-termination-aware-string-view-class-for-c-42fh>

**TL；我写了一个小库，我称之为“str _ view-null-termination-aware string-view class for c++”。您可以在下面的 GitHub 资源库中找到代码和文档。请继续阅读，了解背后的完整故事...**

## ![GitHub logo](img/292a238c61c5611a7f4d07a21d9e8e0a.png) [萨维奇亚普](https://github.com/sawickiap) / [ str_view](https://github.com/sawickiap/str_view)

### C++的支持空终止的字符串视图类

<article class="markdown-body entry-content container-lg" itemprop="text">

# str_view

C++中支持空终止的字符串视图类。

作者:亚当·萨维奇-[http://asawicki . info](http://asawicki.info)
版本:2.0.0-beta.1，2020-04-26
许可:麻省理工学院

文档:见下文和`str_view.hpp`文件代码中的注释。

# 介绍

str_view 是一个小型的 C++库，它提供了一个方便且优化的类，将视图表示成一个字符串。它有一个单独的头文件形式:`str_view.hpp`，你可以将它添加到你的项目中。所有的成员都被定义为`inline`，所以不需要编译额外的 CPP 文件或链接额外的库。

str_view 只依赖于标准的 C 和 C++库。它是在 Windows 下使用 Microsoft Visual Studio 2019 开发和测试的，但它应该也可以在其他编译器和平台上工作。如果您发现任何兼容性问题，请告诉我。它在 32 位和 64 位代码中都有效。

该类被定义为`str_view_template`，因为它是…

</article>

[View on GitHub](https://github.com/sawickiap/str_view)

我来透露一下我有争议的信念:我喜欢 C++ STL。我认为任何编程语言都需要提供一些内置的字符串和容器，才能称得上现代，适合开发大型程序。但是我当然知道，由于大量的动态分配，像`std::list`或`std::map`这样的类的粗心使用会使程序非常慢。

我最看重的是 RTTI——每当值引用的对象被销毁时，内存就会自动释放的概念。这就是为什么我在我的个人代码中到处使用`std::unique_ptr`。每当我创建并拥有一个数组时，我都会使用`std::vector`，但是当我只是将它传递给其他代码进行读取时，我会传递原始指针和元素数量——`myVec.data()`和`myVec.size()`。类似地，每当我拥有并构建一个字符串时，我都使用`std::string`(或者更确切地说是`std::wstring`——我喜欢 Unicode)，但是当我将它传递到某个地方进行读取时，我使用原始指针。

有多种方法可以传递字符串。一个是指向第一个字符和字符数的指针。另一个是指向第一个字符的指针和指向倒数第二个字符的指针——一对迭代器，也称为范围。这两者可以很容易地相互转换。在这些中，我更喜欢指针+长度，因为我认为这个字符数比指针超出长度更需要。

但是还有另一种在 C 和 C++程序中常见的传递字符串的方法——只有一个指向需要以空终止的字符串的指针。我认为空终止字符串是计算机科学中最糟糕和最愚蠢的发明之一。它不仅通过排除`'\0'`限制了字符串内容中可使用的字符集，还使得字符串长度的计算时间复杂度为 O(n)。这也为安全漏洞创造了机会。我们仍然必须处理它，因为这是大多数图书馆期望的格式。

我想到了一个类的概念，它封装了对外部拥有的、不可变的字符串或其中一部分的引用。这种类的对象可以用来将字符串传递给库函数，而不是例如指向空终止字符串的指针或一对迭代器。然后可以对它们进行查询`length()`，索引以访问单个字符等。，以及使用`c_str()`方法要求空终止的副本——类似于`std::string`。

像这样的代码已经存在，例如 C++17 引入了类`std::string_view`。但是我的实现有一个我很满意的变化，它让我称我的类为“空终止感知的”。我的`str_view`类不仅记住了指针和被引用字符串的长度，还记住了它的创建方式，以避免不必要的操作并延迟评估那些被请求的操作。

*   如果它是从以 null 结尾的字符串创建的:
    *   `c_str()`平凡地返回指向原始字符串的指针。
    *   长度未知，在第一次调用`length()`时计算。
*   另一方面，如果它是从非空终止的字符串创建的:
    *   长度是显式已知的，所以`length()`很容易返回它。
    *   `c_str()`在第一次调用时创建字符串的本地空终止副本。

如果您认为这样的类在您的 C++代码中有用，请参见**[GitHub-sawickiap/str _ view](https://github.com/sawickiap/str_view)**项目以获得代码(它只是一个头文件)、文档和大量测试。我在麻省理工学院许可下免费分享这段代码。如果您发现任何错误或者对这个库有任何建议，请随时联系我。