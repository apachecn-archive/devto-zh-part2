# Shippable 的微服务之旅

> 原文:[https://dev . to/pavanbelagatti/shippeables-journey-to-micro services-4305](https://dev.to/pavanbelagatti/shippables-journey-to-microservices-4305)

这篇博客最初发表于[可发货](http://blog.shippable.com/our-journey-to-microservices-and-a-mono-repository)

微服务是目前软件开发中最热门的话题。这个概念很简单:将您的应用程序分解成更小的部分，每个部分执行一个业务功能，并且可以独立开发和部署。这些片段通常被称为服务，然后可以使用类似 nginx 或 consul 的某种服务发现组装成应用程序。微服务方法被认为是希望构建可扩展平台并在其上高效快速创新的团队的首选架构。

尽管我对这种架构非常着迷，但我们的微服务之旅是一条漫长而曲折的道路。它最终将我们引向一个版本的架构，该架构为我们提供了业务所需的可伸缩性和敏捷性。我想在一系列关于这个话题的博客中分享我的想法、经验和教训，这样你可以从我们的经历中受益。此外，我希望得到您对我们方法的反馈或意见。

当你开始转向微服务时，在你写一行代码之前的第一个问题是:你如何组织你的代码库？您是为每个服务创建一个存储库，还是为所有服务创建一个“单一存储库”？

多个存储库
我们从多个存储库的第一种方法开始。这更有意义，原因有很多:

清晰的所有权:由于代码库模仿架构，一个小团队可以拥有并独立开发和部署微服务的整个堆栈。

规模更小的代码库更容易管理，也更少出现“合并地狱”。团队不需要与其他团队协作，从而提高执行速度。

窄克隆包括 git 在内的大多数源代码管理提供者都不支持存储库的克隆部分。对于大型代码库，克隆、拉取和推送需要太多时间，效率很低。

那么这对我们有用吗？在 Shippable，我们经营着一个相当大的、分布在多个时区的分布式组织。当我们最初将 5 层平台分解为微服务时，我们最终得到了 50 多个服务，每个服务都有自己的代码库。然后混乱开始了。

跨松散耦合的存储库实施代码标准化是一项挑战。这意味着代码阅读起来变得非常复杂，而且没有人能够完全理解这个平台。这导致了对拉请求的代码审查是无效的——从事相同服务的人缺乏对全局的理解，任何不从事该服务的人都没有相关的上下文。由于没有共享组件，我们也在团队间重复工作。

具有讽刺意味的是，将团队与服务和回购紧密耦合导致了我们的大多数问题。我们意识到，我们希望建立一个拥有跨服务知识的团队，而不是几个拥有本地化知识的团队。

为了解决这些问题，几个月前我们转向了“mono repo”。这意味着即使我们的服务仍然是独立开发和部署的，所有服务的代码都在一个存储库中。几乎立刻，我们就看到了这些改进:

更好的开发人员测试:开发人员可以轻松地在他们的机器上运行整个平台，这有助于他们理解所有的服务以及它们是如何协同工作的。这导致我们的开发人员甚至在发送拉取请求之前就在本地发现了更多的 bug。

降低代码复杂性:高级工程师可以很容易地跨所有服务实施标准化，因为很容易跟踪整个存储库中发生的拉请求和变更。

有效的代码审查:大多数开发人员现在理解了端到端平台，导致更多的错误在代码审查阶段被识别和修复。

共享公共组件:开发人员可以看到所有服务中正在发生的事情，并且可以有效地开发公共组件。几个星期后，我们实际上发现每个微服务的代码变得更小了，因为许多公共功能被识别并在服务间共享。

简单的重构:任何时候我们想要重命名某个东西，重构就像运行一个 grep 命令一样简单。重组也更容易，因为所有东西都整齐地放在一个地方，更容易理解。

结果呢？我们的生产率至少提高了 5 倍。

我们转向 mono repo 的最大好处是，我们没有放弃微服务架构的任何优势。

我们相信 mono repos 是希望更快发布代码的团队的正确选择。有人担心这不会很好地扩展，但这些都是没有根据的。像推特、谷歌、脸书这样的公司运行着有 1000 名开发者的大规模单一回购协议。

使用 mono repo，您真正放弃的唯一一件事是能够让开发人员远离他们没有参与的代码。在一个有着正确招聘实践的健康组织中，没有理由这样做。除非你有妄想症...或者叫苹果。

今天就去单声道，比以往任何时候都更快地开始运送编码器！

这篇博客最初发表于[可发货](http://blog.shippable.com/our-journey-to-microservices-and-a-mono-repository)