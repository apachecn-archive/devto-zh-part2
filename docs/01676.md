# 优化 AWS Java Lambdas

> 原文:[https://dev.to/adjohn/optimizing-aws-java-lambdas-4kmo](https://dev.to/adjohn/optimizing-aws-java-lambdas-4kmo)

*这最初是由[斯蒂芬妮·高罗里斯基(Xer)](https://twitter.com/multiphasicapps) 在 [IOpipe 博客](https://read.iopipe.com/optimizing-aws-java-lambdas-3ea2b872fe74)上撰写的。*

如果您的 Java lambdas 运行缓慢，找到罪魁祸首可能是一场噩梦！本文将涵盖一系列可靠的技巧，您可以利用这些技巧来优化您的代码，使其运行得更快，或者使用更少的内存。

有许多优化技术可以使用，根据具体情况，有些技术会比其他技术更好。在本文中，我们将集中讨论可以改进 Java AWS Lambda 函数的优化。

# 查找哪部分功能慢

优化的时候最重要的是知道从哪里优化。这是一个分析器可以帮助你的；它可以非常详细地告诉你，你的代码中所有潜在的性能问题区域。

请注意，分析器数据可能并不总是精确的，有时这种不精确可能会歪曲情况，因此它们应该真正用作指向需要优化的代码的指针。这是一个可用的工具，而且当您查看自己代码的性能时，它可能非常重要。

当然，您不需要使用 profiler，您可以通过在代码块的开头和结尾使用`System.nanoTime()`来测量执行需要多长时间。这自然只是一个简单的度量，并且比使用一个成熟的分析器开销要少得多。

这样做可能有助于您只关注代码的某一部分，而不是看到代表所有代码的所有数据。它可能非常简单，但就像由`System.err.printf()`生成的调试消息一样，它添加起来很快也很容易，你唯一能得到的就是你特别要求的信息。您甚至可以将这与剖析结合使用，让您更好地了解您的代码发生了什么，并且使用`printf()`您可能会发现这种情况只在某些情况下发生——剖析器通常不包含关于方法输入的任何信息，因此它们缺少一些上下文。

# 首先要看的地方:算法

无论您计划执行哪种优化，首先要检查的因素是您在代码中使用的算法是否是最佳的。在许多情况下，对所用算法的改进会超过对代码执行的其他优化，从而节省时间和金钱。

例如，如果您正在对用户传递的数字或其他条目进行排序，那么您将需要选择一种排序算法。诸如选择排序这样的算法会很慢，而合并排序会执行得更好。如果你花时间优化选择排序，那么在大多数情况下，即使是写得最糟糕的合并排序也可能比你的精简快速选择排序运行得更快。

# 降低你的类的复杂度

在我以前的文章[中有很多关于这个解决方案的讨论，Java 库是你的λ敌人](https://read.iopipe.com/java-libraries-are-your-lambda-enemy-6c9467321d2b?utm_source=devto&utm_campaign=java_lambda_optimization_post)。当虚拟机初始化一个类时，它解析该类并需要加载该类的所有信息，然而这本身并不是一个复杂的过程。复杂性通常来自于 JIT 编译器需要编译所有代码，以便它在虚拟机中运行得更快。然而，大量的简单类会减慢这个过程，因为虚拟机需要处理更多的类；尤其是当有许多类依赖时。所以你应该降低你的类的复杂度和类的数量。

这似乎是一个显而易见的解决方案——更少的类意味着虚拟机要做的事情更少。但是很容易意外地添加看似很小的库，结果却需要很多依赖项。需要特别注意的一点是`ServiceLoader`——服务加载器发现的任何类都将在迭代时被初始化。因此，这意味着您可能从未使用过的服务可能会被初始化。如果您需要使用服务加载器来发现服务，那么这些服务类实现应该是简单的工厂类。

# 需要时初始化变量和类并使用缓存

这是变化的，但通常在普通服务器上的做法是在程序启动时尽可能地初始化。由于流程的生命周期更长，这些步骤在开始时就完成了，所以从长远来看，它们不会真正成为问题。然而，在 Lambdas 中，由于冷启动期间的大量争用，初始化每个变量所花费的时间将是昂贵的，并会占用您的初始冷启动，这可能会超时或不够快，以至于淹没 lambda。

所以为了减少冷启动的压力，你应该选择只在需要的时候初始化数据。这样，任何复杂的数据都只会在需要时被初始化。

如果您的类生成了任何其他按需使用的对象，如果它们并不总是需要的，那么您可以使用缓存将其保存在内存中一段时间。如果可以回收缓存的对象，就可以节省该类的初始化时间。

实现该缓存的正确方法是使用`SoftReference<T>`，该引用将一直指向该对象，直到没有对它的强引用(字段和变量)，并且当内存耗尽时(在垃圾收集期间)。如果您需要知道参考何时被清除，那么您可以使用`ReferenceQueue<T>`；请注意，这使用了轮询，轮询可以立即返回，也可以等到对象可用时再返回，因此，如果使用了队列，最好将其放在自己的线程中。

# 避堵

当代码必须具有低延迟时，最糟糕的事情之一就是阻塞。当您在另一个线程(`synchronized`、`Object.wait()`和`Lock.lock()`)中等待数据时，或者当您在等待远程请求(比如 HTTP)的结果时，就会发生这种阻塞。任何时候你的程序只是坐着等待事情发生，都是浪费时间。因为一次只执行一次 Lambda，所以如果 CPU 根本没有被使用，那就没有任何好处，因为无论使用多少 CPU，你的成本都是一样的(如果你`Thread.sleep()`使用了很长的持续时间，尽管什么都没有发生，你也会付出代价)。

如果在你的代码中可能的话，减少阻塞时间的一个方法是创建一个在后台工作的线程，然后当你真正需要结果的时候，你可以阻塞直到它可用。你可以有一个存储计算结果的 worker 对象，其中有一个原子类型(如`AtomicInteger`或`AtomicObject<T>`)，读取该值以查看是否有可用的，如果没有，则锁定一个监视器，然后等待计算结果，循环读取并忽略`InterupptedException`。

或者，一个更具执行性的实现将使用`ReadWriteLock`和`Condition`来执行相同的功能(因为较低级别的锁，尽管需要更多的实现工作，但可以比`volatile`和`synchronized`执行得更好)。

当然，如果线程必须运行并完成，但不需要结果，那么它可以等待锁，一旦获得锁，它就可以解锁并退出。当然，如果你想避免使用锁，而是不断地从一个原子变量中读取数据，直到某个值被设置，那么你的 busy 循环应该`Thread.yield()`，这样我们就可以告诉操作系统，我们想放弃剩余的 CPU 片，把它交给另一个线程。让步可能会也可能不会产生影响，这取决于 lambda 运行所在的容器中可以同时运行的线程数量，但是如果没有足够的资源来同时运行这么多线程，它将释放 CPU 片，以便实际正在做某件事情的线程可以做它需要做的事情。

* * *

希望这些信息对你有用，可以用来帮助优化你的 Lambdas，使它们性能更好，降低你的成本，让你更快地满足请求。