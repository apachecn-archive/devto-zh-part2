# 重构指南

> 原文:[https://dev . to/rlxdprogrammer/the-refactoring-guideline-1377](https://dev.to/rlxdprogrammer/the-refactoring-guideline-1377)

软件生命周期

几乎所有的软件都是带着美好的计划和厚望开始的。开始的那个人认为它将来会满足所有的要求。后来第一个版本已经实现了，通常它已经不完全按照原来的计划。随着时间的推移，新的需求不断出现:新的功能需要添加，一些行为需要改变，一些错误需要修复。这些活动通常以尽可能快的态度完成。不去想未来，不去想过去，不去想架构，只是用最快的方式解决。过一会儿，会有一个代码基本上做了它应该做的事情，但是代码质量很糟糕，它通常以一种奇怪的方式管理内存，这导致了一些棘手的错误。运行时既不是最佳的。有很多代码重复和死亡代码，很难确定在出现新需求时应该改变什么。因此，即使是一个小功能的实现也可能需要很长时间。还有一件更重要的事情:大多数开发人员都讨厌处理质量如此糟糕的代码！

# 重构的意义是什么？

重构是以质量会变得更好的方式改变代码，但是它的行为不会改变。因此，例如修复 bug，或者让行为更加用户友好，都不是重构的一部分。但是，增加代码可读性或模块化的代码更改，或者在运行时或内存使用方面实现更好性能的更改，都是重构的一部分。

# 重构有什么好处？

在重构过程中，你总是在提高代码的质量，换句话说:你在让你的代码变得更好。代码质量是一个相当复杂的话题，但我认为主要是以下几点:稳定性、可读性、模块化、可维护性、可靠性、效率、安全性、可测试性和大小。因此，在你重构的过程中，你正在处理一个或多个关于这段代码的问题，你正在从选定的目的出发使你的代码变得更好。请注意，不同的目的可能是矛盾的。例如，通常你可以通过使用更多的内存来获得更好的运行时间。

这就是它的理论基础。但是让我们看看现在的练习。正如我在引言中所说，通常一个软件的代码库随着时间的推移变得越来越复杂，同时它的质量也越来越差。通常，它的可读性、可维护性和可靠性都会下降。这意味着到处都有虫子。由于可读性差，找到错误的根本原因需要很长时间，由于可维护性差，修复这些问题也需要很长时间。由于错误的代码结构，实现新功能也需要很长时间。所以这个项目将会达到一个阶段，很多人都在做这个项目，但是没有什么大的成果。看起来他们什么也没做，只是让代码活着。这是浪费时间和金钱。此时通常是重构代码库并达到更好的可读性、可维护性和稳定性的时候。所有其他点总是取决于情况，例如，如果程序运行缓慢，当然运行时间也将是一个焦点。

低层次的好处是更好的代码质量，高层次的好处就是钱。

# 如何从重构入手？

正如我所说的，重构意味着不改变行为的代码改变。在改变任何事情之前，你需要非常了解当前的行为。这应该以某种方式记录下来。最简单的解决方法是把它写在文档里。但是一个更有效的解决方案是，如果可能的话，为你的代码实现自动化测试。事实上，几乎在每种情况下都是可能的，除了一些非常特殊的情况。你需要实现覆盖整个功能的测试用例，这些测试用例独立于实现细节，并在当前代码基础上传递。每次更改后，您都可以运行它们来检查它们是否仍然是绿色的。

一旦完成，就可以进入组件级了。这里，即使它们还没有出现，你也应该在组件的层面上思考:你的程序的主要功能是什么，这些功能如何分类，你的架构的不同层次是什么。这几点都需要考虑。组件应该有明确的职责和定义良好的输入和输出接口。

一旦你弄清楚了主要的组件，试着把你现有的代码库分成这些组件，并在它们之间使用预定义的接口。这可能具有挑战性。可能你也需要减少课程或函数。始终确保您的代码正在编译，并且您的自动化测试正在通过。

如果你的代码已经基于组件进行了组织，你可以使用它们的接口编写一些组件级的自动化测试。所以以后如果测试失败，你就会知道哪个组件有问题。

# 应该重构什么？

重构可以在不同的层次上进行，也可以有不同的目的。让我们从主要目标是提高可读性和可维护性的情况开始。

我建议从最高层开始。检查您当前的组件。他们有明确的单一责任吗？他们的界面是否足够清晰？是否有重复的接口？沟通工作流程是不是越简单越好？如果任何一个问题的答案是否定的，你应该从这个层次开始。将过于复杂的组件拆分成多个组件，去掉不需要的接口，使组件之间的通信更容易。

下一步检查每个组件并检查它们的类:它们有清晰简单的职责吗？他们有清晰的公共接口吗？它们是否以最佳方式相互连接？如果任何一个答案是否定的，你就应该在这个层面上进行改变。在这个层面上，你应该始终遵循所谓的坚实原则:

*   单一责任原则

    你的每一个班级都应该有简单明确的责任

*   开放/封闭原则

    你的代码应该对扩展开放，但对修改关闭

*   利斯科夫替代原理

这可能有点复杂。但这意味着你的每个父类都可以被它的任何子类替换，而不会影响功能

*   界面分离原理

你的界面应该小而清晰，并且有一个明确的目的。所以你应该避免使用返回大量数据的接口。

*   从属倒置原则

你应该以这样一种方式设计你的类，作为你的类的依赖的类可以通过一些 setter 函数或者构造函数参数来设置。以便以后可以将它们更改为任何子类型。例如，如果你有一个用于创建日志文件的 *Logger* 类，并且你可以通过 setter 函数来改变它，你可以在 *XMLLogger* 、 *JSONLogger* 或 *SimpleLogger* 之间改变你的 Logger，如果所有这些类都是从同一个 *Logger* 基类派生的话。如果在单元测试中你需要模拟你的依赖关系，这也是有帮助的。

一旦你完成了你的类的重构，就进入到函数的层次。在这一步，尽量消除有太多参数的函数。尝试将长函数拆分成多个函数。尽量消除代码重复。明确区分返回某些值但不改变对象状态的函数和旨在改变对象状态的方法。在这一点上，确保你的代码被单元测试所覆盖。如果没有，那就盖吧。确保你的函数名和变量名足够清楚，如果需要的话重新命名它们。定义常数，而不是一些幻数。这是一个非常复杂的主题，要在一篇文章中解决所有问题。现在，一旦你完成了这一层的重构，继续回到你的类层。现在有没有什么职业应该被分成多个职业？如果是，请这样做。下一步在组件级别做同样的事情。在这一点上，你可能会看到，这是一个永无止境的故事。没有完美的代码。有更差的代码和更好的代码。你的代码可以永远更好，但永远不会完美。您需要在重构和新特性的实现之间找到恰当的平衡。

如果这种重构的目标是达到更好的性能，你需要从另一个角度分析你的代码。您应该监控您的运行时，并从运行时的角度确定哪些是最关键的组件和功能。找到他们之后，你可以做两件事:找到优化他们算法和沟通方式的方法。或者把某些部分改成多线程。多线程又是一个复杂的话题，这里要小心，要特别注意共享内存字段。还有一点:创建一个新线程并不总是能带来更好的性能！

# 总结

正如已经提到，重构确实是一个复杂的话题，但是几乎在任何地方都需要它。我试着给你一个大概的概述，希望对你有帮助。

[http://howtosurviveasaprogrammer.blogspot.com/](http://howtosurviveasaprogrammer.blogspot.com/)