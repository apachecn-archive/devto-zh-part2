# 三减一规则

> 原文:[https://dev.to/mdabek/the-rule-of-three 减一 188 便士](https://dev.to/mdabek/the-rule-of-three---minus-one-188p)

许多人知道杰夫·阿特伍德，有些人知道他的三原则。是啊！另一条黄金法则，你需要在你的编码冒险中记住。

女士们先生们，这是三条规则

# 单元测试

现在，我们已经奠定了基础，让我们考虑谁可能是第一批观众。通过单元测试我们的 API 来成为我们自己的观众怎么样？

我听你说，这不是由本书单元测试，我同意。根据定义，单元测试应该测试源代码的单个单元。这些通常被理解为函数或类方法。然而，没有什么可以阻挡我们制作更大的代码片段，在现实生活中使用我们的 API，并将其集成到我们的构建验收测试套件中。

# 案例分析

最近，我有机会为我正在开发的框架编写一个事件管理器。这项任务要求我开发多个接口:生产者、消费者、事件管理器、事件消息。

## 设计

我“在纸上”设计了一切，写了代码，编译了程序，对部分完成的工作感到满意。我正在做的项目要求只用单元测试来推送代码。所以我开始写我的测试套件。这就是我被我的“设计决策”或缺乏它们所打击的地方。

## 问题

我开发的单元测试是测试一些基本的真实流程:向事件管理器添加生产者，添加消费者，添加消息，引发事件等。因为设计主要集中在接口上，并且实现是在抽象类中完成的，所以我需要实现从生产者、消费者和消息类派生的类。我的虚拟类(DummyProducer、DummyConsumer 等)就是这样。)被创造出来。结果是我没有考虑对象的生命周期和所有权，这在 C++中不是一个小问题。我使用引用将一个生产者传递给事件管理器，但结果完全失败了。经过一些重构，我转向了共享指针——我认为这是一个好的解决方案(目前来说)——因为它在异步事件处理中更安全。
接下来，消息。当然，我可以传递消息，但是它的有效载荷呢？谁应该控制有效载荷的寿命？结果是我需要创建一个代理类，它存储有效载荷(每个事件可能不同)并将其传递给事件承载类。
以上例子是我在设计中发现的一些更重要的问题，还有更多小细节我需要润色。

# 结论

我正在为框架项目开发一个嵌入式系统，花了一些时间来设置单元测试环境。除此之外，我的测试套件看起来更像是一个示例应用程序，而不是标准的单元测试。像这样过度复杂的测试值得吗？我会答应的！它让我站在 API 用户的角度看待问题。我肯定会再做一次！