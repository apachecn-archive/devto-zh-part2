# 微服务通信。为什么应该切换到消息队列。

> 原文:[https://dev . to/matteojoliveau/micro services-communication s-why-you-should-switch-to-message-queues-48ia](https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia)

*这实际上是我写的一个旧评论的更详细的版本[这里](https://dev.to/matteojoliveau/comment/1bk1)T3】*

做微服务的时候，一个相当关键的设计点是:我的服务之间应该如何通信？许多人通常选择设计一些 RESTful HTTP API，让每个服务公开，然后让其他服务通过普通的 HTTP 客户端调用它。
这有一些优点，主要是通过使用 DNS 解析和 API 网关使发现服务变得容易，但是它也有许多缺点。
例如，如果被调用的服务崩溃了，无法响应怎么办？您的客户端服务必须实现某种重新连接或故障转移逻辑，否则，您将面临丢失请求和信息的风险。云架构应该具有弹性，能够从容地从故障中恢复。此外，HTTP 请求是一个阻塞 API，使其异步意味着客户端的一些棘手的诡计。

## [](#entering-message-queues)进入消息队列

在处理多个相互通信的服务时，使用消息队列实际上是一个相当老的解决方案。想想旧的方法，如企业服务总线或 Java JMS 规范。

让我们先介绍一些术语:

*   *消息*:信息包，通常由两部分组成。一些**头**，包含元数据的键值对，以及一个**体**，包含实际消息本身的二进制包。
*   制作人:创建和发送消息的人
*   *消费者*:接收和阅读信息的人
*   *Queue* :将消息排队以供一个或多个消费者稍后检索的通信通道
*   *Exchange* :一个队列聚合器，它抽象出消息队列，并根据一些预定义的逻辑将消息路由到适当的队列。

消息队列架构需要一个叫做*消息代理*的额外服务，它的任务是收集、路由和分发来自发送者的消息到正确的接收者。

把它想象成邮件服务。您(生产者)正在向某人(消费者)发送一封信(您的消息)，您通过指定地址(消息的路由逻辑，如发布消息的主题)并将信交给本地邮局(消息代理)来完成此操作。在你把信送出去之后，你就不再需要确保它真的到达你的朋友手中了。邮局会处理的。

在微服务环境中，它实际上是一个非常可靠的解决方案，因为它在松散耦合的服务之间添加了一个抽象层(消息代理本身),并允许完全异步的通信。

## [](#errors-will-occur-lets-deal-with-them-instead-of-simply-avoiding-them)会出现错误。让我们应对它们，而不是简单地回避它们

请记住，云环境应该具有容错能力，服务必须优雅地失败，并且在其中一个服务失败时不会关闭整个应用程序。使用消息队列，如果一个微服务意外死亡，代理仍然可以接收传入的消息，存储它们以备后用(以便死亡的服务可以在重新联机时恢复它们),并可选地向另一个服务发回一条*最后遗嘱和遗嘱*消息，说明接收者已经死亡。此外，*推/拉*、*发布/订阅*和*主题*队列机制在设计服务间通信时提供了更大的灵活性和效率，发送二进制有效载荷的能力允许轻松使用像 [Google ProtoBuff](https://github.com/google/protobuf) 或 [MessagePack](https://msgpack.org/) 这样的格式来代替 JSON，这在带宽使用方面更有效。

## [](#security-is-key)安全是关键

像 [RabbitMQ](https://www.rabbitmq.com/) 这样的高级代理服务器支持多种消息协议(AMQP、MQTT、STOMP...)，拥有[灵活的授权机制](https://www.rabbitmq.com/access-control.html)(访问控制、虚拟主机甚至第三方/自定义授权服务，通过许多不同的传输方式，如 [HTTP](https://github.com/rabbitmq/rabbitmq-auth-backend-http) 或 [AMQP](https://github.com/rabbitmq/rabbitmq-auth-backend-amqp) )，并将基本上消除您的服务协调授权请求的负担。将一个定制的微服务插入 Rabbit 的 auth 后端，并在那里编写您的策略。剩下的就交给经纪人了。

## [](#infrastructure-at-scale)大规模基础建设

在 Rabbit 这样的代理中使用消息队列对可伸缩性也有很大帮助，这是微服务的另一个重要方面。如果其中一项服务不堪重负，我们希望能够快速启动更多实例，而无需重新配置。使用 HTTP 作为我们的通信方法，我们通常会有一个自注册的**服务发现服务器**(像[网飞尤里卡](https://github.com/Netflix/eureka)或一个容器编排系统，像 [Kubernetes](https://kubernetes.io/) 或 [Rancher](http://rancher.com/) )和某种与之集成的负载平衡器，以便我们的流量被分配和路由到各个实例。对于消息队列，我们的代理是负载平衡器。如果多个用户同时收听一个话题，消息将按照配置的策略发送(更多关于 RabbitMQ 的 QoS [在这里](https://insidethecpu.com/2014/11/11/rabbitmq-qos-vs-competing-consumers/))。

例如，我们可以有四个服务实例以循环方式处理消息，但由于 QoS 参数在运行时是可定制的，因此如果其中一个消费者花费太长时间来完成其工作，我们也可以切换到[公平调度策略](https://www.rabbitmq.com/tutorials/tutorial-two-java.html)，我们需要平衡负载。另外，请注意，客户端配置完全是在运行时完成的(顺便说一下，交换、队列和主题声明也是如此)，因此不需要修改代理的配置或重新启动任何东西。

## [](#async-efficiency)异步==效率

我们在开始时说过，与 HTTP 请求相比，消息的一个关键特性是它们允许完全异步的通信。如果我需要向另一个服务发出请求，我可以就其主题发送一条消息，然后继续我的工作。我可以在我自己的话题上处理回复，而不必等待。[关联 id](http://www.enterpriseintegrationpatterns.com/patterns/messaging/CorrelationIdentifier.html)用于跟踪哪个响应消息引用哪个请求。这与我们所说的弹性是一致的。
在一个 HTTP 场景中，如果我发出一个请求，而被调用方停机，连接将被拒绝，我将不得不一次又一次地尝试，直到它恢复。有了信息系统，我可以发送我的请求，然后忘记它。如果被调用者不能收到它，代理将把消息保存在队列中，然后在消费者连接回来时传递它。我的反应将会回来，当它可以的时候，我不需要阻止或者等待它。

## [](#in-conclusion-messages-are-great-show-them-some-love)总之，消息很棒。给他们一些爱

这绝不是对 HTTP(它仍然很棒，特别是对于面向公众 API 来说)的咆哮，而是试图引导您走向一种更有效和熟练的策略来协调微服务通信，所有这些都可以通过开源软件、开放协议(如 AMQP)来实现，以防止供应商锁定，并具有低(和可扩展的)基础设施成本(参见 [RabbitMQ 的需求](https://www.rabbitmq.com/production-checklist.html))。

我在所有的微服务项目中都使用了 RabbitMQ，这是一次很棒的体验。请在评论中告诉我你的想法！您以前使用过消息队列吗？你对它有什么体验？