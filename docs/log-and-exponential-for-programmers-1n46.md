# 程序员用对数和指数

> 原文：<https://dev.to/pancy/log-and-exponential-for-programmers-1n46>

当你听到对数和指数算法时，你会退缩吗？好消息是，你不需要成为一个微积分专家来理解它们。

这是对你的一个小测试:

1.  如果一个算法的运行时间为 O(log n ),并且在您的计算机上从 10 个数据点获得结果需要一秒钟，那么在同一台计算机上从 1，000，000 个数据点获得结果大约需要多长时间？

2.  这次另一个算法据说运行时间为 O(2 <sup>n</sup> )(指数时间)，从 10 个数据点计算出一个结果需要一秒钟。从 20 个数据点做同样的事情大约需要多长时间？

这两个问题有点关联。第一个处理 log <sub>2</sub> (在 Big-O 符号中，O(log n)是 log <sub>2</sub> 的简写)另一个处理 2 <sup>n</sup> 。它们是同一枚硬币的两面。

2 <sup>n</sup> = P 和 log <sub>2</sub> P = n 是一样的，只是从两个不同的角度来看而已。理解这种区别的最好方法是演示我们是如何得到前两个问题的答案的。

### 问题 1

如果说一个算法的运行时间是 O(log n)，从 10 个数据点得到结果需要一秒，那么从 1，000，000 个数据点得到结果需要多长时间？

log <sub>2</sub> 10 = 3.3
(因为 2 <sup>3.3</sup> = 10)

log <sub>2</sub> 1000000 = 19.9
(因为 2 <sup>19.9</sup> = 1000000)

比例因子= 19.9 / 3.3 = 6.03

如果代码在 10 个数据点
上运行需要 1 秒，那么在 1，000，000 个数据点上运行需要 **6.03 秒。**

1，000，000，000，000 个数据点呢？

log <sub>2</sub> 1000000000000 = 39.9

处理一万亿个数据点需要 **39.9 秒。**

39.9 秒仅仅是代码处理 10 个数据点所用时间的 40 倍，但是它现在正在处理一万亿个数据点！。与数据量相比，CPU 时间的增长速度非常缓慢。这使得对数算法具有很强的可扩展性。

### 问题 2

如果说另一个算法的运行时间是 O(2 <sup>n</sup> ，从 10 个数据点计算出一个结果需要一秒钟。从 20 个数据点做同样的事情需要多长时间？

密切注意。这是前一个日志版本的“逆版本”。

2<sup>10</sup>= 1024
2<sup>20</sup>= 1048576

scale_factor = 1048576 / 1024 = 1024

如果代码需要 1 秒来处理 10 个数据点，
那么将需要**1024 秒来处理 20 个数据点**。

30 个数据点呢？

2<sup>30</sup>= 1073741824
scale _ factor = 1073741824/1024 = 1048576

处理 30 个数据点需要 **1，048，576 秒。**

考虑到数据点的数量仅增加了 3 倍，这是一个很大的数字！这是因为我们处于 2 的指数端。无论如何都要避免指数运行时间。

有趣的事情:试着计算 100 个数据点需要多长时间。

## 外卖

即使运行低效算法的超级计算机也无法打败运行在普通笔记本电脑上的高效、可扩展算法。