# 用 crystal-db 和 Lucky 将数据库查询映射到 Crystal 类

> 原文：<https://dev.to/mikeeus/mapping-database-queries-to-crystal-classes-with-crystal-db-and-lucky-460i>

有时我们需要从数据库中获取几列，或者进行复杂的查询并返回许多不适合我们模型的列。在这些情况下，我们希望我们使用的框架足够灵活，以允许这样的查询，并使其易于在我们的应用程序中使用结果。克里斯托和拉基让我们做到了这一点。

在这篇文章中，我们将看看如何使用 [crystal-db 的](http://crystal-lang.github.io/crystal-db/api/0.4.3/DB.html) [DB.mapping](https://github.com/crystal-lang/crystal-db/blob/master/src/db/mapping.cr) 宏来将数据库查询映射到一般的 crystal 类。然后我们将快速查看 Lucky 如何在内部使用`DB.mapping`。

在本文中，我们将使用 Lucky 进行数据库查询，但是请记住， [crystal-db](http://crystal-lang.github.io/crystal-db/api/0.4.3/DB.html) 可以单独使用，也可以与任何框架一起使用。

## 设置

如果你想亲自测试，你可以使用我的演示应用程序，只需克隆回购并检查`db-mapping-0`以跟进，或`db-mapping-1-complete`以查看完成的代码。

```
git clone git@github.com:mikeeus/lucky_api_demo.git
cd lucky_api_demo
bin/setup
git checkout db-mapping-0 
```

Enter fullscreen mode Exit fullscreen mode

## 查询

对于这个例子，我们将映射这个相当简单的查询，它获取帖子，在`user_id`上加入用户，并将用户名和电子邮件作为 JSON 对象返回。由于 Lucky 使用了 [crystal-pg](https://github.com/will/crystal-pg) Postgresql 驱动程序，我们可以使用`DB.mapping`轻松地将查询中的 json 对象解析成`JSON::Any`。

```
SELECT
  posts.id,
  posts.title,
  ('PREFIX: ' || posts.content) as custom_key, -- custom key for fun
  json_build_object(
    'name', users.name,
    'email', users.email
  ) as author
FROM posts
JOIN users
ON users.id = posts.user_id; 
```

Enter fullscreen mode Exit fullscreen mode

## 上课

`crystal-db`将查询结果作为`DB::ResultSet`返回，这对我们没有直接用处。因此，让我们创建结果将被映射到的类，我们可以使用[数据库映射](https://github.com/crystal-lang/crystal-db/blob/master/src/db/mapping.cr)来处理脏工作。

```
class CustomPost
  DB.mapping({
    id: Int32,
    title: String,
    content: {
        type: String,
        nilable: false,
        key: "custom_key"
    },
    author: JSON::Any
  })
end 
```

Enter fullscreen mode Exit fullscreen mode

本质上，`mapping`宏将创建一个接受`DB::ResultSet`并为我们初始化这个类的构造函数，以及一个初始化多个结果的`from_rs`类方法。它会扩展成这样。

```
class CustomPost
  def initialize(%rs : ::DB::ResultSet)
    # ...lots of stuff here
  end

  def self.from_rs(rs : ::DB::ResultSet)
    objs = Array(self).new
    rs.each do
      objs << self.new(rs)
    end
    objs
  ensure
    rs.close
  end
end 
```

Enter fullscreen mode Exit fullscreen mode

## 把一切都勾起来

现在让我们写一个规范来确保一切都按计划进行。

```
# spec/mapping_spec.cr
require "./spec_helper"

describe App do
  describe "CustomPost" do
    it "maps query to class" do
      user = UserBox.new.name("Mikias").create
      post = PostBox.new
                    .user_id(user.id)
                    .title("DB mapping")
                    .content("Post content")
                    .create

      sql = <<-SQL SELECT
          posts.id,
          posts.title,
          ('PREFIX: ' || posts.content) as custom_key,
          json_build_object(
            'name', users.name,
            'email', users.email
          ) as author
        FROM posts
        JOIN users
        ON users.id = posts.user_id; SQL

      posts = LuckyRecord::Repo.run do |db|
        db.query_all sql, as: CustomPost
      end

      posts.size.should eq 1
      posts.first.title.should eq post.title
      posts.first.content.should eq "PREFIX: " + post.content
      posts.first.author["name"].should eq user.name
    end
  end
end

class CustomPost
  DB.mapping({
    id: Int32,
    title: String,
    content: {
        type: String,
        nilable: false,
        key: "custom_key"
    },
    author: JSON::Any
  })
end 
```

Enter fullscreen mode Exit fullscreen mode

我们可以用`lucky spec spec/mapping_spec`和运行测试...绿色！很好。

## 幸运车型

这实际上非常类似于 [LuckyRecord 如何建立它的数据库映射](https://github.com/luckyframework/lucky_record/blob/189dd6418c3bd6375157ed585e0c099920f3975e/src/lucky_record/model.cr#L87-L101)。例如，如果你有一个这样的用户模型。

```
class User < BaseModel
  table :users do
    column name : String
    column email : String
    column encrypted_password : String
  end
end 
```

Enter fullscreen mode Exit fullscreen mode

对`column`方法的调用会将每一列的名称和类型添加到一个`FIELDS`常量中。

```
macro column(type_declaration, autogenerated = false)
  ... # check type_declaration's data_type and if it is nilable
  {% FIELDS << {name: type_declaration.var, type: data_type, nilable: nilable.id, autogenerated: autogenerated} %}
end 
```

Enter fullscreen mode Exit fullscreen mode

`table`宏将建立模型，包括调用`setup_db_mapping`宏，该宏将通过迭代`FIELDS`来调用`DB::mapping`。

```
macro setup_db_mapping
  DB.mapping({
    {% for field in FIELDS %}
      {{field[:name]}}: {
        {% if field[:type] == Float64.id %}
          type: PG::Numeric,
          convertor: Float64Convertor,
        {% else %}
          type: {{field[:type]}}::Lucky::ColumnType,
        {% end %}
        nilable: {{field[:nilable]}},
      },
    {% end %}
  })
end 
```

Enter fullscreen mode Exit fullscreen mode

就像你的每个幸运模型现在都可以从`DB::ResultSet`实例化，并有一个可以被你的查询调用的`from_rs`方法。很简单，对吧？

## 加入我们

我希望你喜欢这个教程，并发现它很有用。加入我们的 [Lucky gitter 频道](https://gitter.im/luckyframework/Lobby)了解框架的最新进展，或者[查看文档](https://luckyframework.org/guides)了解如何通过 Lucky 将您的应用理念付诸实践的更多信息。