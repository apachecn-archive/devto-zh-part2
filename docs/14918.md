# 兰花，黄蜂和测试夹具

> 原文:[https://dev . to/DM fay/the-orchid-the-wasp-and-the-test-fixture-4f 50](https://dev.to/dmfay/the-orchid-the-wasp-and-the-test-fixture-4f50)

我写了很多操作数据的集成测试。通常的格式是一个 setup 函数，它使数据库进入特定的状态，一个或多个测试，它验证适当的应用程序功能，然后是一个 teardown 函数，它清除所有东西，以便下一个测试套件可以做它的事情。有不同的名字和一些小的复杂性(例如，Mocha 和 AVA 提供了一个`before`和一个`beforeEach`)，但是一般来说，在我编写测试的每一种语言/框架中都是这样做的。这与其说是有意识架构的产物，不如说是测试过程的自然进化；还没有人真正确定测试数据管理的正式模型。

最终的结果是，这些设置功能，或*夹具*，往往是临时开发的，并且不一致。不难发现，两个测试套件采用完全不同的方法来生成几乎相同的数据。当事情发生变化，你的一堆测试变得过时时，情况会变得更糟，直到一份错误报告落到你的膝盖上，你才知道。我写了很多这样的固定装置，我想停下来。

不一致的唯一解决方案是集中化:需要有单一的数据源。如果有一个地方可以找到夹具数据，那么这对于确保测试保持最新大有帮助。然而，仅仅把所有的设备放在一个屋檐下是不够的。如果一些测试执行外卖订单，而其他测试执行送货订单，那么数据库状态可能有 75%是相同的——但是一个测试附加了电话号码和取货时间，另一个测试附加了地址和司机。单靠一个夹具是不行的，打破它是回到原来的问题。集中化只是解决方案的一部分；固定装置也必须灵活。

## 与此同时，在澳大利亚西南部

锤兰有非常特殊的繁殖机制。Drakaea 属中的每一个物种都模仿共生黄蜂雌性的气味(更不用说颜色和形状了)。这种气味吸引了雄性黄蜂，它们试图与兰花交配，结果却被兰花的花粉所覆盖。最终它们放弃了，飞走了。足够多的兰花再次落入相同的圈套，将花粉摩擦到新的花朵上，以确保兰花的存活；而且，据推测，他们中有足够多的人找到了真正的伴侣，以确保自己种族的生存。

当然，要说兰花捉弄黄蜂，是明目张胆的拟人化。兰花可能是进化建筑的奇迹，但它不会思考，也不会计划。它只是简单地遵循一个程序，这个程序要求它在某种意义上——字面上的意思——成为一只黄蜂。没有成为黄蜂的兰花不会繁殖。黄蜂也是一种兰花，它将花粉沉积在另一种花的柱头上。

后结构主义者 Gilles Deleuze 和 Felix Guattari 用兰花和黄蜂来举例说明他们所谓的根茎。根茎是一种组织模型，一种思考结构和过程的方式，以及过程的结构*，它与更熟悉的层级或树状模型相对应。公司是自上而下流动的权力层级；与此同时，工会可能有官员和官僚机构，但这些地方层级并不能定义整个组织。工会中的权力流向很多方向。根茎模型有很多令人喜欢的地方，但是它的一个主要属性正是我们正在寻找的:灵活性。*

德勒兹和瓜塔里确定了 *1000 年高原*根茎的六个特征。前两个和后两个各有密切联系，一起考虑。

## 联系和异质性

根茎是一群或一簇不同的(异质的)事物，它们可以并且已经无层次地连接在一起。这描述了很多技术上的东西，尤其是分布式系统！如果你正在考虑无服务器应用，Cassandra，或者 Kubernetes 集群:这就是我们要做的。

我们的数据在原子级别上由不同表中的记录组成。如果我们考虑一个“初始化器”函数，它生成这些记录中的一个作为根茎的元素，我们可以组合多个初始化器来生成我们需要测试的任何数据状态。

初始化式看起来像这样:

```
async (db, data) => {
  return db.drivers.insert({name: 'Taylor', license: 'abc123'});
}; 
```

Enter fullscreen mode Exit fullscreen mode

其他初始化器可能包括`franchises`表、`destinations`表和`orders`表。每个都尽可能简单，只生成一种类型的记录。创建多种类型记录的初始化器是对我们试图避免的复杂装置的一种倒退。

总有一些测试需要对数据做一些特定的事情。司机没有驾照会怎么样？如果泰勒总是有一个，我们就不能行使那个代码。我们有几个选择:

*   更新 Taylor 的记录，在“无证驾驶被开罚单”测试开始时取消她的驾照
*   创建第二个`driver-without-license`初始化器，为泰勒不幸的同胞泰勒生成一条记录，没有许可证
*   在单个`driver`初始化器中为有许可证的 Taylor 和没有许可证的 Tyler 生成记录

这里没有一成不变的答案；最佳解决方案视情况而定。在这里，如果只有一个测试依赖于无照驾驶，我会选择选项 a。如果有几个，可能是时候考虑其他的了。

## 多重性

根茎必须被认为是组成它的离散元素，以及这些元素如何与其他系统的元素相互作用。锤兰的繁殖由花和黄蜂组成，花和黄蜂都与外界事物相互作用。德勒兹和瓜塔里提供了一个更直接的例子:一个木偶的线，被认为是多重性的，不是与木偶操纵者的意志相连，而是与另一种多重性的神经相连。木偶师的神经系统变成木偶，就像锤兰变成黄蜂一样。

从多重性的角度考虑，会颠倒如何设置夹具数据的问题。这不再是关于这个或那个测试的状态，而是关于描述和构建任何数据状态的能力。每个测试套件选择它需要的初始化函数，并从它们构建一个根茎。调用的顺序对本地层次结构很重要；例如，没有司机，我们无法创建交货订单。

我有一个`ContextFactory`，可以将初始化函数的名字传递给它。该工厂返回一个新的函数，当执行该函数时，它按顺序运行初始化器并收集每个初始化器生成的记录，将当前状态或上下文传递给每个后续的初始化器，以便局部层次结构中的元素可以正确地创建它们的关系。每个测试套件的`before`函数在全局范围内创建一个新的`ContextFactory`:

```
contextFactory = await ContextFactory(
  'franchise',
  'driver',
  'destination',
  'delivery-order'
); 
```

Enter fullscreen mode Exit fullscreen mode

该示例包含两个本地层次结构:特许司机订单和目的地订单。对排序的唯一约束是不能在它的依赖项之前出现任何内容；例如，我们可以先创建`destination`，但`delivery-order`必须在最后创建。

## 放大破裂

我有没有提到后结构主义因为晦涩难懂的术语而备受指责？平心而论，很难建立一个词汇来谈论像它这样抽象的东西，但它的名声在一定程度上还是当之无愧的。如果根茎的一个组成部分损坏了，可以把这想象成一种“自愈”能力。如果一只黄蜂没能开出第二朵花，那也没什么区别；还有其他的黄蜂和其他的花。政治根茎尤其有办法在严酷的压制下重现，就像假俭草一样。

对于分布式架构和并发处理来说，这是一个有用的属性:如果 Spark 作业因为某个执行器离线而导致结果不完整，那么集群管理器可以调度其他执行器来覆盖丢失的数据。但是对于我们的目的来说，崩溃意味着不一致，所以这是我们的出发点——我们最好抛出一个异常并中止。

## 制图学和贴花纸

根茎是“一张地图，而不是一个痕迹”。后者创造了一个不变的静物图像，地图可以被解释、询问，最重要的是，可以被修改。地图一直在变化，因为它们所代表的东西永远在变化。领土宣布独立，被承认或不被承认，被吞并；边界在改变，联系在建立和打破，文化和语言在潮起潮落。地图不仅仅展示这些信息:它们还传递这些信息(“贴花”是一个复制图像的过程，也是更常见和微妙不同的单词“贴花”的起源)。边界定义了人们所理解的领土界限；地图上的一条路线变成了司机头脑中的一条路线。

当调用`ContextFactory`时，它返回一个对象，将初始化器映射到每个初始化器创建的数据。

```
ctx = contextFactory();

assert.equal(ctx.driver.name, 'Taylor'); 
```

Enter fullscreen mode Exit fullscreen mode

整体夹具是一种跟踪:它冻结了数据模型在某个时间点出现时的快照。相比之下，初始化器一点一点地映射出应用程序的数据模型，每一部分都增加了更多的定义。如果组成一个驱动的信息改变了——增加了一个姓或者他们是否在轮班——这些信息就会被添加到初始化器中。每次测试都会自动更新。如果一个坏了，那是好事！这意味着正在运行的代码无法正确处理新信息，需要在我们发布之前修复。

## 结束

根茎模型使得测试夹具具有无限的灵活性。整体式夹具增加了复杂性，并在几乎没有警告的情况下过时，而一组统一的、可组合的离散夹具使数据生成集中，并确保行使相关功能的测试使用一致和最新的数据集。

* PHP 的[教条](https://www.laraveldoctrine.org/docs/1.3/orm/testing) O/RM 提供了一个加载和执行分散的集中式测试装置的框架，如果你是那种在继续之前跳过阅读脚注的人，那么这是我在我将要介绍的内容中看到的唯一例子。反正 PHP 得一分！