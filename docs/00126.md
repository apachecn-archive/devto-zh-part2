# C++中的协同程序

> 原文:[https://dev.to/dwd/coroutines-in-c-2i5b](https://dev.to/dwd/coroutines-in-c-2i5b)

# 什么是协程？

在一个典型的函数调用中——被称为子例程——你从顶部进入，一旦子例程完成就退出。可能有多条路径，但是呼叫者认为它是一个单独的步骤。

协程允许该路径在不同的点暂停，并将控制权多次交还给调用者，或者移交给另一个协程。调用者很可能在调用过程中看到多个步骤，或者可能故意选择暂停并等待结果。

# 协程的类型

使用协程可以做的事情有很多种。Python 的生成器可以说是这个概念的第一次流行使用(尽管协程的最初概念可以追溯到 1956 年，生成器本身出现在 70 年代的语言中)。

在异步代码中，一个异步函数可以“等待”另一个函数的结果，由于 Python 和 Javascript，异步代码也同样变得流行起来——在这里，调用者挂起，直到被调用的协程能够返回值(即使它也挂起)。

# 操作多态性

面向对象编程(OOP)涵盖了非常广泛的概念，但最容易被误解的是多态性。多态仅仅意味着两个或更多不同的对象类型可以处理相同的操作(或者，用更严格的 OOP 术语来说，处理相同的消息)。

大多数想到 OOP 的人会想到包容多态——或者类的继承。但是大多数现代语言允许其他形式的多态性。C++的模板(在某种程度上，Java 的泛型)是参数多态性的一个例子，但是很多惯用的 C++依赖于一种更简单的形式，其中严格类型对于期望的操作来说是次要的。

这就是所谓的操作多态性、行多态性或简单的鸭子类型。

C++03 中惯用的 foreach 循环就是一个例子:

```
 for (iterator i = container.begin(); i != container.end(); ++i) {
  // Do something with (*i).
} 
```

到了 C++14，这已经成为如此具体的习语，以至于它获得了一个句法简写:

```
 for (auto & a : container) {
  // Do something with a.
} 
```

但是 foreach 循环不需要特定的容器超类型——它可以操作任何同时公开 begin()和 end()方法的东西。如果它看起来像容器类型，走起来也像容器类型，那么它*就是*容器类型。

# C++协程

C++中的协同程序 TS 也是如此。协程本质上是一个包含至少一个协程关键字的函数，具有提供正确方法的特殊返回类型。返回类型不需要继承任何东西。

主要接口是函数的返回类型必须有一个嵌套类型`promise_type`。反过来，它必须支持一个依赖于所用关键字的界面。

可选的——但也是明智的——是为返回类型本身创建一个接受协程句柄的构造函数(特别是，`std::experimental::coroutine_handle<promise_type>`)。这是一个库提供的句柄，包括一些实用方法，如`resume()`、`promise()`和`done()`。

在每个“暂停点”对承诺调用不同的方法——开始、结束、使用协程关键字的任何时候，等等。

这些关键字是:

`co_return` -这将暂停执行并调用`promise_type::return_value(T t)`，其中 T 是与您试图返回的内容兼容的某种类型。最简单地说，使用`co_return`而不是简单的`return`的协程不是很有用——但是你可以在`promise_type::initial_suspend()`中的协程开始做任何工作之前暂停它，给你一个懒惰的——实际上是有条件的——执行。

`co_yield` -这和`co_return`类似，除了你可以有很多，它们调用`promise_type::yield_value(T t)`，恢复后协程可以继续执行。有了这个，你就可以构建生成器——如果你的返回类型支持`begin()`和`end()`，你就可以用普通的惯用 C++进行迭代。

这是一个操作符，如果在具有正确接口或 co_await 操作符重载的对象上调用，它允许调用方和被调用的协程都挂起。界面稍微复杂一点。

# 结论

协程已经成为现代编程中相当成熟的一部分，非常值得探索。C++的方法不同于其他主流语言，因为它允许一个非常灵活的系统——你可以用它来构建各种各样的高级原语。

虽然这可能看起来令人生畏，但请记住，这与 C++用于容器的方法是一样的，这导致了一套强大的算法和容器类型，程序员可以无限制地添加它们。

# 更多信息

关于原语如何工作的最佳教程是 Kirit slensminde 的优秀教程:[c++协程如何工作](https://kirit.com/How%20C%2B%2B%20coroutines%20work) -但它们的本质是你可能会随便找一个给你更高级别的库，比如 [Conduit](https://github.com/loopperfect/conduit) ，或者 [CppCoro](https://github.com/lewissbaker/cppcoro) 。

你需要一个支持它们的编译器——这仍然是一个 ts，所以我们还在实验阶段——但是 modern CLang 可以让你玩(注意，你还需要 libc++和 libc++abi)。

玩得开心！