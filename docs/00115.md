# 技术洞察:解耦(或学会忍受代码冗余)

> 原文:[https://dev . to/lgelfan/tech-insights-decoupling-or-learning-to-live-with-code-redundancy-4j 58](https://dev.to/lgelfan/tech-insights-decoupling-or-learning-to-live-with-code-redundancy-4j58)

[![decoupling](../Images/5dce2bcb0311326436a867dba72777b5.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--yxuZLXV_--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/4b0tkoslgmcjyk61lov3.jpg)

我明白了——你之前在最近开发的一个软件应用程序中找到了一个聪明的解决方案，现在你发现你在一个不同的应用程序中完美地使用了它。太棒了。因此，您建立了一些系统来共享这些伟大的代码——Git 子树、花哨的 shell 脚本、重用这些代码所需的任何东西、保持同步并保持整洁。很好，对吧？

也许没有那么多。虽然您可能认为重用代码更有效，但现在您已经将应用程序紧密耦合，使它们相互依赖。如果该代码具有一些领域逻辑或数据模式意识，您可能会遇到无法独立完成部署这些应用而没有风险的情况(“独立可部署性”是微服务的主要优势)。你也许可以添加一些条件，以确保它在应用 B 中以一种方式工作，而在应用 A 中以另一种方式工作——但是你可以看到这是怎么回事，这并不漂亮。复制粘贴会是一个更好的选择。

## [](#shared-library%C2%A0approach)共享库方法

“好吧，好吧，好吧，我会把代码分成一个单独的库，每个应用程序都可以使用，”你想。这个好一点，但也有它的问题。代码经常坚持其最初的目的，只有通过几次复制粘贴到不同的应用程序中，你才能真正隔离共享的功能，并看到实际使用行为中的共性。而且您仍然冒着包含多余代码和花费时间创建抽象层的风险。

像这样开发的库很少能被用作黑盒，所以你需要确保你有适当的文档、有用的注释和易于理解的代码。如果只有你或一个小团队，这在一开始似乎是可以管理的。然而，你在做假设，无论谁来维护和更新这段代码，他都会理解它在你的世界中作为一个共享库的目的，而不是简单地为他们当时正在开发的应用程序添加一些功能，而没有完全意识到它可能在其他地方产生的副作用。所以现在你需要添加更多的测试，包括共享库和消费者应用，以确保任何更新都不会破坏任何东西。

一旦你完成了所有的排序，每个应用程序现在可以选择何时升级——假设你遵循严格的 semver 实践(你是这样做的，不是吗？).即使你这样做了，你的库也可能有它自己的依赖项，所以你需要确保使用它的任何服务也满足这些依赖项，这可能会降低消费者应用程序的发展能力。(上帝禁止这些依赖中的一个是另一个内部共享库。)

这并不是说你不应该使用任何共享库——成熟的开源组件是现代软件开发的主要部分。这也不意味着你不能使用属于纯实用分类的内部库:那些不是特定于应用程序的，没有自己的依赖关系的库。其中更新可能是附加的并且是向后兼容的。(这也不意味着你不应该包含 UI 库，从设计上来说，这些库是为了确保表示层的一致性。)

* * *

> 代码复制确实有一些明显的缺点。但是我认为这些缺点比使用最终耦合服务的共享代码的缺点要好。如果使用共享库，请小心监控它们的使用，如果您不确定它们是否是一个好主意，我强烈建议您倾向于服务之间的代码复制。——《构建微服务》(O'Reilly，2015)的作者萨姆·纽曼(Sam Newman)。

* * *

## [](#reuse-as-an-antipattern)重用为反模式

我意识到，在使用 mono-repos 等工具时，有各种工具可以处理共享代码的依赖管理。但最终我建议的是，这变成了一种反模式，阻止您看到更优雅的方法来解决问题，并创建了一个脆弱的整体式结构，很难可靠地部署。

通常，通过后退一步，将生态系统作为一个整体进行评估，您可以更好地确定为什么最终在不同的地方需要相同的代码，而不是设计消除对共享库的需要的服务。弄清楚每个服务如何以更具体的方式完成它的工作。这可能意味着不同的数据模式，甚至(是的)非规范化。您可能会发现您的应用程序是基于一种过时的服务切片观点。不可否认，创建更多服务会导致不同类型的复杂性和更多需要管理的东西，因此确实需要对微服务理念及其优势有一定程度的认同。

## [](#dont-share-domain-models)不共享域模型

需要了解其他服务的实现细节或领域逻辑的服务导致它们被同步开发，这可能是共享代码似乎有意义的原因。创建独立于彼此内部工作的自治服务将使它们更有弹性，并允许更有机的增长。

我最近在我们的一个应用中遇到的一个例子是，一个特定的功能有一个条件，其中包括特定的用户类型，以确定谁应该被允许使用某个过滤器。我们的授权服务中也使用了类似的功能——因此，一种方法是使用一个共享的实用程序来确保功能在使用该过滤器的任何应用程序中都是一致的。然而，这意味着认证服务模式(用户类型)需要在多个服务之间保持同步。

我们通过确保 filter 属性仅在适用时才被提供来解决这个问题。这消除了在下游应用程序中拥有授权细节的需要，并简化了逻辑。请求更纯粹是数据驱动的，决策是二进制的。当我们添加新的用户类型时，我们只需要更新一个服务。

## [](#embrace-redundancy-within-reason)拥抱冗余*(情理之中)*

我参与过各种软件项目，这些项目实际上是单块的，也包括最终成为分布式单块的微服务架构，我可以说我坚定地站在微服务做对的阵营中。什么是“正确”的定义当然取决于具体情况，但是最终您希望团队能够独立地工作和部署应用程序——即使这意味着一些冗余。