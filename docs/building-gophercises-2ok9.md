# 建造 Gophercises

> 原文：<https://dev.to/joncalhoun/building-gophercises-2ok9>

> *这篇文章最初发布在我的网站 [calhoun.io](https://www.calhoun.io/building-gophercises/) 上，基于我在 2018 年 [Gotham Go](http://gothamgo.com/) 大会上的一次演讲。它不会与演讲完全相同，但应该涵盖相同的主题并传达相同的信息。*
> 
> 本次演讲的幻灯片可以在这里找到[。](https://www.calhoun.io/gothamgo2018.pdf)

## 什么是 Gophercises？

Gophercises 是我创建的一个免费课程，由迷你练习组成，帮助初学的 Gophers (Go 开发者)练习编写 Go 代码，并熟悉该语言的不同方面。我坚信成为一名伟大的开发人员的唯一方法就是编写大量的程序。是的，成为一名优秀的开发人员还涉及到其他因素，但是如果你不能编写代码来挽救你的生命，如果你对你正在使用的语言的一些简单方面感到困惑，它们将永远限制你的能力。Gophercises 旨在通过实践帮助提升上限。

## 这篇文章不是关于 Gophercises 课程的

虽然我喜欢这门课程，可以整天谈论它，但这不是这篇文章或最初演讲的重点。相反，我想谈谈我们是如何让软件变得过于复杂的，这让我们感到沮丧，我打算用网站 powering Gophercises 作为一个反例，说明我们如何能够编写更简单的软件，但仍然为用户提供巨大的价值。

## 我们让软件变得太复杂

想想上次有人问“我应该如何设计我的 xxx”，其中`xxx`是任何基本的 web 应用程序。你很可能会看到这样的回答:

*   "*你应该使用 JSON API 和微服务设计，这样就可以很好地扩展，每个微服务都可以独立开发。*
*   "*查看 Docker 和 Kubernetes，了解您的部署。它们允许轻松扩展、多区域部署等。*
*   "*不要使用框架或 ORM！用标准库就好！*

当我们用人们应该做的事情或应该使用的技术来淹没他们时，你应该做什么和不应该做什么的列表会越来越多。

更糟糕的是，我们倾向于让它听起来好像这些技术是不可选择的。不使用它们会使你成为一个糟糕的开发人员，或者会导致一个低劣的应用程序，在最轻微的增长迹象下就会崩溃。

现在我并不是说所有这些技术都不好，我也不是想挑任何特定技术的毛病，但我的主要问题是，我们有这种倾向，在有需求之前就鼓励过于复杂的软件架构。更简单地说，我们建议人们在构建第一个版本之前，先构建我认为是第 20 个版本的应用程序，以便从中学习和提高。

最终结果不难猜测。我们现在有整整一代开发人员在实践一些人所说的“炒作驱动的开发”开发人员正在构建更复杂、更难维护、需要更长时间来构建的软件，并且所有这些额外的移动部分更容易出现错误。

现在，如果这种情况只发生在由经验丰富的开发人员管理的项目中，他们能够做出明智的决策并知道取舍，我可能会坐在一旁什么也不说。同样，如果有人因为熟悉某项技术而决定使用它，这也没什么不好。真正困扰我的是，当我们开始把这个建议给那些不懂的开发者时；开发人员可能不是初学者，但他们不理解当他们选择使用微服务、spa 和我们告诉他们应该使用的任何其他东西时，他们正在接受的额外复杂性。

在这篇文章中，我希望帮助证明你可以不用做所有你应该做的事情就能构建有用的、可伸缩的软件。为了证明这一点，我将讨论我在构建 Gophercises 时所做的选择，我为什么做这些选择，以及它们如何影响我的代码。

## 内容管理

我们将从我的内容管理系统(CMS)开始。或者像其他人所说的，我缺乏一个合适的内容管理系统。

从长远来看，我希望我的围棋课程需要一个更复杂的后端。我目前有两个已经出版的课程，我正在进行第三个。在某种程度上，为每一个都定制后端可能会变得不可扩展，而且令人头疼。对于需要在每个课程页面上创建帐户的用户来说，这将是令人讨厌的，对我来说，维护所有这些不同的应用程序是令人难以置信的相似，这将是令人讨厌的。简而言之，我可能需要为我所有的课程建立一个统一的后端。

当我建立统一的后端，一个更复杂的 CMS 将成为一种需要。我需要一种方法来添加新的课程，更新视频，标记课程是付费还是免费，以及其他一百万件事情，但短期内这根本不是真的。短期来看，我只需要一种向 Gophercises 推广新练习的方法，而我是唯一一个这样做的人。我没有非开发人员或其他任何人管理这些内容，所以为什么要全力以赴建立一个 CMS 呢？为什么不写一些代码，用这些信息植入我的数据库呢？

```
app.Exercise{  Number:  1,  Title:  "Quiz Game",  Link:  "/quiz",  Description:  "Create a program to run timed quizzes via ...",  Topics:  []string{"strings",  "channels",  "goroutines",  "flags"},  Duration:  36*time.Minute  +  52*time.Second,  Videos:  []app.Video{  app.Video{Name:  "Overview",  VimeoID:  "..."},  app.Video{Name:  "Solution - Part 1",  VimeoID:  "..."},  app.Video{Name:  "Solution - Part 2",  VimeoID:  "..."},  },  Solutions:  []app.Solution{  app.Solution{Name:  "Part 1",  Branch:  "solution-p1"},  app.Solution{Name:  "Part 2",  Branch:  "solution-p2"},  },  }, 
```

我的应用程序中的真正代码包含了这些练习的一部分，然后这些练习被用来在每次部署时播种数据库。

不仅代码非常简单，编写起来非常快，我还受益于让编译器验证我的所有数据大部分都是有效的。现在我们可以整天争论这不是 CMS，从技术上来说你是正确的，但是 CMS 的目标是为你提供一种将新数据放入你的应用程序的方法，这段代码解决了这个问题。对其他细节的争论，大多与我无关；我只关心解决实际问题。

## Gophercises 没有传统的认证系统

同样，如果我的所有课程都有一个统一的后端，我需要一个真正的认证系统。用户需要一种登录、更改密码、查看他们有权访问的课程、添加支付方式以及调整数百万其他小事情的方式。

很容易想到从现在开始可能会有几次迭代，也很容易将此作为现在构建这些功能的理由，但短期内我希望尽快发布。这可以让我开始获得用户对课程和网站的反馈，让我知道什么是真正有效的，网站哪里有缺点。我真正需要做的是一个电子邮件地址来交换课程材料。有了这个电子邮件地址，我可以给用户发送一个链接，让他们登录课程，更新课程信息，以及我觉得他们可能感兴趣的其他课程或有趣的文章(比如这篇)的信息。

为了实现这一点，我构建了一个密码重置流程。首先，用户在表单中输入他们的电子邮件地址。之后，我在后台做一些事情来创建一个账户，并做其他任何必要的事情，然后最后我给他们发一封带有“登录”链接的电子邮件。当用户点击这个链接时，我假设他们是该电子邮件地址的所有者并登录，就像密码重置流程一样。从这一点开始，我让用户登录几个星期，就像标准会话一样，如果用户丢失了登录链接的电子邮件，他们只需输入新的电子邮件地址。

*有些重置流程是不让你登录的，而是允许你用令牌更改一个密码，然后用新密码登录，所以在高层次上它们大致是等价的，只是在细节上有一些小的区别。*

现在肯定有一些关于这个认证系统的抱怨，我会第一个承认它可能比传统的用户名/密码登录表单更烦人，但是有一些额外的好处很多人经常忘记:

1.  这比构建要快得多，如果我构建一个真正的认证系统，我可以重用大部分代码。这意味着我可以更快地开始制作练习视频，并且能够更快地在课程和课程网站上收集反馈，这比我花时间预先建立认证系统要快得多。
2.  通过使用这种方法，用户不必担心由于糟糕的安全措施而导致另一个网站泄露他们的密码。我不是说我会在认证系统上做得很差，但是用户没有真正的方法来验证我知道我在做什么，或者我没有偷工减料，所以当你用你在其他地方使用的密码注册时，你基本上是在进行信仰的跳跃，信任开发者。我的注册过程不需要太多的信任(你只需要信任我的电子邮件地址)。

总之，这个系统并不完美，但是它让我快速地运行起来，满足了我的最低要求。我没有把注意力放在我认为我在未来版本中需要的东西上，我认为这已经足够了，可以在未来进行改进。

## 部署

这可能是第一部分，在这里，我们没有考虑我删减特性的方式，而是选择使用比行业标准更简单的技术。

虽然现在部署应用程序的唯一方式似乎是 Docker、Kubernetes 等，但事实是我们可以用更简单的方式部署 Go 应用程序。在我的例子中，我决定使用我熟悉的可靠的方法——在本地构建，上传一个二进制文件到我的服务器，最后进入服务器告诉它重启 systemd 服务。下面是我的部署过程的大致轮廓(用真实代码)。

```
# 1\. Build the app
$ mage prod

# 2\. Upload the binary to the production server
$ rsync -azP prod root@gophercises.com:/path/to/app/prod

# 3\. Stop the service on the server
$ ssh root@gophercises.com "sudo service gophercises.com stop"

# 4\. Reseed the database with exercise data
$ ssh root@gophercises.com "/path/to/app/prod seed --db /path/to/db"

# 5\. Restart the application on the server
$ ssh root@gophercises.com "sudo service gophercises.com restart" 
```

没有微服务——Gophercises 托管在一个数字海洋水滴上(一个 5 美元的水滴！).

没有负载平衡、自动伸缩、docker，或者您可能期望的任何东西。相反，我只是依靠 systemd 来保持我的服务运行，这对于我的用例来说非常好。

作为参考，Gophercises 目前有大约 1 万名用户，所以我怀疑这种方法可以通过使用一个更强大的网络服务器来很好地扩展。

这显然不是对每个人都有效，但是我还是根据我的需求和经验选择了我的技术，对我来说这是最简单的方法，即使它不是行业标准并且可能不被接受。

## 服务资产

如果您密切关注上一张幻灯片，您可能会想，“您如何处理不断变化的资产，如图像、CSS 文件和其他可能不包含在二进制文件中的内容？”

简而言之——我不提供任何不包含在我的二进制文件中的东西。相反，我使用 [packr](https://github.com/gobuffalo/packr) 将所有这些资产嵌入到我的二进制文件中，这是一个来自 Buffalo“框架”(或者像 Mark 喜欢的那样——“网络生态系统”)的库。下面是实现这一点的代码的简要预览。

```
// Assets are compiled into the binary with gobuffalo/packr  images  :=  packr.NewBox("../assets/img")  // Assets can be accessed via the Bytes method  imageBytes  :=  images.Bytes(imagePath)  // Packr boxes can also be used as an http.FileSystem and then  // served via the http.FileServer handler  mux.Handle("/img/",  http.StripPrefix("/img",  http.FileServer(images))) 
```

第一个代码片段创建了一个新的 packr 框。这大致相当于文件系统上的一个目录，但是可以构建到二进制文件中。

第二个代码片段演示了如何访问 packr 框中特定文件的字节。同样，这非常类似于从本地文件系统访问它，但都是从内存中完成的。

第三个也是最后一个代码片段演示了如何将 packr box 用作`http.FileSystem`，使得在 web 服务器上提供 packr box 的资产变得非常容易，就像在本地文件系统上提供目录一样。在我看来，这就是 packr 包装盒真正因其简单性而大放异彩的地方。

### 打包的利弊

这种方法显然有一些巨大的缺点。例如，我的应用程序有更大的内存占用，构建更慢，因为资产需要添加到二进制文件中，它的性能可能不如 CDN，我可能会错过一些其他的。

尽管有这些缺点，但使用 packr 的一些非常明显的好处是说服我在这个应用程序中使用它的原因:

1.  如果我有正确的二进制版本，我保证也有正确的构建资产。我不必担心由于服务器有更新二进制文件和没有正确的资产而产生的奇怪的错误。
2.  上传和发布只需要处理单个文件，使部署变得非常简单。

## 附加工具- Mage、Cobra 和 BoltDB

我还使用了一些非常适合我需求的工具，并简化了构建和部署。

### 建筑用法师

我提到将资产构建到我的二进制文件中很慢，所以我想要一种方法来改善这种体验。我没有放弃 packr，而是选择寻找任何快速的解决方案，并且找到了一个有[法师](https://github.com/magefile/mage)的解决方案。

Mage 是一个构建工具，你可以用 Go 编写所有的构建命令。虽然你们中的许多人可能知道如何创建 Makefiles，并且喜欢使用它们，但是我没有多少编写自己的 Makefiles 的经验。另一方面，我有相当多的编写 Go 代码的经验；我每天都在 Go 里写代码！

Mage 允许我用一种我熟悉的语言，以一种非常简单和轻量级的方式创建构建脚本。这导致我创建了两个构建过程——一个用于构建，一个用于开发。

```
# Mage is used for multiple build targets
$ mage
Targets:
  dev    Builds the development binary that reads assets from disk
  prod   Builds the production binary with embedded assets 
```

第一个——`dev`——为我的本地操作系统构建二进制文件，用标志告诉 packr 从磁盘读取资产，而不是将它们捆绑到二进制文件中。这些是我在 dev 中 99.99%的时间使用的选择，所以在这里把它设为默认值是完全有意义的。

第二个构建——`prod`——构建产品二进制文件。这意味着构建我的生产服务器操作系统(ubuntu linux)并将所有资产捆绑到二进制文件中。使用此命令构建会花费更多的时间来完成，但仍然相对较快，并且不需要记住所有正确的生产设置。

### 用于子命令的 Cobra

在前面的几个代码片段中，我展示了如下代码行:

```
# Cobra allows me to build one binary with many subcommands
$ ./app server --db /path/to/db # starts the server
$ ./app seed --db /path/to/db   # seeds the database 
```

Cobra 使得向我的二进制文件添加子命令和标志变得非常简单。这一点很重要，因为我不想意外地为一个版本的二进制文件运行 seed 命令，然后用另一个版本运行服务器。通过将所有这些打包成一个二进制文件，我再次避免了任何混淆或版本不匹配的潜在问题。

### 数据库的 BoltDB

我需要一种方法来跟踪注册用户、练习元数据以及传统上存储在数据库中的任何其他内容。虽然我对 PostgreSQL 很熟悉，而且它会是一个很好的选择，但我还是决定冒险使用 BoltDB 来处理 Gophercises。

这一选择有几个动机。首先，BoltDB 非常符合我的使用模式。BoltDB 在高读取、低写入设置方面做得很好，而 Gophercises 在用户注册时只有少量写入。除此之外，99%的数据库操作都是读取。

BoltDB 也是纯 Go 写的。通常情况下，我不会仅仅因为一项技术是用哪种语言创造出来的就倾向于它，但在这种情况下，这意味着我可以构建一个嵌入了 BoltDB 逻辑的二进制程序。也就是说，我不必担心在我的服务器上安装数据库。只要我导入 BoltDB 包，这种逻辑就全部内置到我的二进制文件中，这又一次简化了服务器设置和部署之类的事情。

事实上，在 BoltDB、packr 和 Cobra 之间，我基本上有一个文件可以交给任何拥有 linux 服务器的人来启动 Gophercises 的本地副本。他们不会有我使用的相同的数据库文件，所以他们不会有所有相同的用户数据，但他们仍然有所有的种子练习和其他相关数据。

## 我的构建和部署流程关注我的需求

在我们继续之前，我想说明一点，我并不建议您使用与我这里完全相同的设置。对你们大多数人来说，这将是一个糟糕的选择，因为你们的要求与我的不同。

解释我的构建和部署过程的目的是为了证明:

1.  你不需要 Docker，Kubernetes 等，而且
2.  你可以根据你所熟悉的和适合你当前需要的来挑选使用什么，即使它们是非正统的决定。

## 呈现 HTML 页面

虽然这看起来可能不是一个流行的选择，但 Gophercises 不使用 JavaScript 前端，而是使用标准库的`html/template`包在服务器上呈现所有的 HTML。

从长远来看，一个带有 API 的 JavaScript 前端可能是有意义的。我可能有一个受益于 JS 框架的非常复杂的 UI，使用相同 API 的移动应用程序，还有许多其他原因需要考虑 JSON API + JS 前端设计。

短期来看，这根本没有意义。Gophercises 的当前版本仅由几个独特的页面组成；没有一个用于创建新练习的自定义表单的管理门户。视频是通过 Vimeo 托管的，所以即使这部分应用程序也相当简单。事实上，我考虑使用 JavaScript 前端的唯一原因是因为它在严格执行前端和后端逻辑分离方面做得很好，但这可以很容易地在不使用 JavaScript 前端的情况下实现，而且我在编写 Go 代码方面比 JavaScript 更有经验。因此，我选择在 Go 服务器上完成所有的 HTML 呈现，而是使用以下组织技术将视图特定的逻辑与后端逻辑隔离开来:

*   更小的类似组件的模板
*   装饰图案
*   服务对象

旁注:如果你熟悉 Ruby 开发，你可能听说过装饰模式和服务对象。两者在围棋上很像，但又不太一样。

### 更小的类似组件的模板

这里的基本思想不是什么独特或新的东西；我没有为一个页面创建一个大模板，而是为单个组件创建模板，就像你在 React 中做的那样。下面是一个例子。

```
{{define "exerciseWidget"}}
<div class="panel widget widget-exercise">
  <!-- ... some code omitted for brevity -->
  <div class="col-xs-12">
    <p class="mb0">Exercise {{.Number}}</p>
    <h4 class="m0">{{.Title}}</h4>
  </div>
  <!-- ... -->
  <div class="col-xs-4 text-right text-top">
    <p class="mb0">Length</p>
    <p class="m0 h4 length">{{.Duration}}</p>
  </div>
  <!-- ... -->
</div>
{{end}} 
```

通过将模板分解成小组件，您可以轻松地在不同的页面上重用它们，并且管理每个组件变得更加容易。

### 装饰图案

装饰模式最好用一个例子来解释。让我们从`Exercise`类型的简化版本开始。

```
package  app  type  Exercise  struct  {  Duration  time.Duration  // + other fields  } 
```

在我们的`Exercise`类型中，我们有一个属于`time.Duration`类型的`Duration`字段。在后台，这基本上是一个整数，将持续时间存储为纳秒数。很明显，这对最终用户没有用。没有人想读“这个练习有 100000000 纳秒长。”你不能轻易决定你是否有足够的时间看一个视频，但是有了“10 分钟”这样的时间，这就变得容易多了。

现在我们不想把这个逻辑附加到我们的`app.Exercise`上，因为这是 UI 特有的逻辑，但是我们需要把它放在某个地方，那么我们该怎么做呢？

另一个选择是给你的模板添加功能，但是这也不是一个理想的解决方案。向模板中添加逻辑会导致代码难以维护和测试。

我选择创建一个名为`html`的新包，在包中创建一个新的`Exercise`类型，然后在新类型中嵌入`app.Exercise`,而不是这两个选项中的任何一个。

```
package  html  type  Exercise  struct  {  app.Exercise  } 
```

从这一点开始，每当我想将一个`app.Exercise`传递到一个 HTML 模板中时，我将创建一个`html.Exercise`并嵌入原始练习，然后将它传递到模板中。

```
var  orig  app.Exercise  forTemplate  :=  html.Execise{  Exercise:  orig,  }  tpl.Execute(w,  forTemplate) 
```

这段代码的工作方式与旧代码非常相似，但是它允许我们通过添加一个同名的方法来“覆盖”(*因为没有更好的术语*)字段。

```
package  html  type  Exercise  struct  {  app.Exercise  }  func  (e  Exercise)  Duration()  string  {  if  e.Exercise.Duration  <  0  {  return  "TBD"  }  // returns a string like “1:22:03”  return  fmt.Sprintf("%d:%02d:%02d",  e.Hours(),  e.Minutes(),  e.Seconds())  } 
```

在大多数 Go 代码中，这会导致问题，因为我们需要区分调用函数和引用带括号的函数。也就是说，在下面的例子中，最后两行代码是不同的。

```
var  e  html.Exercise  e.Duration  // get the function as a value, but don't call it  e.Duration()  // actually call the function 
```

幸运的是，在 HTML 模板中这是不正确的，这意味着我们模板中以前引用了`Duration`字段的任何点现在都将调用新的`Duration`方法。

```
{{define "exerciseWidget"}}
<div class="panel widget widget-exercise">
  <!-- ... some code omitted for brevity -->
    <p class="m0 h4 length">{{.Duration}}</p>
  <!-- ... -->
</div>
{{end}} 
```

现在我们有了一种方法来隔离特定于视图的逻辑，同时不污染模板，这基本上就是装饰模式。

### 服务对象

最后要解决的是 HTTP 处理程序和服务对象。

```
type  UserCreator  struct  {  userService  *db.UserService  mgClient  *mailgun.Client  }  func  (uc  *UserCreator)  Create(email  string)  (string,  error)  {  token,  err  :=  uc.userService.Create(email)  if  err  !=  nil  {  return  "",  err  }  err  =  uc.mgClient.Welcome(email,  token)  return  token,  err  } 
```

所以我不打算详细说明它们是什么，但是使用这种模式的主要好处是:

*   代码易于测试，数据需求清晰
*   HTTP 处理程序被简化了，因为它们通常只调用一两个服务对象方法
*   将来移植到 JSON API 非常简单，只需重用服务对象

通过应用所有这些技术，我能够在不使用 JS 前端的情况下隔离所有特定于视图的逻辑。

## Gophercises 没有测试

这可能是我在构建 Gophercises 时做出的最有争议的决定；我选择不写任何测试。

让我先声明一下，我是测试的忠实粉丝。我目前正在学习一门教授围棋测试的课程，我永远不会提倡放弃测试。尽管如此，我仍然觉得不测试这个应用程序是有意义的。

**为什么？**

1.  Gophercises 非常简单，因此测试它既快速又容易。
2.  我不经常改变 Gophericses。虽然我会在每个新的 exercise 版本中发布新的应用程序版本，但这些版本变化都不会包含任何逻辑或功能变化。
3.  该网站的当前版本旨在提供对课程网站可行和不可行的见解。

前两者协同作用非常好。当一个应用程序测试速度很快，并且不经常改变时，这意味着我们实际上可能花费更少的时间进行手动测试，而不是编写自动化测试，但是第三个原因也是至关重要的，因为它表明我不需要在将来为这个应用程序编写测试。相反，我可能会删除一大部分代码，并使用我所学到的知识来构建一个新的改进的课程应用程序，其中包括测试。

重要的是要记住，可以编写一次性代码来学习。不是每个人都在第一遍就写出 PR (pull request)完美的代码，也不是所有我们写的代码都可以在没有重构的情况下轻松测试。有时候最好的方法是简单地接受你的代码不会被测试的事实，并把它作为一个学习实验。

## 关键要点

这篇文章的主要目的是**你可以在 Go 中构建更简单的软件，而不会被所有你“应该”做的事情所困扰**。

我没有为 Gophercises 编写测试，尽管我知道我应该这样做。我有意识地权衡了这一决定的利弊，认为其收益与成本不相称。

另一个例子是来自 Rails、Django 或 Laravel 背景的开发人员；对于这些开发人员来说，框架可能是学习和熟悉 Go 的最佳选择，尽管大多数人反对使用框架。我并不是想暗示他们应该永远使用它们——有很多很好的理由考虑不使用框架——但是如果一个框架将为开发人员提供更多的共同点，并使学习和掌握 Go 的速度更快，那么它就不应该作为学习工具被忽视或回避。

不要担心人们说你应该做什么。不要担心使用最新最棒的技术，因为每个人都在炒作它们。请记住，您可以在 Go 中构建更简单的软件，简单的内容会因开发人员的不同而有所不同，这取决于他们过去的经验。

## 想看看 Gophericses 吗？

如果你想了解这篇文章中讨论的课程，你可以(免费)到这里来:[Gophercises.com](https://gophercises.com)

在这个课程中，你将学到各种编写 Go 代码的技巧，但更重要的是，你将获得大量的实践机会，这将帮助你成为编写 Go 软件的专家！

哦，我还在经营我的高级课程“Web Development with Go ”的销售，以庆祝 Gophercises 第 20 次也是最后一次练习的发布。销售将于 6 月 4 日结束，在此过程中，您将学习在 Go 中从头开始构建一个真正的、可用于生产的 web 应用程序，从头开始构建一个完整的身份验证系统。