# 有没有好的技术债这种东西？

> 原文:[https://dev . to/iedaddy/is-the-so-the-this-a-thing-thing-as-good-technical-debt-490 b](https://dev.to/iedaddy/is-there-such-a-thing-as-good-technical-debt-490b)

# [![](../Images/f9d1e551a2b5ca97c72d1d76111bc50b.png)T4】](http://iedaddy.com/wp-content/uploads/2018/03/Technical_Debt.jpg)

我喜欢“技术债务”这个术语，因为它是一个普通企业主容易理解并付诸实践的隐喻。债务隐喻的一个特别的好处是，它非常便于与非技术人员交流。就像金融债务一样，技术债务会产生利息支付，这是因为我们现在所做的选择，我们必须在未来的发展中付出额外的努力。

技术债务并不总是不好的，就像一个企业如何利用市场机会借贷和招致债务一样，开发人员也可能招致技术债务以赶上重要的截止日期或比他们“第一次就做对了”更快地将特定功能推向市场在一个系统中也可能存在谨慎的债务，团队成员认识到如果支付的利息足够少，可能不值得支付，例如在系统中很少更新或被开发触及的部分——如果子系统永远不会接收到功能更新，我们可能不需要关心注释密度、复杂性或重构。技术债务的棘手之处在于，与金钱不同，有时很难有效衡量它将如何影响你未来的速度，在某些情况下，可能永远不需要在未来还清。每种类型的技术债务都必须根据特定的系统及其生命周期进行权衡。

技术债务有各种来源，有些是好的，有些是坏的，但技术债务隐喻背后的思想是，走捷径、犯错误或故意选择都有相关的成本，不处理这些问题的成本将随着时间的推移而增加。众所周知，我是 sonar cube(【https://www.sonarqube.org】)的忠实粉丝，这是一个管理代码质量的开源仪表板。它试图计算代码库的技术债务(称为“代码味道”)，使用静态代码分析结果，如自动化测试的代码覆盖率、代码复杂性、重复、违反编码实践、注释密度和基本编码标准的遵循。

虽然它通过代码分析很好地报告了技术债务领域，但是这些数字对业务真正意味着什么呢？这就是技术债务的模糊性以及它如何影响项目的长期生命力的地方。当我想到技术债务的最大成本时，它通常围绕着今天实现的设计或代码可能如何减缓我们交付未来功能的能力，从而为收入损失创造机会成本。记住这一点，当测量技术债务时，识别这些不同种类的技术债务的影响对于每个项目都是重要的和具体的。正是通过评估每一种具有潜在危害的技术债务，并找出某一种技术债务过多的时候，我们才能开始明智地管理它。

在考察一个项目、评估不同种类的技术债务以及它们可能让你付出的代价时，这涉及到一种比仅仅查看 sonarQube 仪表盘更模糊的方法。在讨论不同类型的技术债务以及我们最终可能支付的利息时，我喜欢将这些债务归为以下几类:

## [](#different-types-of-technical-debt)不同类型的技术债务

### [](#architectural-)建筑($$$) [![](../Images/cce899bc538e3588f5255ffa5b8e50a1.png)](http://iedaddy.com/wp-content/uploads/2018/03/leaning-tower-of-technical-debt.jpg)

如果您正在构建一个关键组件或平台存在根本缺陷的系统，因此它不可伸缩或不可靠，这可能是一个巨大的问题，直到真正的客户运行您的产品时，您才意识到这一点。如果由于核心依赖问题或对客户将如何使用系统的不正确假设，您不能按照您需要的方式扩展您的架构，您将别无选择，只能重写或重组系统的大部分。

一个很好的例子就是游戏明星公民和他们选择在 CryEngine 平台上构建游戏([https://www . extreme tech . com/gaming/237434-Star-Citizen-single-player-delayed-infinitely](https://www.extremetech.com/gaming/237434-star-citizen-single-player-delayed-indefinitely))

### [](#fragile-code-)脆弱码($$$)

[![](../Images/7d6ef9e4acf5fe43c811730badedfbcf.png)](http://iedaddy.com/wp-content/uploads/2018/03/fragile_code.jpg) 在每一个大型系统中，总有几个模块似乎给开发人员带来最多的问题。这些子系统或组件的代码很难理解，更改起来既昂贵又危险，因为它们一开始就写得很差，或者使用了非常过时的技术。因为这些子系统非常脆弱，所以没有开发人员想接触它们，当他们接触时，通常是进入并应用非常具体的解决方案，然后继续前进。因为这些短视的补救措施随着时间的推移而积累，问题只会变得更糟。这些脆弱的组件需要被识别和评估，以便完全重写来“防弹”它们，否则它们将继续成为项目账本上的昂贵债务。

### [](#untestable-or-undertested-code-)【不可测试或欠测试代码($$) [![](../Images/20f339e25b93371da58df71195a3442b.png)](http://iedaddy.com/wp-content/uploads/2018/03/danger-untested-software-ahead.jpg)

编写单元测试需要时间。它还要求开发人员编写他们的代码，以便可以对其进行单元测试。开发人员在编写代码以便进行单元测试时，倾向于将他们的功能分解成小的原子组件，使单元测试变得容易。如果您的系统有不能很好地自动化的单一功能，并且您选择不花时间去重构它们，那么您最终得到的测试是脆弱和缓慢的，并且每当您更改代码时都会崩溃。随着代码库增加额外的选项和特性，这将导致您的测试费用随着时间的推移而增加。更糟糕的是，脆弱的自动化测试在失败时被忽略，因为“它总是失败”。这可能会导致手动和探索性测试成本的增加，以及当代码返回大量错误报告时计划外工作的额外成本，这些错误报告本来可以通过适当的自动化测试来避免。

### [](#no-automated-deployment-)没有自动部署($$)

[![](../Images/0a7555539197adf746c37191e9168f57.png)](http://iedaddy.com/wp-content/uploads/2018/03/easy-automated-deployment.png) 我将此包括在技术债务中，因为每次有工时和内在风险方面的释放，我们都要为此支付“利息”。这是一个隐藏的成本，似乎没有人想到，直到你真正坐下来回顾它是如何影响你的发布，以及你的开发节奏。手动发布过程本身就容易出错。因此，每个版本最终都是“以防万一”的全员参与场景。随着时间的推移，这些成本不断增加。不仅仅是熬夜，还包括从开发团队的正常周期中抽出时间来准备发布，以及在当前的周期中损失生产力。自动化部署的成本是否比安排一次手动发布更昂贵？大概吧。但是自动化在产品的每个后续版本上都有巨大的回报，并且可能有最好的长期投资回报。

### [![](../Images/9841ef976bd7e6240ef5aeb36f603dc3.png)](http://iedaddy.com/wp-content/uploads/2018/03/black-box-magic.png)黑盒码($$)

这是由某个失踪已久的绝地代码大师写的代码，他已经离开了公司或者退休了。我们都知道它在起作用，我们也看到它在我们的系统中起作用，但是没有人能解释为什么它会这样起作用。这也是一个非常棘手的领域，因为企业可能会决定在项目分类账中承担技术债务，因为没有计划改变这个黑盒负责的任何功能。这很好。直到有所改变。而且没用。这种类型的技术债务就像那些在最后支付巨额贷款的抵押贷款。你可以几年不付，然后咬紧牙关付清，或者如果你的产品到了寿命末期，你可以不用付钱就让系统退役。

### [](#outdated-libraries-)过时的库($-$$$)

[![](../Images/ecb2641d54b3d898c265354aac5002ee.png)](http://iedaddy.com/wp-content/uploads/2018/03/outdated-libraries.jpg) 这可以是小额的技术债务，也可以是巨额的技术债务。这是因为必须根据它给业务带来的风险进行评估。当过时的库包含新发现的安全缺陷时(如 Experian hack[https://www . cyber scoop . com/equifax-breach-Apache-struts-FBI-investigation](https://www.cyberscoop.com/equifax-breach-apache-struts-fbi-investigation)或 Heartbleed 漏洞([http://heartbleed.com/](http://heartbleed.com/))期间被利用的过时的 struts 库)，这一点尤其重要。一个过时的库可能被认为是少量的技术债务，直到它不是，然后它变成一个所有人都参与的补救练习，在被利用之前让您的系统打补丁。

### [](#poor-error-handling-and-instrumentation-)【糟糕的错误处理和插装($ $-$ $)[![](../Images/aa8d84a7a623666658e2eecff42042e5.png)](http://iedaddy.com/wp-content/uploads/2018/03/poor-error-handling.jpg)

如果您的代码中没有适当的错误处理，当出现问题时就很难进行故障排除。更糟糕的是，您可能没有注意到某些子系统出错了，除非您有办法检测这些错误和性能问题。当系统没有以应有的方式工作时，如果您没有适当的工具，就很难确定问题的根本原因，除非您在系统的流程中构建了各种窗口。

### [](#copyandpaste-code-)复制粘贴代码($$)

[![](../Images/b926bb97eb2afd4f05b55204139c19a2.png)](http://iedaddy.com/wp-content/uploads/2018/03/copy-paste.jpg) 代码起作用时，就起作用；sonarQube 在通过静态代码分析找出重复代码块方面做得相当不错。因此，我们最终可能会得到许多略有不同的代码结构变体，开发人员剪切并粘贴这些变体，然后在迭代过程中稍加修改，以便将代码投入生产。我们总是告诉自己，“在某个时候，我可以返回并参数化代码，以巩固和重构功能。”但是，在项目的迭代过程中，很少对时间进行预算，并且债务继续堆积。现在，对代码工作方式的任何更改都需要开发人员记住多个代码的位置，并反复进行相同的更新。如果只是几个地方，可能没什么大不了的，但是忽略这个问题会导致在项目生命周期中进行额外更新的成本更高。

### [](#inconsistent-programming-practices-)【不一致的编程方法($-$)[![](../Images/58b970ed5cabcdc4eba4b579ea62e9f2.png)](http://iedaddy.com/wp-content/uploads/2018/03/noconsistency.jpg)

有时候，通过检查代码，很容易判断谁编写了系统的哪个部分。一个开发人员可能总是使用一种特定的模式而不是另一种模式，或者他们以一种非常特定的方式创建特定模块的包装器，使其用法不同于另一个开发人员实例化代码的方式，或者以一种特定的方式命名变量。这种实践在小团队中可能不被注意，但是参与更新系统的开发人员越多，这个问题就变得越复杂，并且越难交给其他开发人员。代码应该尽可能与开发人员无关，人们应该只能通过查看签入日志来判断是谁编写了特定的代码行。

### [](#backwards-compatibility-)向后兼容性($-$$)

[![](../Images/9993e4e978df32506843b902717bc719.png)](http://iedaddy.com/wp-content/uploads/2018/03/backwards-compatible.png) 通常这是一笔必要的短期债务。您将希望保持与先前版本的某种兼容性。但是之前的版本呢，或者之前的版本呢？维护系统向后(或向前)兼容性的力度越大，维护和测试系统能够处理的所有兼容性场景的成本就越大。

### [](#inefficient-design-)【低效设计($) [![](../Images/e9d9625faf3dc5e8825f26966cdbc716.png)](http://iedaddy.com/wp-content/uploads/2018/03/streamlining.jpg)

在今天这个时代，硬件很便宜。有时，您可以通过在问题上投入一些硬件来摆脱浪费的做法，问题会暂时消失。这可能导致一些懒惰的编程实践，在初始部署期间，低效的内存使用或处理不会显现出来。随着您的横向扩展，您的计算需求将会增长，这些问题将会开始浮现。

### [](#magic-numbers-)幻数($)

[![](../Images/005fff426b677b00895ab04fb590e97a.png)](http://iedaddy.com/wp-content/uploads/2018/03/magic-number.jpg) 一般来说，幻数是有意义或多次出现的唯一值，最好可以用命名的常数来代替。它们在代码中的使用通常是唾手可得的，这意味着它们可以很容易地被替换，但是对于不熟悉系统的其他编码人员来说，它们使他们很难跟上特定幻数的使用方式和原因。在代码中用命名的常量替换这些值，可以在代码中使用更具描述性的标识符，从而更容易理解代码块的整体。

### [](#custom-functions-for-built-in-features-0)【自定义功能】为内置功能(0-$) [![](../Images/36b855073dc6806cb14328aba7a0a150.png)](http://iedaddy.com/wp-content/uploads/2018/03/customized-code.jpg)

每个程序员对特定的框架都有不同程度的体验。当他们为一个系统构建功能时，他们可能最终会创建已经在框架中处理的特定功能。一旦这个功能建立起来(假设它没有大的缺陷)，它就变成了沉没成本。当然，这是低效的，但是只要它在工作，就没有任何与重复功能相关的技术债务。

### [](#documentation-0)文档(0-$)

[![](../Images/0c4cec2f8f1005bc5e4755fff2571fd1.png)](http://iedaddy.com/wp-content/uploads/2018/03/documentation.png) 没人看文档。任何编写的文档在出版时通常都是过时的。那么，这真的是技术债吗？也许不是，这将取决于程序的复杂性和为什么要制作文档。对于小项目，开发人员通读代码并认为它是“自文档化的”(假设我们有良好的注释实践)可能更容易。但是对于需要监管审查或者接受审计的较大的项目或者系统，文档可能被认为是必须产生的一种必要的邪恶。

## [](#summary)总结

技术债务的比喻很有用，因为它给了我们一个模型，非技术团队成员可以用它来评估在项目的整个生命周期中所做的选择。必须偿还的债务和可以延期偿还的债务之间也有一个有用的区别。

如果团队认识到他们正在承担债务，并且理解早期版本与偿还成本之间的权衡，谨慎的债务可以被认为是可接受的。该评估过程的重要部分是，团队认识到他们实际上正在承担这些风险，并根据产品生命周期中进一步补救问题所需的工作来权衡这些风险，并为最终支付费用做出计划。

在项目的整个生命周期中，即使是最好的团队也会有债务需要处理——因此团队成员认识到这一点并有意识地选择何时接受技术债务以及何时花时间修复它是很重要的。

[![](../Images/c57a7c93ac1be6727cf2fe30f144c5bd.png)T2】](http://iedaddy.com/wp-content/uploads/2018/03/technical-debt-uphill.jpg)

帖子[有好的技术债这种东西吗？](http://iedaddy.com/2018/03/understanding-technical-debt/)最早出现在[上一个内陆帝国老爸的经历](http://iedaddy.com)。