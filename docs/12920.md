# 疯狂的普通兔子洞

> 原文:[https://dev . to/scotthannen/the-generic-rabbit-hole-of-madness-2nnn](https://dev.to/scotthannen/the-generic-rabbit-hole-of-madness-2nnn)

您是否曾经编写了一些泛型类，却发现自己在努力编写另一个与这些泛型类交互的接口和类？也许是这样的:

```
public interface IMultipleMappingCommandExecutor<TRepository, TData, TResult>
    where TRepository : IRepository<TData>
{
    IEnumerable<TResult> ExecuteCommands<ICommandInput, ICommandOutput>(
        IEnumerable<Command<ICommandInput, ICommandOutput>> commands)
        where TCommandInput : ICommandInput
        where TCommandOutput : ICommandOutput;
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

如果你已经走上了这条路，你可能已经经历了在这些不同的状态中循环往复的挫败感:

*   它不会编译。
*   它可以编译，但是我们的泛型参数要求我们指定`IEnumerable<TSomething<TSomethingElse<TWhat>>>`中的类型是什么，而我们实际上希望它们同时是任何东西，因为这不是泛型的用途吗？
*   我们创建接口或抽象类，并约束我们的泛型类型来实现它们，像`where TCommandInput : ICommandInput`，现在我们可以使用我们想要的集合类型，它会编译...
*   ...但是现在我们的泛型方法不知道集合中的实际类型是什么。它只知道它们实现了`ICommandInput`或`ICommandOutput`。所以我们的方法必须检查对象的实际类型，并相应地进行分支。
*   我们试图通过添加更多的通用参数来解决这个问题。
*   我们试图通过添加更多的基类来解决这个问题。
*   我们试图用反射来修复它。
*   我们尝试通过使用`dynamic`来修复它。
*   我们谷歌“协变”，因为它在一个编译器错误中，然后阅读前三段的[协方差和泛型](https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance)中的逆变。
*   我们去散步或打乒乓球来清醒头脑。
*   我们发布了一个关于堆栈溢出的问题，用`Base`、`A`、`B`和`C`替换我们所有的类名，用`IFruit<Base>`替换我们的接口名。评论要求澄清，但我们很难记住我们试图做什么。
*   不知何故，它工作了，但现在我们需要它做一些稍微不同的事情，我们的头爆炸了。

我已经做了以上所有的事情(除了栈溢出问题，这是一个真实而频繁的问题)足够多次，以至于我给它起了一个名字:*疯狂的一般兔子洞*。

## [](#why-does-this-happen)为什么会这样？

小时候，我们多久会用乐高积木来建造许多非常小的物体？如果我们有几副纸牌，我们多久会用纸牌搭建 50 个真正的小房子？更有可能的是，我们专注于建造一些辉煌、高耸、复杂的建筑。

也许这种可以理解的心态影响了我们以后作为软件开发人员的生活，以至于我们发现自己试图创建更大、更复杂的类，而不是更小、更简单的类。此外，许多关于面向对象编程的入门课程和书籍过分强调继承的使用，而没有警告其危险性。

当我们第一次创建继承类的层次结构时，我们可能会体验到我们正在构建一个令人印象深刻的结构的错觉，就像我们对乐高积木所做的那样。实际上，我们只是创建了许多相互耦合的单独的类。一个继承的类可能看起来像是建立在它的基类之上，但它实际上只是一个依赖于那个基类的新类。

仿制药就像是我们的乐高积木上一些令人敬畏的新附加组件，有轮子、动作玩偶或激光。现在，我们可以用更多的活动部件建造更酷的东西，并展示给我们的朋友。当我们第一次得到它们时，我们会有点过分，这是很自然的。

## [](#how-to-step-back-from-the-edge)如何从边缘退一步

当我得意忘形地构建了一堆像上面例子中那样的接口，或者可能是一些基类时，大多数时候我都没有编写任何具体、有用的代码来实现它们。我只是迷恋于我的实际代码将适合我正在创建的这个令人印象深刻的框架的想法，我在这上面花了太多的时间。几乎毫无例外，当我开始写一些真实的东西时(如果我能做到的话)，我意识到它不适合我的普通怪物。

对于一般疯狂的兔子洞的解药是避开那种分心，只写我们需要的实际代码，来做我们现在需要它做的实际事情。并编写单元测试。如果我们开始编写更多类似的代码，并开始看到模式的发展，那就是我们可能看到如何重用公共元素的时候，这可能包括使用泛型。但不管这种情况是否会发生，我们实际上是在生产有用的东西，而不仅仅是在转动轮子。

## [](#a-simple-example-of-a-useful-generic-class)一个*有用的简单例子*泛型类

我们为什么使用泛型的一个很好的例子是`List<T>`。之前。NET 2.0 中，如果我们想要一个强类型集合，我们必须编写大量复杂的、重复的代码。许多项目都有类似于`SalesOrders`的集合类。`Contacts`或`Products`，除了他们收集的类型之外，它们都是 100%相同的。

与。NET 2.0 和泛型，所有的样板代码都被完善并移入框架本身，这样我们就可以重用它，我们只需要指定类型。我们甚至有专门的集合，如`HashSet<T>`、`Queue<T>`以及更多的集合来处理各种场景，而编写和维护大量类型的代码是不现实的。

这向我们展示了什么？当我们发现自己在编写或需要重复的代码时，我们应该使用泛型，这些代码只随它所操作的类型而变化。通常情况下，如果我们首先编写一些代码，我们只会识别出这样的重复代码*。*有时候我们可以看到一点点未来，或者看到眼前。我们通常不能。这就是为什么我们要写今天我们能写的最好的代码，并且在我们进行的时候重构，包括当我们意识到我们将要引入重复代码的时候。

我已经在疯狂的兔子洞里浪费了太多时间，自从认识到并打破这个习惯后，我变得更有效率了。希望我的经历能拯救其他人。如果下到那个洞里，一个小时后你还没有找到底部，你可能永远也找不到了。

* * *

最初发布于[scotthannen.org](http://scotthannen.org/blog/2018/04/05/the-generic-rabbit-hole-of-madness.html)。