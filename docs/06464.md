# 我完成了我的第一个编码训练营

> 原文:[https://dev . to/Juan frank 77/I-finished-my-first-coding-boot camp-4jj 8](https://dev.to/juanfrank77/i-finished-my-first-coding-bootcamp-4jj8)

由于这是我在 dev.to 的第一篇文章，我把它用于不同的目的(如果你愿意的话，一石二鸟)。除了制作 Readme 之外，使用 markdown 做一些事情，尝试液体标签，看看东西是如何嵌入的，显然没有表情符号出现，讲述我迄今为止所做的事情，并为自己留下笔记，记录我从 React 学到的东西，如果我不经常使用，我可能会忘记。

所以，事不宜迟，让我们开始记笔记吧！

# [](#the-bootcamp)训练营

上周末，我完成了前端开发的编码训练营，特别是使用 React 作为构建 UI 的技术。训练营由公司的一名技术经理领导，其他开发人员全程作为指导者协助。它始于七月的第一周，所以可能已经过去一个月了。大部分是通过现场会议在线进行的，每周一，它被要求出现在网站上参加讲座，讲座通常由技术经理主持。

尽管 bootcamp 是为 React 的前端开发设计的，但是如果没有基础知识，你就不能开发出好的 UI，所以这是我们首先要做的。第一周网页语义与 HTMl 和适当的 CSS 样式。我只用 HTML 和 CSS 做了我的第一个杂志封面！我从没想过这是可能的，但我认为我做得很好。

然后我们继续用 HTML 制作可访问的表单，并学习 Aria 属性，我以前从未在我的网站中考虑过 a11y，所以这是一个很大的优势。第二周是关于优秀的旧 Javascript，从最基础的一直到 ES6 的增加。当我意识到我的 JS 技能很一般时，我遇到了第一个大挑战。我只是被用来制作一些很酷的动画和 DOM 操作，仅此而已(也许还有一些 Ajax 和 Jquery，但这不是重点)。

由于我有点完美主义(虽然我已经有所进步，不再对我必须解决的问题过于情绪化，哈哈)我晚上大部分时间都在做复习题目的“作业”。我做的第一件事就是这个计算器，它非常简单，但却能完成工作。

[https://codepen.io/juanfrank7/embed/KBqvZq?height=600&default-tab=result&embed-version=2](https://codepen.io/juanfrank7/embed/KBqvZq?height=600&default-tab=result&embed-version=2)

我的目标是用最少的代码满足需求。那是我个人的胜利，尽管在那个阶段并不重要(尽管后来我意识到，那不应该总是最终目标)

解决一些来自 codewars 的卡式也有助于学习算法技巧和练习编写 ES6 函数。然后在那周的最后一个挑战中，我用纯普通的 JS 做了一个滑动拼图，没有使用外部库。

这真的考验了我的知识，我花了整整一个晚上搜索互联网和 Mozilla 文档，寻找一种简单而优雅的方式来完成这个难题的功能。

[https://glitch.com/embed/#!/embed/slider-puzzle?path=index.html](https://glitch.com/embed/#!/embed/slider-puzzle?path=index.html)

现在，在第三周和第四周，React 展示了其所有创新和闪亮的新概念。
你知道钻组件，虚拟 DOM，JSX，道具，状态，生命周期方法，路由器和 Redux。

在这里，我做了我的第一个 React SPA，并尝试了一下太有名的待办事项列表。除了编写代码来创造东西，导师们的重点更多的是写好代码。从那时起，创建的所有应用程序都是干净的、语义化的和可访问的。

专注于在训练营中表现出色让我对前端开发的当前趋势有了新的看法。而不是到处尝试下一个流行的 Javascript 框架。如果我能只擅长一般的 Javascript 会怎么样？如果我可以选择我的开发工具，而不是感觉 FOMO，因为我没有使用这个新的库或框架或技术或任何东西。

# [](#enter-react)回车反应过来

有了这些，我想我有一些事情要坦白。我最初认为 React 只是一堆炒作，事实上我在和一些亲密朋友的交谈中说过。我就像“是啊，另一个很快就会过去的时尚”。伙计，我错了，这是一种完全不同的思考 UI 的方式。

我需要一些时间来适应 React 中处理事情的方式，并改变我的 OOP 和 MVC 思考代码的方式，以获得更多功能性的东西，但现在有一些事情对我来说是有意义的，让我产生了“点击”，这就是为什么这是为了”这种类型的时刻。

让我们来看看，如果我们使用的组件应该是模块化和可重用的，我们如何处理数据？原来有两种数据。一个是不需要随着时间的推移而改变，另一个是必须更频繁地更新以使应用程序按预期运行。

保持不变的数据(静态数据)是组件属性的一部分，称为 props。随时间变化和更新的数据(动态数据)被称为状态，它被声明一次，并且只通过为任务 *setState* 提供的方法进行更新。

现在，因为 ES6 语法在 React 中几乎无处不在，所以有许多箭头函数、let 和 const、析构、承诺和最重要的类。对我来说，这并不麻烦(事实上恰恰相反)。但是我看到有些人开始有点迷失了，并且没有很好的接受。

如果我在组件中制作组件，那么就会有父子关系，这实际上并不是因为继承 *Java 风格*更像是一种数据流。父组件可以将数据作为道具传递给子组件，然后这些子组件可以在它们的函数中使用数据，做它们自己的事情。

因此，如果父组件是保存逻辑的组件，而子组件只是处理其他细节(比如交互和获取用户输入)，那么如果子组件需要访问父组件中的功能呢？原来，父母不仅可以通过 props 发送他的状态，还可以发送函数，这样孩子就可以访问这些信息。

## [](#more-react-quirks)多反应过来的怪癖

在创建组件时，我还注意到了一些事情。标准的 ES6 类是从 *React 扩展而来的。组件*但是也有一种不同的方法，那就是使用功能组件。
这个组件基本上只是普通的 ES6 功能，但是有更多的限制和更少的东西要写，这使得它们不容易出现错误。

但是我内心的好奇问。为什么这是两种流行的做法？我怎么知道什么时候选择一个比另一个合适？就像“我如何知道何时使用默认导出还是命名导出”这样的问题。起初，我只是得到了正常的答案，想知道这两者之间有什么不同，但有些事情让我明白了。

在一次谈话中，技术经理提到了我以前从未想过的事情，状态不仅仅是用来存储变化的数据的元素，可以有两种类型的状态。应用程序做什么的状态(如存储输入或响应点击)和界面如何呈现其元素的状态(如切换或下拉)。

这让我们发现了*表示性*组件和*容器*组件。表示层处理 UI 的所有方面，以及这些元素如何响应用户交互而变化，它们甚至可以根本没有任何状态，而容器组件处理应用程序的逻辑，因此具有反映变化并将其传递给其他组件的状态。

用 ES6 类创建的组件是容器组件的良好候选，因为它们有状态，有上下文，人们需要使用 *this* 来访问 props，并且它们还有 React lifecyle 方法。另一方面，功能性组件更适合表示性组件，因为它们基本上只是*渲染*方法，它们不需要任何其他东西(老兄只需要关注 UI，没有其他需要担心的)。

有些人说组件是功能性的也是无状态的，但是类组件也可以是无状态的，反过来，如果功能性组件有自己的状态呢？那些可能是更多的超级赛亚人表象成分。

最初真正困扰我的另一件事，后来在最终演示的那天引起了我的注意，那就是在组件中使用 *this* 。在一个子组件中访问数据的方式是通过使用 *this.props.whateverdata* 是正常的，但是如果我将在几个不同的地方使用它，那么 *this.props* 将会重复很多次。

一个巧妙的小技巧是通过使用 ES6 析构赋值，我可以将所有不同的属性放在单独的变量中，而不是做 *this.props.userName* 我可以只做 *userName* ，它将同样工作，增加的好处是代码更干净，重复更少*。*

可能我不得不处理的最奇怪的事情，是绑定这个的*,这样我在组件内部的函数就可以工作了。这是一位导师向我指出的另一件事，他就像
“你为什么在构造函数中绑定我这个？”。*

不可否认，我在主组件中使用了 5 个不同的函数，构造函数看起来像是我在做某种惩罚
(就像《辛普森一家》导言中的巴特)。

我当时想“是的，这看起来不太好，但这是我目前所知的唯一方法”，然后在那一刻，我学会了不这样做:

```
constructor(props){
    super(props);
    this.state = { messages: [] };
    this.sendMessage = this.sendMessage.bind(this);
}

sendMessage(text){
    //My code goes here
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我可以在类属性中使用箭头函数，这样我的组件就会变成这样:

```
constructor(props){
    super(props);
    this.state = { messages: [] };
}

sendMessage = (text) => {
    //My code goes here
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

更加清晰，简洁，没有更多的装帧线！(我不想被禁足在黑板上，请)。

所以是的，我想就是这样，没有遇到任何可能困扰我的事情(至少现在)，这肯定会帮助我记住这些以前有点陌生的反应。

如果你知道一些其他使用组件的怪癖，或者知道我可以做得更好更简洁的其他方法，一定要在评论中告诉我！我很想学习其中的一些并尝试一下。

无论如何，如果你一直读到这里，那么非常感谢你！感谢你的时间。