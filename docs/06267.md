# 去拿模块

> 原文:[https://dev.to/rhymes/go-gets-modules-12ei](https://dev.to/rhymes/go-gets-modules-12ei)

尽管命名混乱，Go 1.11 最终还是增加了一个合适的包管理系统，他们称之为*模块*。

我第一次使用 Go 时，当我被告知必须将代码放在文件系统的特定位置(臭名昭著的 [`GOPATH`](https://github.com/golang/go/wiki/GOPATH) )时，我说出了一系列 wtf，并使用特定的命名方案来匹配 git 存储库和其他类似的东西。2018 年，我们似乎在倒退。我确信这样做有很好的理由，我只是不在乎来自很久以前(或多或少)已经解决了如何管理包的问题的语言。我最终适应了[的生活方式](https://golang.org/doc/code.html)，但并不开心。

幸运的是，不久之后我发现了 [`go dep`](https://github.com/golang/dep) ，它允许开发者对发生的事情有更多的控制(但仍然在`GOPATH`内部)。Dep 的工作方式是拥有一个文件，其中列出了依赖项及其版本和修订，并创建一个`lock file`(许多包管理器共享的概念)，同时在一个`vendor`文件夹中出售依赖项(通常被忽略)。gitignore)。这样，当您构建应用程序时(在本地、在 CI 上、在服务器上或其他地方)，您可以确定应用程序正在使用哪个版本的什么包。

Go 社区决定更进一步，创建一个初步版本，这个版本很可能是官方的 T2 工具来处理包和模块。这种新工具与 [Go 1.11](https://blog.golang.org/go1.11) 一同推出。

该工具是这样工作的:

*   你写你的应用程序来声明你需要哪些包
*   它创建一个`lock file`并处理语义版本控制
*   它可以选择供应商文件

我喜欢它的地方是:

*   它非常简单，而且是内置的
*   它迫使开发人员按照语义版本化来标记他们的库。我讨厌不得不通过主版本来找出发生了什么变化，因为开发人员太懒了，不会发布他们的代码。这也可能会鼓励他们为这样的标签写变更日志
*   它可以自我清理(删除应用程序不再使用的模块)
*   它告诉你为什么你安装了这个或那个包
*   它不会自己升级到主版本(这对大型项目来说是巨大的)
*   **它允许同一个 app 中同一个包的多个版本**(这太神奇了！我可以想象未来运行时热代码替换的场景——比如 Erlang 或 Common Lisp，但也许我有些过头了)

关于模块的更多细节可以在 [Go 的文档中找到，关于 go mod](https://golang.org/cmd/go/#hdr-Module_maintenance) 和[这是一个很好的概述](https://roberto.selbach.ca/intro-to-go-modules/)。