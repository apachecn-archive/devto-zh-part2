# 什么是 React 服务器端渲染，我应该使用它吗？

> 原文：<https://dev.to/mladenstojanovic/what-is-react-server-side-rendering-and-should-i-use-it-5b7i>

如标题所述，我将尝试提出一些关于这种不再热门的技术的优点和缺点，并帮助刚接触 SSR 的人对它有更多的了解。

首先，让我们深入了解一些术语

### SSR？同构？万能的？WTF？

首先，对于一些不知道(我直到最近才知道)服务器端渲染没什么特别的。任何一个普通的静态网站都是在服务器端呈现的，一个服务器得到你的请求并把 HTML 发送到你的浏览器。我们也有模板语言为我们做一些被认为是服务器端渲染的巧妙的技巧。
**但是**当我们谈论 JavaScript 时，服务器端渲染通常指前端代码在后端系统上运行时渲染 HTML 的能力。

#### SPA + SSR =同构*

*或通用

同构或通用应用程序是可互换的短语，通常指的是一种编写应用程序的方式，这样你就可以在服务器端和客户端使用相同的语言。更具体地说，对于 JavaScript，最好的情况是您也使用相同的语法。例如，如果你在 NodeJS 中运行你的后端，你可能会使用 CommonJS 模块语法。

```
//...Our awesome app code...
const circle = require('./circle.js');
//...Rest of our awesome app code... 
```

Enter fullscreen mode Exit fullscreen mode

你在 ES6
中写下你的反应

```
//...Our awesome app code...
import React, { Component } from 'react';
//...Rest of our awesome app code... 
```

Enter fullscreen mode Exit fullscreen mode

使用 Webpack，我们可以开始在应用程序的服务器端使用我们的 ES6 导入语法，这是 isomporphic 应用程序的真正目标。

### 为什么我首先要使用 React 进行服务器端渲染？

我们传统的 React 应用程序在加载时会有这样的流程:

*   浏览器请求页面
*   **暂停**
*   我们得到一个非常空的 html 和一个指向 JS 文件的脚本标签，所有的代码都在这个 JS 文件中
*   浏览器请求该脚本
*   **暂停**
*   屏幕上可见的内容

我们现在看到，到服务器有 2 次往返，这是可以接受的。但是，让我们想象一下，我们的应用程序有一个博客帖子列表，或者一系列图像，或者我们需要从某个 API 请求的任何内容，现在这个流程更现实一些，看起来像这样:

*   浏览器请求页面
*   **暂停**
*   浏览器请求我们的 JS
*   **暂停**
*   React 应用程序启动，从后端请求数据
*   **暂停**
*   屏幕上可见的内容

正如您所看到的，请求的数量增加了，所以在我们的用户看到屏幕上的任何内容之前，还会有更多的事情发生。

**现在为服务器端渲染 React App**

*   浏览器请求页面
*   **暂停**
*   屏幕上可见的内容！

什么？怎么会？让我们更详细地看一下

*   浏览器请求页面
*   服务器负载在内存中反应
*   服务器获取所需的数据
*   服务器渲染 React 应用程序
*   服务器将生成的 HTML 发送到浏览器
*   **用户看到内容**
*   需要 JS 文件
*   React 应用程序启动，从后端请求数据
*   应用程序重新呈现(水合物)在屏幕上。

如您所见，在为用户获取一些内容之前，我们只访问了服务器一次。现在，在我们重新呈现所有内容之前，我们提供的内容是静态的，所以如果我们的用户速度非常快，并且在水合物发生之前就开始点击，应用程序将不会响应。

### 我们用这种方法解决了什么问题？

其中最大的两个是 **SEO** 和**感知性能提升**

如果你的应用程序有点大，搜索引擎爬虫会把你的页面看作一个几乎是空的 html，只有一个`script`标签请求你的大规模 React 应用程序，因为它不会等待它填满 DOM 的那一刻，你的页面不会被索引。与此同时，谷歌改进了他们的爬虫，也可以搜索 javascript 创建的内容，但必应或百度仍然缺乏这一功能，所以如果你的大部分受众来自其他搜索引擎，你就必须解决这个问题。

使用 React SSR，您的第一次有意义的绘画时间将(在大多数情况下)显著缩短。这是一些公司的一个重要指标。你肯定听说过许多公司通过减少网络应用程序的加载时间来增加利润的故事。([https://wpostats.com/](https://wpostats.com/))。

上面我写了**感知到的**性能提升，虽然你确实会比使用传统的 React 应用更快地向用户提供内容，但问题是这可能不是*性能*提升。在上面一点的 SSR 请求示例中，您可以看到服务器也在做客户端所做的一切:它启动 React，为您呈现应用程序并输出 HTML。这意味着你每件事都做了两次，这并不理想。另外，react 用来将漂亮的 jsx 代码转换成 HTML 的方法非常慢，而且是同步的。这将使服务器处于更大的负载之下，并且来自服务器的初始响应将稍后到达。

如果您决定使用服务器端呈现，您可能会有 2 台服务器:一台用于 API 和业务逻辑，另一台用于呈现目的。知道渲染过程是一项多么艰巨的任务后，您可以扩展渲染服务器，以匹配增加的负载。

因为我不是第一个遇到这些问题的人，沃尔玛实验室的工程师们创造了一个工具来优化 SSR 的这些怪癖，称为电极。他们还写了几篇关于它的很酷的文章，如果你已经做到这一步，真的值得一读:)([https://medium . com/walmartlabs/using-electrode-to-improve-React-server-side-render-performance-by-up-to-70-e43f 9494 eb8b](https://medium.com/walmartlabs/using-electrode-to-improve-react-server-side-render-performance-by-up-to-70-e43f9494eb8b))
也有 React SSR 的“框架”，例如 Next.js，它正在获得社区的良好关注和支持。

使用 React SSR 也增加了多个层次的复杂性。还记得自由使用`window`或`document`做事情吗？算了吧！

当然，我只是开玩笑，但你必须格外小心，因为应用程序将首先在节点环境中运行，例如，`window`和`document`没有在那里定义，所以你必须克制自己不要在`componentDidMount`之外或没有`if (typeof window !== 'undefined')`的情况下使用它们。我不记得我的应用程序坏了多少次，直到我习惯了它。

你的节点服务器将捕捉你的路由，并把它传递下去，以决定渲染什么，那么它是如何访问服务器上的路由器的呢？并没有。解决方案？双重路线。你的应用程序的渲染依赖于你的 Redux 存储？双店。

SSR 引入了许多复杂性，幸运的是，像 Next.js 这样的工具解决了其中的许多问题，但是如果你坚持自己解决所有这些问题，那将非常困难。

### 应该用 React 服务器端渲染吗？

也许吧。

如果你/你的公司真的重视 SEO，并且你的大量访问来自谷歌以外的搜索引擎，是的。

如果你/你的公司真的重视用户感知的性能，想想看，如果你的客户端应用程序性能不能得到任何更好的东西，那么是的。

在任何其他情况下，我的建议是置身事外，这只会增加你的项目的复杂性，而没有真正的好处。