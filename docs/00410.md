# 新手的运行时间复杂度(像我！)

> 原文:[https://dev . to/independent/run-time-complexity-for-初学者-like-me-56dl](https://dev.to/independnt/run-time-complexity-for-beginners-like-me-56dl)

当我们编写 javascript 和算法的大部分时间里，我们知道在所有的编程中，几乎总是有更好的方法来编写一些东西。有时它看起来更好，或者看起来更容易理解，但运行时复杂性特指运行您编写的代码所花费的时间，或者用更简单的术语来说，它描述了算法的性能。

那么我们如何弄清楚我们如何能发现我们算法的复杂性。有不同种类的“运行时间”，这取决于你的算法如何运行。例如，如果我们有一个函数需要任何类型的 For 循环，并且给定一个参数，那么根据输入的长度，for 循环有更多的项要迭代。例如，反转一个字符串。

```
function rev(str){
    let rev = ""
    for(let i = str.length - 1; i >= 0; i--){
        rev += str[i]
    }
    return str
} 
```

对于每个输入，我们的计算必须对字符串中的每个额外字符再迭代一次。相当简单，因为我们为多一个字符多做了一步，这就是所谓的线性运行时。字符数和步数之间有直接的关系，比例为 1:1，因此是线性的。

现在，如果我们有一个不止一个 for 循环的东西，有时候，这是必要的。如果任何函数都有两个 for 循环，那么现在就需要双倍的处理能力。假设我们有一个函数需要迭代一次，然后再迭代一次。让我们举一个函数嵌套了 for 循环的例子。这表明对于给定的每一个额外的输入字符，函数现在必须做更多的工作。向我展示的一个例子是一个控制楼梯的函数。

```
function stairs(input){
    for(let row = 0; row < input; row++){
        let stair = '';

        for(let column = 0; column < n; column ++){
            if(column <= row){
                stair += '#';
            }else {
                stair += '  ';
            }
        }
        console.log(stair)
    }
} 
```

这里，随着输入的增加，函数需要执行的步骤呈指数增长。输入值为 2 时，我们必须执行 4 个动作。对于 3，我们必须执行 9 件事情，以此类推。这就是所谓的正交运行时间，或 n*n 东西(N^2).

我读到过最常见的时间如下:
线性时间(如上所述)
二次时间(如上所述)
常数时间
指数时间
对数时间
准线性时间

让我们简要地谈一下其余的部分。

对于常数时间，常数这个词是关键。这意味着无论输入是什么，操作都将花费相同的时间。所以大概是这样的:

```
function FifthItem(list){
    return list[4]
} 
```

无论大小如何，这将总是在相同的运行时计算，因此名称，常数。(O(1))

指数时间被认为是效率最低的。原因在于，指数时间解决方案意味着只添加一个额外的字符，解决方案所需的处理能力就会加倍。这显然是非常糟糕的。(第二^北)

对数时间是如果给定的元素增加一倍，但结果不会使所需的工作量增加一倍。通常通过数据的排序数组进行搜索，或者任何类型的搜索，这些通常以对数时间运行。(对数(n))

最后，准线性时间。类似于对数时间，这是当被迭代的元素数量加倍时，工作量并不加倍，而是增加了 1 加多一点。这是一个我还没有完全理解的问题，但这就是我在这里的原因。(n * log(n))

今天就到这里吧！