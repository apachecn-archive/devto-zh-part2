# 解开嵌套代码

> 原文:[https://dev.to/gonedark/untangling-nested-code-1h0a](https://dev.to/gonedark/untangling-nested-code-1h0a)

我不相信写代码的硬性规定。你经常听到他们。方法之类的东西不应该超过 **15** 行。方法应该只有**一个**语句。缩进必须是 **4 个空格**。这样的规定太死板了。

在现实世界中，代码要灵活得多。遵守这些硬性规定会分散我们对真正重要的东西的注意力- *可读性*。如果我的注意力严格集中在行数或`return`语句的数量上，我会阻止自己编写更可读的代码，仅仅因为它有几行“太长”或有不止一个`return`语句。

许多这些硬性规则试图解决嵌套代码。嵌套代码很难理解。身体上，眼睛有更多的视觉扫描。从心理上讲，每一层嵌套都需要更多的开销来跟踪功能。所有这些都让读者精疲力尽。

嵌套代码主要是条件的结果。由于条件是所有编程逻辑的基础，我们不能很好地删除它们。我们必须认识到它们对读者的影响，并采取措施尽量减少这种影响。

## [](#getting-back-on-top)重回巅峰

为了提高可读性，我们希望将代码带回到顶层。本质上，循环和条件语句有一个嵌套的结构。没有办法避免在这些街区筑巢。然而，我们可以避免嵌套超出这个结构。

让我们看几个嵌套代码的例子，以及提高它们可读性的实践。

### [](#empty-blocks)空块

你可能不相信我，但是我不止一次看到过下面的代码:

```
public function handle($request, Closure $next)
{
    if (env('APP_ENV') == 'development') {
        // do nothing...
    } else {
        if ($request->getScheme() != 'https') {
            URL::forceScheme('https');
            return redirect('https://www.example.com/' . $request->getPath());
        }
    }

    return $next($request);
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

没错，一个空的`if`块。我也见过相反的情况——一个空的`else`街区。没有规定说`if`必须与`else`成对出现——至少在我过去 20 年使用的任何编程语言中都没有。空块是*死码*，删除它们。

### [](#conditional-values)条件值

嵌套的代码块通常会返回值。当这些是布尔值时，有机会压缩代码块并直接返回条件。

考虑一个`Set`类的`isEmpty`方法中的嵌套代码:

```
public function isEmpty() {
    if ($this->size === 0) {
        return true;
    } else {
        return false;
    }
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

虽然这个方法块只有 4 行代码，但它包含多个子块。即使只有这么少的几行，也很难读懂，这使得代码看起来比实际更复杂。

通过识别原始布尔值的条件返回，我们有机会通过直接返回条件来完全删除嵌套代码。

```
public function isEmpty() {
    return $this->size === 0;
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

给定这个恰当命名的方法的上下文，结合现在的一行代码块，我们降低了它的感知复杂性。虽然这一行看起来很密集，但它比原来的更易读。

***注意:**冷凝条件可以处理比原始布尔值更多的数据类型。例如，可以通过简单类型转换将条件作为整数返回。然而，这迅速增加了复杂性。许多程序员试图通过使用三元组来解决这个问题。但是三元组在不降低复杂性的情况下压缩了代码，使得代码可读性更差。在这些情况下，保护条款是更好的选择。*

### [](#guard-clauses)守护条款

嵌套代码通常是逻辑发展的结果。作为程序员，我们写出每一个条件，直到达到可以安全执行动作的程度。

虽然这个流程对于执行来说可能是理想的，但是对于阅读来说并不理想。对于每个嵌套层次，读者必须保持一个不断增长的心智模型。

考虑下面这个`Set`类的`add`方法的实现:

```
public function add($item) {
    if ($item !== null) {
        if (!$this->contains($item)) {
            $this->items[] = $item;
        }
    }
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

逻辑上的进展:如果*项*不是`null`，如果`Set`不包含*项*，则添加。

问题不仅在于这样一个简单动作的复杂性，还在于这个代码的主要动作隐藏在最深层。

理想情况下，代码块的主要操作在顶层。我们可以将条件重构为一个 guard 子句，以解开嵌套代码并公开主要操作。

guard 子句只是保护我们的方法免受异常路径的影响。虽然它们通常出现在代码块的顶部，但是它们可以出现在任何地方。我们可以通过应用[德摩根定律](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)并放弃控制权，将任何嵌套的条件转换成保护子句。在代码中，这意味着我们否定条件并引入一个`return`语句。

通过将其应用于`add`方法，我们的实现变成:

```
public function add($item) {
  if ($item === null || $this->contains($item)) {
      return;
  }

  $this->items[] = $item;
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

在这样做的时候，我们不仅画出了主要的动作，而且强调了我们方法的特殊路径。对于未来的读者来说，现在理解起来没那么复杂了。测试起来也更容易，因为异常路径被清楚地画了出来。

### [](#switching-to-if)切换到 if

一个`switch`语句是一个非常冗长的代码结构。`switch`固有 4 个关键词，3 个等级。即使包含的代码块只有几行，也要读很多。虽然这在某些情况下是可以接受的，但在其他情况下却不是。

在一些情况下，使用`if`语句代替`switch`语句可能会产生更可读的代码。

*   当只有几个`case`块时，`switch`语句的固有结构比等价的`if`语句产生更多的行。
*   当`case`块包含嵌套代码时，复杂性增加，可读性降低到临界水平。使用保护条款或采用*大块*中的实践可以改进代码。
*   当需要类型转换或计算来将值加入到`switch`的约束中时。这不适用于支持更复杂的`case`比较的语言(Swift、Go 等)。

`switch`当`case`语句与其块中的代码行之间存在 1:1 的比例时，语句是最好的。无论这些行是赋值、`return`语句还是方法调用，只要比率大约为 1:1，可读性几乎保持不变。

```
switch ($command) {
    case 'action':
        startRecording();
        break;
    case 'cut':
        stopRecording();
        break;
    case 'lights':
        adjustLighting();
        break;
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

***注意:**在这种情况下`switch`语句被精简，许多程序员使用映射、数据库表或多态来代替。所有这些都是额外的选择。请记住，每个解决方案都有权衡(复杂性)。对于大多数代码来说,`switch`语句通常“足够好”。*

### [](#complex-loops)复杂循环

嵌套代码的另一种常见形式是循环。循环本质上是复杂的。作为程序员，我们被诅咒一个错误，错过增量逻辑。再说一次，我们是人不是电脑。所以我们不太可能赢得与循环的斗争。他们会一直挑战我们。对付这种复杂性的唯一方法是可读性。

我不会深入讨论哪些数据结构和算法可能有助于改进您的代码。这太专业了。不过，一般来说，大多数循环都处理累积或调用。如果你发现你的代码库包含很多循环，看看是否可以使用像`filter` / `map` / `reduce`这样的高阶函数。虽然这可能不会提高所有读者的可读性，但它会提高你个人的技能。

* * *

***想要更多提示？**这个实践摘自[base code](https://basecodefieldguide.com)——一个包含 10 个真实实践的领域指南，帮助你改进你每天写的代码。*