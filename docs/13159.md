# 新的虚拟 Go 包版本

> 原文:[https://dev . to/dnn rly/the-new-go-package-versioning-for-dummies-504 l](https://dev.to/dnnrly/the-new-go-package-versioning-for-dummies-504l)

或者也许应该是“*by*Dummies”…

2018 年 2 月， [Russ Cox](https://swtch.com/~rsc/) ，围棋的幕后推手之一，发表了一系列博客，试图解决目前围棋界最大的问题之一。这是我又一次尝试去理解这个世界到底发生了什么。

这个博客主要是重复他的所作所为，夹杂着我在网上旅行时收集到的一些信息。目的不仅仅是为了你的娱乐，也是为了帮助修复我脑海中的东西。

源材料:

*   [Russ 的 Go 版本控制博客](https://research.swtch.com/vgo)
*   [版本提案博客](https://blog.golang.org/versioning-proposal)
*   [正式的 Go 包版本提案](https://github.com/golang/proposal/blob/master/design/24301-versioned-go.md)

# 有什么问题吗

假设您在项目中导入了一个包`github.com/me/pkg`。一切都很好，直到您决定在另一台机器上构建您的项目，而它不再工作。你的代码没有改变，但是运行`go get githhub.com/me/pkg`得到了一个完全不同且不兼容的包版本。没有办法指定您想要的包的版本。如果 API 改变或者引入了一个 bug，你就没有保护了。对`github.com/sartori/go.uuid`的改变就是一个很好的例子。[这个问题](https://github.com/satori/go.uuid/issues/66)是在提交后出现的，它改变了一些方法的返回签名，破坏了导入包的项目。有一段时间，如果不看代码，就无法判断你拥有的是哪个版本。

当您考虑到您的项目导入的包也导入它们自己的依赖项时，情况会变得更糟。同样，你无法控制`go`为你下载的版本。

如果您的依赖项导入了与您相同的包，会发生什么呢？我们再以`go.uuid`为例。如果我的项目导入了`go.uuid`，而另一个项目也导入了，该怎么办？如果我发现了 API 的变化并更新了我的代码，那么其他导入的包呢？我不得不等待维护人员发现问题，并在他们着手解决时解决它——如果他们曾经解决过的话！

> **版本控制快速说明**
> 
> 信不信由你，版本的含义是有标准的。它叫做[语义版本化](https://semver.org/)。简单来说，你的版本定义为`vX.Y.Z`。让我们按照重要性从低到高的顺序来解决这个问题:
> 
> *   Z ->补丁版本–更改此项以表示小的更改，如错误修复
> *   Y ->次要版本–更改此选项以进行向后兼容的更改，例如添加新功能
> *   X ->主版本–当您做出不兼容的 API 更改时，请更改此选项

# 做了什么来解决它

## Gopkg.in

在 [http://gopkg.in](http://gopkg.in) 上可以获得这项服务，它允许软件包开发者管理他们的 API 版本。这项服务作为 Github 的门面，允许开发者`go get`你想要导入的包的特定主要版本。Gopkg 服务将通过解析 git 标签计算出最新版本，确保`go get -u`将更新您的依赖关系。

这是包版本问题的最早解决方案之一，但它似乎从未流行起来。我的感觉是，它应该比现在更受欢迎。尽管这种方法很好，但也存在一些问题:

*   你只能使用 Github 来托管你的代码，所以没有私人位桶或公司回购
*   你只能得到一个主要版本的最新版本——如果你发现一个问题，没有回滚
*   你的依赖依赖于两个外部服务，而不仅仅是 Github

## 大量工具

人们开始开发工具来改善这种状况。这里有一个相当全面的列表。总的来说，这些工具允许您指定您想要下载的依赖项的版本，甚至到具体的提交。有些通过将存储库克隆到您的`GOPATH`中来工作，有些实际上提供了完整的构建解决方案。

一些有趣的例子是:

*   很长一段时间以来，glide 一直是 Go 包管理的黄金标准，它使用一个文件来指定每个依赖项的版本
*   [Godep](https://github.com/tools/godep) 保存你已经下载的依赖项，允许你提交`vendor`目录
*   [Govendor](https://github.com/kardianos/govendor) 可以使用命令行参数获取个人，并再次将它们保存在`vendor`中

另外值得一提的是 [gb](https://getgb.io/) ，它在`GOPATH`的`src`旁边创建了一个单独的`vendor`目录，但也执行了构建。

所有这些工具都试图以略微不同的方式解决包版本控制的问题，并取得了不同程度的成功。最终，虽然他们都没有得到 Go teama 的官方支持，也没有因此而遭受损失。

## 供应商目录

围绕`vendor`目录的需求，共识已经开始形成。所以在 1.5 版本的 Go 中，通过将环境变量`GO15VENDOREXPERIMENT`设置为`1`，为`vendor`目录带来了官方的实验性支持。这个给出了一个很好的背景，但是关键的一点是`go`现在在解析依赖关系时更喜欢`vendor`目录。将查找依赖关系，就好像`./vendor`与`$GOPATH/src`相同一样。有自己的`vendor`目录的包仍然是一个问题，在这一点上你必须依靠工具来解决。

在 1.7 版本中，实验结束了，`vendor`目录不再位于环境变量之后。后续版本通过确保`go test ./...`不在`vendor`中导航来改进支持。

Go 团队的意图是让这个目录可用将允许社区就正确的解决方案达成共识，但这并没有出现。

## Dep

很明显，仅仅期望社区自发地对功能进行重大改变是行不通的。他们决定组织一支精干的队伍来解决这个问题。他们选择的人做出了重要的贡献，有些人是上面的包管理者的作者。其意图是，无论他们想出什么工具，最终都将成为 Go 工具的一流支持部分。

他们很快决定从头开始创建一个新的包管理工具，并学习了这个工具的所有经验。这个工具叫做`dep`。它允许你在`Gopkg.toml`和`Gopkg.lock`中指定依赖关系，如果你愿意，可以和`vendor`的内容一起提交。这是一个很棒的工具，它可以计算出你的依赖项是什么，哪些版本是兼容的。

但是可能会很慢。会向您展示它在做什么，有时这意味着它会克隆一个存储库，构建最新的标签，看着它失败，然后处理标签，直到有东西工作为止。有时甚至这也不起作用。

## 这些为什么不行？

到目前为止，所有这些方法都有一个问题没有解决。当您有两个依赖于同一子依赖的不同版本的依赖时会发生什么？通常这不是问题，但是如果这成为您正在使用的 API 的一部分呢？

# RSC 的解决方案

Russ 本质上回到了基础，也许有点回到过去，想起了 Go 团队的一个早期命题，这个命题被称为*导入兼容性规则*。Russ 在 [Go 博客](https://blog.golang.org/versioning-proposal)上有一段精彩的描述。

> 如果旧包和新包具有相同的导入路径，则新包必须向后兼容旧包

除此之外还有什么要说的吗？也许有…

这意味着，如果您想要进行突破性的 API 更改，您需要设计一个新的导入路径。这就成了他所说的 [*语义导入版本化*](https://research.swtch.com/vgo-import) 。这意味着如果你有你的包的版本 1，这反过来意味着把 API 的版本放在导入路径中。`github.com/my/pkg`变成了`github.com/my/pkg/v1`。遵循*语义版本*标准意味着 API 兼容性是使用主版本来表示的，我们在路径中使用了主版本。

当他稍微思考这个问题时，Russ 发现了几个有趣的暗示:

*   如果软件包开发人员坚持 semver 标准，您可以确信当您导入一些东西时，它将与您的`GOPATH`中的所有东西兼容
*   如果你决定升级一个软件包，它不会破坏你的构建或业务逻辑

Russ 在 Dep 方面的经验表明，用于解析包版本的算法可能会非常慢。他开发了一种新的算法， [*最小版本选择*](https://research.swtch.com/vgo-mvs) ，使用了上面的概念。事实证明，在早期原型中解决版本问题要快得多。它还有一个额外的好处，那就是它可以使用一个单独的配置文件，这个文件既可以由人编辑，也可以由工具编辑。

实现这一切的 Go 工具的一个更完整的原型版本已经写好了， [`vgo`](https://godoc.org/golang.org/x/vgo) 。