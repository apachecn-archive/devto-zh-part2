# 我的祈祷者杂志之旅:结论

> 原文:[https://dev . to/danieljsummers/a-tour-of-my prayer journal-endowment-296 l](https://dev.to/danieljsummers/a-tour-of-myprayerjournal-conclusion-296l)

注意:这是 8 篇系列文章的最后一篇；请参见[介绍](https://dev.to/danieljsummers/a-tour-of-myprayerjournal-introduction-jl5)中的所有内容，以及构建该软件的要求。

在这个旅程中，我们浏览了客户端代码、服务器端代码、数据库和文档。然而，开发应用程序的体验不仅仅是组合技术和技巧的总和。让我们来看看这些“经验教训”和在这个过程中形成的观点。(这篇帖子会比之前多使用很多第一人称单数代词“我”/“我”/“我的”。)

## Vue 很棒，但是…

当我尝试不同的 <abbr title="Single Page Application">SPA</abbr> 框架时，它们很有趣，但是比我预期的要多得多。然后，我遇到了 [Vue](https://vuejs.org) ，它的范例和流程就这么一拍即合。单个文件组件很棒；不用在整个网站的 CSS 文件中寻找影响组件元素的样式，这真是太好了。我只需要向下滚动！虽然我将通用 CSS 放在了应用程序的顶层组件`App.vue`中，但是该组件所做的任何独特的事情都在那里。还有各种你可以添加和使用的 Vue 感知包，它们将自己的元素/组件添加到流程中； [Element UI](https://github.com/ElemeFE/element) 、 [Bootstrap Vue](https://bootstrap-vue.js.org) 和 [Vue-Awesome](https://github.com/Justineo/vue-awesome) 是我在开发的不同阶段使用的三个。因为它是一个 JavaScript 框架，所以你也可以使用普通的 JS 包；myPrayerJournal 使用 [moment.js](https://momentjs.com) 来显示相对日期(“8 分钟前的最后一次活动”)并格式化日期以供显示。

然后……我运行了构建过程，包非常大——有几兆字节那么大！我们改变了 Vue-Awesome 的实现，只导入我们在应用程序中使用的图标(公平地说，这是项目的建议)。元素似乎也相当重。在最终发布之前，我处理的最后一个问题是移除 Bootstrap Vue，只使用直接的 HTML/CSS 进行布局和流程(这是我们将在下面探讨的另一个课程)。有关于配置 [Webpack](https://webpack.js.org) 的指南，以帮助使 moment 的包更小(并且该项目有一个开放的问题要重构，以便它对“只导入您需要的部分”范式更友好)。

这并不意味着对我到目前为止提到的任何优秀项目的抨击。当我转换到 Vue CLI v3 模板时，也是在项目接近尾声的时候，它使用了一个版本的 Webpack，该版本具有更好的“树摇动”算法。(这意味着，如果它可以确定代码永远不会被执行，那么它会将其从捆绑包中排除。)myPrayerJournal v1.0 的现代“供应商”包(带库的那个)是 283K，而遗留包是 307K 虽然这在移动设备上没有闪电那么快，但也比得上许多其他网站，而且由于页面更新是通过 API 进行的，所以一旦加载就很快了。 [<sup>1</sup>](#note-1)

第七课:对你导入的东西要聪明。

第七课:JavaScript 生态系统发展迅速。这篇文章发表于 2018 年 9 月 2 日，描述了 2016 年 9 月至 2018 年 8 月期间的发展；其中很大一部分可能已经过时了。:)

## 你可能不需要…

我们在上面提到过，这个网站最终是用简单的 HTML 和 CSS 编写的。许多更受欢迎的软件包和实用程序是为了弥补浏览器生态系统或不同浏览器供应商之间的不足而创建的。然而，随着浏览器供应商最近努力支持已发布的标准，这些包中的许多都是出于舒适和惰性的原因而使用的。和以前一样，这不是对这些项目的抨击；它们满足了明确的需求，并继续作为许多已部署的、正在执行的代码的基础。

但是，对于新的开发来说，现有的标准——及其支持——可能就足够了。有一些很棒的网站详细介绍了如何使用普通 JavaScript 或 CSS 来完成某些事情。

*   你可能不需要 jQuery
*   你可能不需要引导程序 *(对于这个，你必须自己阅读 HTML 看起来它不再托管在给定的 URL)*
*   你可能不需要 Lodash
*   [我可以用 __？](https://caniuse.com)

最后一个我用了不少。我还广泛参考了 [CSS Tricks 的“Flexbox 完全指南”](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)帖子。当我决定在没有 Bootstrap 的情况下返工布局时，我以为替换的会是 CSS Grid 然而，Flexbox 已经足够了。

第七课:如果你愿意，可以使用框架，但不要认为这是做事的唯一方式。

**第一课**:如果你想缩小你的包的大小，20-30 行你自己的代码有时可以节省 20-30K(或者更多)。

## 学围棋

> 2018 届互联网班的各位-
> 学围棋。
> 
> 如果我只能给你一个关于未来的建议，那就是
> 去吧。
> 
> –*[(向巴兹·鲁赫曼致歉)](http://www.metrolyrics.com/everybodys-free-to-wear-sunscreen-lyrics-baz-luhrmann.html)*

Go 是一种系统编程语言。它是由谷歌开发的，以帮助他们更好地利用他们的硬件。它本身支持并发处理(可以并行完成，但不同于“并行编程”)；具有固执己见的代码格式化程序；强制您处理可能出错的呼叫；而且效率极高。当 myPrayerJournal 与 Go 后端一起运行时，RAM 中的工作大小大约是 10MB。让我再说一遍，这次是带着感情- **数据库访问、HTTP 侦听、动态 web 服务的工作大小是 10MB 的 RAM！**如果你曾经分析过一个 web 服务器进程，你会知道这是多么的小。作为比较，后端的 F#/Giraffe/EF 核心版本的进程工作集在 60-80MB 之间运行，并且包括另外大约 256MB 的共享工作集内存。 [<sup>2</sup>](#note-2) (一个运行 PHP 的 Apache2 进程也可以在 256MB 范围内运行。)

为什么我要推荐一项我最终在 1.0 版发布前放弃的技术？除了“你读了最后一段了吗？！？!"简而言之，答案是“这是未来，它将改变你用其他语言编码的方式。”它迫使你处理每一件可能出错的事情，这一事实使它变得强大；但是，如果你学会用它来开发，你会发现自己比以前更全面地考虑错误处理——我这么说是因为我已经像编写快乐之路一样编写了错误处理程序。

为什么我放弃了我非常看好的技术？嗯，对于初学者来说，F#是一种让我“点击”的语言，就像 Vue 作为客户端框架一样；它的开发范式与我思考结构化代码的方式是一样的。我完成了一个使用 F#和 Giraffe 的项目(我希望它能很快开源)，这让我有信心继续尝试第三个 F# API。第三次很有魅力，对吧？)此外，虽然 Entity Framework 生成了一些非常冗长的 SQL 语句，但 EF Core 或多或少会生成我本来会写的东西，**加上**它负责填充它从数据库返回的对象。

我还发现开发过程很笨拙，尽管并不笨拙。*(他们可能不会把它作为他们的口号……)*关于`GOPATH`环境变量已经写了很多，但是一旦你进入其中，它就开始有意义了。`go get`非常擅长降低你的依赖关系，它的做法是，你可以仔细阅读源代码，看看他们到底在做什么。此外，在 Windows 上开发并不太难，但是为 Linux 构建可执行文件——在“系统”编程工作中，这是一个非常酷的特性。

**第一课**:学习围棋。

## 写下你的代码

这不是我在这个项目中学到的一课；这是我早就知道的一个。写代码有*(至少)*两个明显的好处:

*   它可以帮助你学到比你在编写代码时学到的更多的东西。作为开发人员，我们有时会忘记后退一步，看看我们已经创建的作品。如果你写它，你必须形成一个连贯的观点，这样你才能向别人解释它；这有助于你的长期发展。此外，对环境了解更多的人可以对你写的东西发表意见，这不仅有助于你学习，…
*   它有助于建立社区。如果你遇到了障碍，而社区中围绕该技术的某个人帮助你克服了它，写下你的经历意味着下一个遇到该问题的人可能不必问了；如果他们的搜索引导他们到你的文章，他们可以修改它并继续前进。如果你不能从社区获得帮助，这一点同样适用；你可能是提出这个问题/技术的人，并推动整个社区向前发展。

第七课:写你的代码；尽你所能参与你的技术社区。

如果你全程都和我们在一起——谢谢。我希望你已经学到了一些东西；我知道我做到了，不仅仅是通过我的祈祷者杂志的发展，而是通过写它的过程。当然，如果你觉得这个应用程序可以帮助你，请自便。它现在是，而且将永远是免费的，在撰写本文时，[比特獾解决方案](https://bitbadger.solutions)(以及之前的 DJS 咨询公司)已经连续 14 年没有已知的数据泄露；你的祈祷请求在我们这里是安全的。

* * *

 *有一些分块技术可以用来使初始下载变得更小，并按需加载其他部分。例如，Moment.js 对于默认的“欢迎来到我的祈祷者杂志”页面来说是不需要的。我们可以推迟加载，直到用户登录，因为杂志页面肯定需要它；我们仍然需要下载相同的数量，但是它会被分散到两个请求中。在初始下载中节省一些大小的机会仍然存在，但是 283K 刚好超过 244K 建议的包大小，所以我们继续使用它。*

 *我托管 myPrayerJournal 的服务器已经有了其他的。NET 核心进程在其上运行，所以共享内存大小已经被分配。*