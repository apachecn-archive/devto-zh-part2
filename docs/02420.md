# 重构的艺术 I:评估代码块

> 原文:[https://dev . to/making loops/the-art-of-refactoring-I-evaluating-the-code-blob-3d EC](https://dev.to/makingloops/the-art-of-refactoring-i-evaluating-the-code-blob-3dec)

[![Pizza by Tom Brown, 2011](../Images/6a216a04e58c28c6a7223eec6a2d5381.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--rvMJkSsI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://purple.pizza/public/art-of-refactoring-part-1.jpg)

你有没有遇到过一些代码，你知道它们看起来…是错误的，但是却不确定用什么策略来修复它？

也许你听说过术语*重构*，但是这又是怎么回事呢？

*重构*实际上是什么意思？

清理杂乱的代码？

改善组织和架构？

或许只是一个模糊的:*让 da 代码变得更好*？

作为开发人员，当我们经常听到一个术语或短语时(例如，[依赖注入](https://purple.pizza/why-should-you-use-dependency-injection/)、[瘦控制器](https://purple.pizza/why-should-controllers-be-thin/)、重构和单元测试)，我们知道它可能很重要，但是我们并不总是知道*为什么*或者如何最好地应用它。

我们能否将重构形式化为一个清晰的过程，可以应用于混乱的代码，并合理地保证它会在另一端得到更好的结果？

## [](#the-art-of-refactoring-series)重构的艺术系列

本文是一个由三部分组成的系列文章的开始，该系列文章介绍了一个重构代码的过程，将混乱的代码重构为您可以自豪地签入的代码。

我们不仅要看*如何*清理代码，还要看*为什么*。

为了成为更好的开发人员，我们需要理解*为什么*某些东西会成为问题，然后才能解决它。

这是一块我们可以加强的代码感知肌肉。

嘿，这就是这篇博客和时事通讯的全部意义。

在这个系列的第一部分中，我们将研究一个假想的汽车保险公司的一组理论上的业务需求，并看一看它的实现所产生的代码块。

然后，在实际修复所述代码 blob 之前，我们将讨论您可以寻找的常见棘手问题的子集，这将为我们提供开始清理工作所需的工具。

在第 2 部分中，我们将把在第 1 部分中学到的工具应用到代码 blob 中，以建立我们重构过程的第一步:*为了清晰而重构*。

我们将扮演医生的角色，考虑应用程序的整个环境、我们客户的需求、变化的可能性，并思考如何将它从一个斑点变成美丽的东西。

最后，在第 3 部分中，我们将对新阐明的代码进行最终分析，以确定我们是否需要在重构过程中更进一步:*抽象重构*。

## [](#some-business-requirements)一些业务需求

就我们的目的而言，你可以想象我们正在开发一个运行在像 GEICO 或 Progressive 这样的汽车保险网站后面的软件。

在这个应用程序中，用户将登录支付保险费。他们既可以用信用卡付款，也可以用 ACH 支票或储蓄帐户付款。他们也可以选择亲自用现金支付。

随着付款进入系统，决定汽车保险公司将需要收取便利费，以支付使用各种信用卡和 ACH 处理器的费用。

下面是随着时间的推移给予开发团队*的需求列表。*

正如在软件工程领域通常发生的那样，需求在开始时并不总是完全已知的。

流程改变了，边缘案例被遗忘了，解决方案本身会导致额外的问题。

为了模拟这种情况，假设每个要点都是在前一个需求几个月后提出的新需求。

### [](#requirements-list)需求列表

1.  所有信用卡支付都应包括统一的 3.00 美元便利费。
2.  所有 ACH 付款应包括相当于付款金额 10%的费用。
3.  现金支付不应包括费用。
4.  我们希望对设置了每月自动支付功能的用户自动生成的付款收取更少的费用。我们认为较低的费用将有助于激励这一功能。
5.  我们希望能够为某些不使用自动支付功能的用户覆盖不同金额的费用，以奖励他们有时出于不同的原因。
6.  我们发现，美国各州都有法律规定该州信用卡和 ach 的费用。
7.  我们希望信用卡支付使用分层模式，这样，低于阈值的支付金额使用固定费用，高于阈值的使用金额的百分比作为费用。
8.  我们现在希望费用覆盖机制也覆盖自动支付费用，而不仅仅是手动支付。

## [](#a-code-blob-emerges)一个代码斑点出现了…

如您所见，该特性开始时非常简单，只有基于支付方式的硬编码费用值。

然而，随着时间的推移，复杂性增加了，正如它趋向于做的那样。

开发人员没有花时间仔细地写代码。

正因为如此，费用计算代码越来越难以更改。

这是一个问题，因为公司预计便利费要求将继续扩大。

让我们看看代码…

```
public static class ConvenienceFeeCalculator
{
    public static decimal Calculate(int method, decimal amt, User user, string state, bool isAutomaticPayment)
    {
        if (isAutomaticPayment)
        {
            if (user.FeeOverride.HasValue)
            {
                return user.FeeOverride.Value;
            }

            if (method == 2) //credit cards get $3 flat fee
            {
                // return 3;
                return StateLaws.GetCreditCardFlatFeeForAutomaticPayments(state);
            }

            if (method == 3) //ACH get's a 10% fee
            {
                return amt * StateLaws.GetACHPercentageFeeForAutomaticPayments(state);
            }

            return 0;
        }

        if (user.FeeOverride.HasValue)
        {
            return user.FeeOverride.Value;
        }

        if (method == 2) //credit cards get $3 flat fee
        {
            // return 3;
            if (Settings.IsTieredCreditCardFeeFeatureEnabled)
            {
                var t = Settings.TieredCreditCardFeeThreshold;

                if (amt > t)
                {
                    return amt * Settings.TieredCreditCardFeePercentage;
                }
                else
                {
                    return Settings.TieredCreditCardFlatFee;
                }
            }
            else
            {
                return StateLaws.GetCreditCardFlatFee(state);
            }

        }

        if (method == 3) //ACH get's a 10% fee
        {
            return amt * StateLaws.GetACHPercentageFee(state);
        }

        return 0;
    }
} 
```

## [](#but-this-wouldnt-happen-to-me)但是……这不会发生在*我*身上！

随着这个特性变得越来越复杂，您可能会发现这些增强是以一种非常单一的方式加入到这个方法中的。

开发人员知道请求是什么，找到它应该去的地方，并添加它。

他们没有花太多时间考虑如何最好地将更改融入现有代码。您甚至可以看到不再适用的早期需求留下的注释。

在理想的世界中，我们试图让代码比我们发现的更好。

但是在现实世界中，时间表、开发人员技能集的差异以及明显的懒惰很容易导致您上面看到的那种代码。

但它完成了工作，这难道不是最重要的吗？

现在让我们来回答这个问题。

## [](#refactoring-phase-1-evaluation-is-it-good-enough)重构第一阶段:评估(够不够好？)

现在我们面前有了代码，我们可以开始评估它了。在我们真正把它拆开并创造出新的东西之前，让我们先来看一系列问题，这些问题将成为我们决定改变什么的基础。

这当然不是一个详尽的列表，但它将涵盖代码中常见问题的很大一部分。

理想的情况是，这些问题已经深深扎根于你的生活中，所以你不再需要考虑它们。在击键到达编辑器之前，您的代码会考虑它们。

### [](#is-it-likely-to-change)有可能改变吗？

对于这个问题，您可能需要咨询您的用户或业务分析师。他们能预见到未来需要对便利费逻辑进行额外的更改吗？

如果答案肯定是否定的，那么您可以决定，基于其他优先级，没有必要重构这段代码！

你们有些人可能会说:

> 什么？但是那个代码太恶心了，把它烧成灰烬吧，你这个傻瓜！。

虽然这里确实有工作要做，但是评估一些代码应该如何改变总是必须包括选择*别管它*。

这就是软件行业。

这是一个很好的平衡，权衡代码的理想是如此干净，以至于让鲍勃大叔流下了美丽的眼泪，还是只是把那些垃圾拿出来，让客户可以真正使用它。

有时，当代码经过多年的使用考验，并且可能永远不会改变时，您可以决定不去管它。当你可能永远也不会再碰它的时候，没有必要冒险去清理它。

然而，在我们的案例中，业务部门告诉我们，他们*确实*预计到*未来这种计算方式会有很多*变化。因为是这样，所以确保代码能够优雅地处理变更就成了更重要的事情。

知道了这一点，对于另一个以前可能没有见过这段代码的开发人员来说，更改会很容易吗？

此外，代码单元是否经过测试，保护了类的行为，从而可以在一定程度上安全地进行更改？

## [](#start-with-readability)从可读性开始

一旦我们决定这些代码可能会改变，下一步就是开始考虑当这些改变变得必要时，我们如何使我们的生活变得更容易。

为了使未来的更改更容易，我们从可读性开始。

如果代码难以阅读和理解，那么修改它将是有风险的，而且潜在的成本很高！

我们可以问哪些实际问题来揭示可读性问题？

## [](#is-the-intent-of-classes-methods-and-variables-clear-by-their-names)类、方法、变量的意图通过它们的名字清楚了吗？

用代码给事物命名本身就是一门艺术。

名字是我们的代码自我记录的方式。它可以读起来像精美的散文，清楚地解释其意图，也可以完全模糊，需要开发人员多次扫描才能弄清楚发生了什么。

好名字允许我们对代码进行推理，这样我们就可以在不破坏代码的情况下修改它。

### [](#are-method-argument-and-variable-names-written-with-nouns-that-represent-their-intent)方法参数和变量名是用代表其意图的名词写的吗？

看上面的代码，一切都做了什么，是不是很明显？

说到名字，我认为用尽可能多的字符来描述某样东西所代表的东西并不可耻。在第 2 部分中，我们将做一些改变来说明我的意思。

### 方法使用动词+名词组合来描述正在执行的动作吗？

我对方法名采取了 Bob 叔叔的立场，因为它们不应该是名词。方法本质上是一种处理行为。获取、设置、计算、排序等。

我要补充的是，如果方法参数不清楚的话，将动作的作用放在上通常会有所帮助。

这个`Calculate`方法可能比`CalculateFeeForPayment`更清楚，或者简单地称为`GetConvenienceFeeForPayment`，因为在幕后没有太多的计算。同样，类名本身可能需要改进。使用`ForPayment`后缀，读者可以流畅地假设方法参数代表支付细节。

### [](#are-their-any-magic-numbers-that-could-be-replaced-with-enumerations-or-constants)它们有没有可以用枚举或常数代替的*幻数*？

阅读上面代码的开发人员将不得不通过评论和行为假设`method == 2`代表信用卡。这个类的客户必须知道。

通过使用枚举或常量，我们可以澄清数字的含义，从而节省未来开发人员的心理处理周期。

## [](#are-method-arguments-easy-on-the-client)方法参数在客户端容易吗？

理想情况下，基于方法的名称和参数(方法的签名)，方法易于理解和使用。

这个方法对客户的要求太高了吗？

参数的类型会对客户端产生依赖性吗？我们的 calculate 方法的客户端负责提供一个完整的`User`对象来传入。[不要做依赖型懒汉！](https://purple.pizza/dependency-slob/)

这是一个合理的要求吗？

如果我们想在代码中其他不容易创建`User`对象的地方重用这个方法呢？

有什么方法可以减少所需参数的数量吗？一个方法的参数越多，阅读代码的人就必须使用越多的内存来理解和推理。

## [](#can-you-see-duplicated-logic-that-could-be-consolidated)你能看到可以合并的重复逻辑吗？

代码复制是一个问题，因为任何时候你需要改变复制区域中的一些逻辑，你必须改变它 *n* 次，其中 *n* 是复制的次数。

想象一下，如果这个应用程序在 UI 中有几个不同的位置，允许用户进行支付。如果为每个区域重新编写这个逻辑，那么每当便利费代码需要更改时，您就必须记住更改每个区域。

它发生了…相信我。

想象一下，如果每次都是不同的开发人员编写的！

在这种情况下，幸运的是，我们只有一个计算费用的静态类，但是其中仍然有许多重复。

## [](#are-the-methods-too-big)方法是否太大？

臭名昭著的*单一责任原则*说，理想情况下，类和方法应该只做一件特定的事情。

他们应该只有一个改变的理由。

此外，它们应该只处理一个抽象层次。我们将在第 2 部分讨论这意味着什么。

仅仅通过我们需要不止一句话来描述这段代码的事实，就告诉我们我们正在做不止一件事，所以这个方法太大了。

将它分解成更小的方法是有价值的，因为人类更容易理解它在做什么，这将使未来的改变更容易，并且不太可能破坏系统。

看看这段代码，你能看出它是如何由许多子任务组成的吗？所有子任务都集中在一个方法中。

## 重构的艺术第 2 部分:清晰的重构

现在我们已经讨论了一系列要问的问题，让我们将它们应用到代码 blob 中，并实际开始清理它。

在本系列的第 2 部分中，我们将*为清晰而重构*，这是我们三阶段重构过程的第二阶段。

要跟进并了解它是如何完成的，请在下面注册。文章一准备好，我就寄给你。

这不仅仅是另一份让你的收件箱塞满狗屎的时事通讯。

作为一名工程师，这是对不断进步的承诺。如果你像我一样，你不会满足于在接下来的 10 年、20 年或 30 年里用代码来破坏你的职业生涯。

让我们真正成为*精英*。

准备好马鞍！点击这里，我们将在重构的艺术系列的第二部分准备好的时候尽快把它发送给你。