# 袖手旁观你的 Lambda -克服 AWS Lambda 的局限性

> 原文：<https://dev.to/dgreene/stand-by-your-lambda---overcoming-aws-lambdas-limitations-gnn>

这个帖子最初出现在[这里](https://goo.gl/Q7FkdY)

不久前，我指出了一些[λ反模式](https://dev.to/dgreene3p/silence-of-the-lambdas---5-antipatterns-for-aws-lambda-e60)。在那篇文章之后，我想我们也想指出一些克服 AWS 作为服务 Lambda 的一些限制的技巧和诀窍。老实说，Lambda 即服务非常棒。自伸缩、模块化的代码执行是一个非常有用的工具。然而，我们确实看到了所有事物都像钉子一样的经典趋势，而 Lambda 就是金锤。Lambda 被设计成一个离散的小事件处理程序。当你开始用它做其他事情时(甚至在正常使用中)，你会开始碰到它的局限性。Lambda 有一些关键的限制。

# 5 分钟执行

这是一个让大多数人陷入困境的大问题。有趣的提示——除非你有理由不这样做——将所有功能的处理时间设置为 5 分钟。您只需为实际使用付费，所以与其惊讶于某些东西比您配置的时间长了几秒钟，不如谨慎行事。Lambda 的本质是它的目标是小的、一口大小的处理任务，有时您可能会遇到这样的情况，看似 Lambda 的一个很好的用例将会遇到这个限制，并使您非常心痛。这里有一些方法可以减轻这个限制。

### 各个击破

Lambda 一个非常常见的用例是处理一个放在 S3 上的文件。如果可能的话，我建议不要在一次 Lambda 调用中处理整个文件，而是通过调用另一个 Lambda 来分割工作，以处理一定数量的行，您非常有信心在限制内完成这些行。基本上，通过 S3 的位置，开始的行号，结束的行号，循环直到你开始每一组。或者，将记录流式传输到另一个解决方案，如 SNS 或 Kinesis，可能就足够了。请注意，如果数据负载的大小超出了您的控制范围，您仍然需要采取某种权宜之计。

### 缓存一些数据并保温

虽然这可能会导致其他问题(见下文)——在提供给所有函数容器的/tmp 分区中缓存一些数据可能会提供一种方法来减少第一次调用后的执行时间——您必须平衡是否可以构建缓存的数据，写入/tmp，然后仍然执行必要的功能——并且您将在函数的每次冷启动时付出这一代价，但是在热执行时，它可能会节省大量处理时间。为了保持它的热度，您可以安排一个 CloudWatch 预定事件来“ping”您的函数——这是一个无操作参数，可以确保容器保持活动状态，或者启动它以便预先预热功能命中。您需要在这里找到正确的平衡，以确保您不会不必要地增加额外的函数副本，但这是您可以随着时间的推移进行调整的。

### 称自己为救命稻草

如果在您的用例中，拆分数据文件的处理不起作用——假设它需要顺序处理——那么您可以利用上下文对象有效地获得“剩余时间”,一旦接近极限，就异步调用同一个 Lambda，提供文件偏移量。随后的调用跳过先前处理的行，继续进行。和任何递归一样——小心不要让自己陷入无限循环——你永远也不想解释你是如何对自己进行“拒绝钱包”攻击的。

### 调大记忆的音量

在某些情况下，增加分配的内存可能会减少处理时间——观察 CloudWatch 日志输出，了解函数的调用内存使用情况。如果峰值使用处于或接近分配的顶部，增加该数字可能会有所帮助。这可能是一种权宜之计，但实施起来非常容易。额外的好处是——如果你看到你的最大内存使用一直低于分配的内存——减少它将降低你的成本。

### 改变游戏——或者至少改变语言

不同的语言有不同的优势——然而，用编译语言构建 Lambda。Net Core、Go 甚至 Java 可能比 NodeJS 或 Python 等解释型语言在您的特定用例中表现得更好。这可能不是一个选项，但要记住。

### 带来大炮

让我们面对现实吧——会有一些场景和事件需要 5 分钟以上的时间来处理。在这个数据无止境的时代，数据文件变得越来越大，你必须处理它。尽管我是 Lambda 的粉丝，但它并不总是能解决问题。您可以选择两个主要的升级点——最直接的是将您的处理从 Lambda 转移到 Fargate 任务——无服务器容器执行可以提供 Lambda 的所有好处，而没有许多限制。这带来了更多的准备成本——但是从战略上来说，Fargate 容器可以非常好地与您现有的无服务器产品架构相吻合。第二种方法是利用 EMR、Glue 或其他服务来完成繁重的工作，只使用 Lambda 作为触发机制来确保处理流程启动。

# 请求有效载荷

下一个最有可能被赶上的项目是 Lambda 的有效负载限制——同步执行 6MB，但异步调用只有 128K。说实话，如果你在一个事件框架中传递大量的负载，那你就做错了:)。在以编程方式调用 Lambda 之前，您应该检查您的有效负载大小——因为有时您无法控制您的消息大小，您还应该知道一些解决方法。

### 【分而治之】(再次)

就像上面关于处理时间的建议一样，如果可能的话，将有效负载拆分为由单独的函数调用来处理——它们会自动缩放——因此一次拆分和传递部分有效负载不仅可以避免有效负载限制，而且如上所述，可以更快地并行运行。

### 使用一些暂存空间

这种限制只限于调用负载，而不是处理的数据，所以可以发送 S3 或数据库位置，而不是数据。我最近在处理一些事件数据，我正在处理客户数据，并将数据重新组织到一个映射中，以便进行高效的查找。为了避免在后续调用中重复这个 map 函数，我试图在有效载荷中将它传递给 Lambda 子调用。正如你所猜测的，随着时间的推移，查找映射变得太大，破坏了 Lambda 调用。我最终使用 DynamoDB 作为暂存空间，因为所需的吞吐量非常低，成本可以忽略不计，而且性能非常好！注意 DynamoDB 的项目限制是 400k——所以要记住如何使用它。我也可以使用 ElastiCache，但是我只是使用了我已经在应用程序中使用的资源。拆分数据并写到 S3 是一个更好的方法，因为您可以使用将文件放到 S3 上作为触发后续 Lambda 的机制。把你的控制机制想象成事件而不是流程，这些使用模式将在你眼前发展。

# 联网

好的——这本身并不是一个限制，但是有一些相关的限制。在 VPC 里跑 Lambdas 有一些限制。首先，函数的每个实例都将在一个容器中运行——在实例化时，该容器将被授予一个 EIP(这也显著增加了函数的冷启动时间)——并且您可能对您的 EIP 帐户有限制。其次，您只能运行您子网中可用的 IP 地址数量的函数实例。这是一个基本问题，因为您通常无法控制运行的函数实例的数量。为此，你应该只在你的 VPC 内部运行那些需要在你的 VPC 内部运行的函数，而对于那些必须在内部运行的函数，一定要将它们设计成最小化大规模并发执行的可能性。现在，您还可以为函数的最大并发调用数添加一个限制。这将导致您陷入 AWS 重试场景——并且本质上会抑制您的功能。您可能会用一组错误消息交换另一组错误消息，但是它是您可以使用的杠杆。

# 内存和磁盘限制

现在，在讨论无服务器技术时，磁盘限制可能听起来很奇怪——但是利用/tmp 驱动器空间是一种非常常见的缓存数据的技术(如上所述),这可以最大限度地减少非冷启动的执行时间。然而，它被限制在 512 MB——所以试图缓存太多会导致你的容器失败。节约使用空间，但在能帮上忙的地方使用。

内存限制是另一个因素——取决于您的代码，达到函数内存的限制可能会导致速度变慢，甚至可能导致代码崩溃。由于您是按 GB 秒计费的，您不希望过度提供您的函数，尤其是经常调用的函数，但是您也不希望达到这个限制。定期分析函数的 CloudWatch 日志输出。输出的最后一行列出了调配的内存和使用的峰值内存。从高开始，然后向下调整——试着将峰值内存使用量设定在 80%左右，以防出现意外情况，但您需要考虑内存使用量的波动性，以找到正确但不过大的标记。

# 总结

所以，最后，Lambda 有很多优点，以及它如何适应无服务器生态系统(是的，它们是不同的)，但是知道如何充分利用它取决于知道它的优势和局限性。在 3Pillar Global，我们对无服务器计算的承诺感到兴奋，无论是 Lambda、Fargate、无服务器数据库还是其他形式。如果你真的热爱无服务器，那么袖手旁观通过限制，因为毕竟，它只是一个λ。