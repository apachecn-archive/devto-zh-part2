# 在企业世界中编写文档

> 原文：<https://dev.to/xowap/writing-documentation-in-the-enterprise-world--56i4>

当我阅读[这篇关于为什么文档很重要的文章](https://dev.to/b0bai/documentation-is-imperative-for-software-developers--here-is-why-5a12)时，我发现我的团队编写文档的方式越来越好，这是分享它的好时机。

当我还是学生的时候，我曾经是网络俱乐部的主席，负责管理学生宿舍的互联网。几代人都想出了非常创新的解决方案，基本上没有预算，但什么都没有记录，许多项目最终都是从头开始。在某个时候，我制定了一个“没有文件就没有产品”的规则，这个规则非常有效！几年后，我们仍然会参考维基，甚至在我们的职业生活中寻找有用的提示。

在 docs-void 世界呆了一段时间后，现在我有了自己的团队，我决定把这条规则带回来。人们需要一些时间来适应，最重要的是需要有人来执行规则。尽管如此，它实际上是可行的，这是非常重要的一点。

## 决定内容

文档中应该包含哪些内容的界限相当模糊，但我认为这是一个好文档应该包含的内容。

首先，我们来考虑文档不应该是什么。你们中有人从 Javadoc 中学习过如何使用库吗？详尽的记录每一个微小的点是没有用的，我们不是他妈的机器人，可以一次吸收所有的东西。另一方面，被誉为优秀文档的项目是像 [Vue.js](https://vuejs.org/v2/guide/) 或 [Requests](http://docs.python-requests.org/en/master/) 这样的东西，它们以概述和温和的走查开始。

很明显，每个项目都应该有一个编辑过的文档，作为进一步做某件事情的重点。

现在我们不要完全抛弃 Javadoc。拥有一份精确的文档来告诉你一个函数到底做什么是很有用的。但不仅如此，尤其是在私有 API 中，你可能会奇怪**为什么**有这个函数。这样你可以后退一步，看看整个系统中的功能。

综上所述，我们希望:

*   一个全球性的，突出和编辑的文件
*   关于每个功能的作用和**为什么**在这里的精确参考

## 正确的格式

存储这些文档是另一回事。让我们尽可能使它没有摩擦！

### 参考单据

参考文档非常简单。有太多的 docstrings、JSDocs、Javadoc 和其他 Doxygens。所以让我们用它作为参考文档。就我个人而言，我甚至懒得生成它们，因为 IDE 可以直接读取它们，并通过简单的键盘快捷键提供文档的内容。

### 概述文档

源代码管理工具(至少是 GitLab 和 GitHub)现在可以呈现 markdown 文件，所以让我们利用这一点。

所有文档都以回购根目录下的`README.md`文件开始，其中大致包含以下信息:

*   项目描述
*   软件依赖，可能是要安装在服务器上的包
*   运行它所需的环境变量
*   必须计划的 Cron 作业
*   特定功能文档的链接

正如你所猜测的，每个特性都有一个特定的`.md`文件来解释它是如何工作的。您可以放入这些文件的内容包括

*   独立于代码库的其余部分，解释您的功能的各种机制
*   提供要查看的主要类/函数的名称
*   列出 cron 作业并解释它们的作用
*   解释数据模型
*   给出各种任务的 API 调用示例

## 保持最新

最大的反对文档的论点是“它没有用，因为它最终会过时”。事实上，由于现在大多数团队都采用了一种奇妙的创新，保持更新变得很简单:拉请求。

由于文档与代码紧密耦合(共享相同的提交)，所以您可以建立一个非常简单的规则:文档的合并与代码不一致。

为了帮助解决这个问题，我创建了一个拉/合并请求模板，它提出了以下清单:

*   新类/函数/CSS 规则上的文档字符串
*   修改类/函数/CSS 规则时更新了文档字符串
*   在`README.md`中提及正在合并的内容
*   单独文件中的特定功能文档
*   `gdpr.yml`中的 GDPR 数据收集分析和文档编制

我想在此强调两点:

1.  是的，我们确实记录了 CSS 规则。这里比任何地方都没有必要在 docstring 中说“给#f00 中的文本着色”。相反，文档解释了为什么这些规则在这里，它们解决了什么问题，它们如何与其他规则相关(相对定位等)，并给出了非显而易见的选择(又名黑客)的理由
2.  `gdpr.yml`文件是我们对 GDPR 注册表的实现。这是另一篇文章的主题，但是强调所有欧洲公司都有义务维护这个注册是有用的。因为数据操作是由代码完成的，所以在更改代码时保持数据更新是一个好主意。

## 从一个没有记录的项目开始

这种方法的好处还在于，您可以将它应用到一个完全没有文档记录的项目中。你所需要做的就是写一个像样的`README.md`文件，它会给你如何运行这个项目的基本知识。然后，您可以在编写文档时逐渐增加特性，而不必一次编写所有的文档。

随着时间的推移，当你开发新的特性时，你要么替换旧的特性，要么自然地记录它们，因为你必须在你的文档中把它们解释为对其他特性的介绍。

## 付出了什么代价

让我们来分解一下这种方法的成本:

*   **工具** -无，您已经有工具，没有设置要做
*   编写 -老实说我不知道，但是如果我必须给出一个大概的估计，比如说 10%的编码时间花在编写文档上
*   **改进代码** -因为你写文档，你会发现一些代码可以分解或重新组织得更有逻辑，你可能会花 5%的编码时间这样做

现在的好处，有点难以衡量:

*   更少的错误，因为在每个拉请求时后退一步有助于你仔细考虑你的代码，并提醒你所有你忘记处理的小事
*   新人进入项目的时间少得多
*   少 WTF 看别人的代码，既然知道*为什么*东西在这里。并且您不会因为认为它们没有用而试图删除它们(因此在没有注意到的情况下破坏了产品中的一个主要特性)
*   但是你也知道什么时候你可以删除代码，因为你知道它为什么在这里
*   这当然意味着更少的技术债务
*   最后，你现在记得这个项目，但是如果你停止工作几个月，我保证你会忘记大部分

总的来说，拥有一个最新的、有意义的文档会给你带来一个压力小得多的代码库。你赢得的时间很难估计，但基本上项目越大，赢得的时间就越多。代价是你不得不花一个**线性**的时间写你的文档，以避免技术债务和困惑的后辈的**指数**时间损失。

所以，在你的项目变得太大之前尽早开始，并保持这份文件是最新的！