# UX API:他们称之为前端的后端

> 原文:[https://dev . to/peibolsang/they-call-it-back end-for-frontend-51nh](https://dev.to/peibolsang/they-call-it-backend-for-frontend-51nh)

我一直在和一位远在地球另一端的同事(我在西班牙，他在悉尼)就现代水疗和 RESTful APIs 的问题交换电子邮件和意见。事情是这样的，我会尽量简短。

# [](#the-problem-space)问题空间

随着[微服务](https://www.martinfowler.com/articles/microservices.html)架构方法的普及，我们见证了一种基于细粒度、对话式 RESTful APIs 设计系统的趋势。这就是，构建 API 驱动的 spa。

1.  这些 API 不满足 UI 需求。句号。它们旨在公开业务流程和数据。这是 API 开发者所关心的，相信我，UX 不是 RESTful APIs 设计过程的一部分。
2.  这意味着我们可能最终会为一个单一的 UI 特性拥有许多 API，更糟糕的是，许多 UI 特性没有 API 或者没有资源表示。
3.  我们不能建立一个新的 API 或者设计一个新的资源表示，因为那需要太长的时间。因此前端开发人员最终构建了一个超级定制的解决方案，编排了太多 API 调用来模仿他们需要的资源表示。这会导致性能低下或不安全的代码。

因此，UI 开发人员需要在他们构建的 API 驱动的应用程序中考虑用户体验和功能需求。当然，应该是他们，因为他们了解两个世界:UI 和 API。别担心，在这些团队中，额外的敏捷应该是一项技能。

[![Fig1](../Images/25ece28ec6a2d86002a6500fb32d7c08.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--AWta7H6u--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/800/1%2AWu33RiyVkIBfJgXqmcFoVg.png)

# [](#what-can-we-do)我们能做什么？

因此，当我们都理解问题陈述时，我们可能不同意解决方案。人们可能会想“嘿，不要试图煮沸海洋，有一些问题你不能在前端解决”或“这是一个组织问题”。我倾向于同意。当建立一个数字平台时，这意味着许多事情，其中之一是每个人都需要将思维模式转变为数字:营销需要实现一种数字产品，其中需要最终用户的最小交互；架构需要提供数字化微服务；商业分析师需要转向数字思维；设计师需要意识到我们已经不是 2002 年了，拥有 50 个字段的前端可能不太适合数字产品和架构。

因此，从组织的角度尝试解决方案，一些公司正在创造一个新的角色:数字工程师。这是一个在前面描述的所有涉众之间充当联络人的角色。在这个特定的用例中，将是告诉设计师和业务分析师他们的工作有一些限制的人，这些限制是由架构中可用的微服务和资源表示的调色板给出的。这样，我们确保 UX 符合 API 规范，但我不确定像这样的隔离创新是否是一个好方法。特别是通过促进来自一个非常面向过程的，甚至是官僚的世界的约束(即数据被表示和暴露的方式)

# 哦，那更好，我的朋友

另一方面，我在悉尼的同事正在推动一些更务实的东西。他说，“嘿，我知道，我们不能改变世界，但我们可以在前端做些事情，至少让我们的生活更轻松”。我担心的是，我们通过构建一个一刀切的超级解决方案，过度设计了前端。但是他的观点开始有意义了:

1.  可用性。80%的时候，当我们开始构建前端时，API 还没有准备好。我们需要找到一种机制来帮助我们不用等待就能开始。
2.  稳定。我们不能告诉企业，他们期望的 UI 和 UX 是不可能的，因为数据表示和公开的方式存在限制。

然后他提出了一些东西，过了一段时间，我发现这些东西被贴上了前端模式的[后端的标签。本质上，这意味着我们可以在 UI 中创建 RESTful APIs 的外观，供 UI 使用，模拟特定 UI 的特定后端。](https://samnewman.io/patterns/architectural/bff/)

1.  可用性。在我们构建前端时，数据接口是可用的，因为这个组件是由 UI 开发人员在前端实现的。这个中间人将为 UI 提供数据和资源的新表示。数据也将通过新的 GraphQL 接口公开。通过这种方式，我们不需要点击多个端点来获取我们需要的数据，因为 UI 开发人员现在将只从新模式中选择需要的字段。
2.  稳定。BFF 提供了我们正在寻找的 UI 所需的资源模型和数据。这个 facade 组件将**从 API (SoR 数据)中获取** REST 资源，**将**它们改编成更符合 UI 需求的中间表示，**通过新的 GraphQL 接口将**它们暴露出来，最终映射到视图模型(UI 组件)。所有这些都发生在前端，所以在某种意义上，这就像拥有 UX API 一样。是的，我们这里说的是前端 API。这也意味着不需要在 UI 中实现复杂且性能不佳的逻辑来从不匹配的 RESTful APIs 中收集显示所需的数据。

[![Fig1](../Images/e0fae5859fd9c6b081aec1efa7455686.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--k8QZZjDL--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/800/1%2AXyZVKlVFhcb6Ba_492418A.png)

当然，这是我们对模式的解读。有人可能认为 BFF 是另一个服务器端组件或中间件，但这就是模式的魔力:我们给它我们想要的实现。

我们可能会尝试这种模式。仅仅是因为，正如伊恩·罗宾逊在 2006 年的这篇文章中提到的(该死的，这些东西总是能保存很久)，一个 API 的成功取决于它的消费者:

*“消费者驱动的提供商合同的衍生性质为服务提供商和消费者之间的关系增加了一个他律方面。也就是说，提供商受制于源自其边界之外的义务。这绝不影响它们实现的基本自主性；它只是明确了一个事实，即服务的成功取决于它们被消费的情况。*

说得好，伊恩，谢谢。

当然，这不是灵丹妙药，每个解决方案都取决于问题的空间和环境，所以对于其他人来说，采用组织方法可能更容易。正如 Martin Fowler 所说，这是一个一般性的帖子，正因为如此，它受到了一般性建议谬误的限制。