# 组件如何赢得“框架战争”

> 原文:[https://dev . to/Hugo _ _ df/how-components-won-the-framework-wars-5fko](https://dev.to/hugo__df/how-components-won-the-framework-wars-5fko)

> React vs Angular vs Vue:为什么不重要。

## 2018 年标志着 JavaScript 疲劳和“框架战争”的结束

在进入 React、Angular 或 Vue 之前，典型的前端/JavaScript 开发人员职业生涯通常涉及一些 jQuery 和相关插件。

在经历了 React、Vue 和 Angular 之后，它们似乎以相似的方式解决了相似的问题。它们的不同之处在于设置体验和最佳实践。在很多方面，这些框架/库的心智模型已经融合到组件模型中。

这对开发者来说是一个胜利，因为心智模型对所有最广泛的框架都是一样的。这意味着从一个地方到另一个地方不再像过去那样是个大挑战。

如果你来这里是为了阅读更全面的评论，并对 Vue、React 和 Angular 生态系统有更多的背景知识，我推荐以下来自去年夏天的内容:

[**Angular vs React vs Vue:2017 对比**](https://medium.com/unicorn-supplies/angular-vs-react-vs-vue-a-2017-comparison-c5c52d620176)

## 组件和组成模型

框架的所有 3 个工作单元都是组件。对于 React，你扩展了`React.Component`，在 Angular 中，我们设置了一个模块，用`@NgModule`和`@Component`装饰器包装一些组件，在 Vue 中，你使用`Vue.component()`在 Vue 实例上注册你的组件。

一切都基于组件，它们相互嵌套，在它们之间传递数据，等等。

作为一个组合模型，组件应该是应用程序中自包含的部分或“位”,您可以在更具体的上下文中重用它们。他们允许的最棒的事情是一种封装逻辑的方法，提供 API 保证:你将 x、y 和 z 传递给这个组件，你将从中获得 foo 行为，组件内部做的任何事情都是它自己的事。

## 状态和突变

所有这些框架解决的问题是以某种方式将数据绑定到 DOM。例如，这是开发人员在 jQuery 中必须手动完成的事情。

这意味着最基本的应用程序(使用框架/库)将拥有某种状态。模型，Vue，角和反应自己(即。而不是用户库)实际上完全不同。

Angular 认为状态应该是可变的。它还提供了跨组件和模块传递服务的能力，通常通过依赖注入将服务保持为准单例。因此，开发人员可以轻松地编写一个数据共享容器来更新相关组件，通常是通过服务返回可观察对象和存储订阅的组件。

Vue 使用反应系统通知应用程序的其他部分状态发生了变化。这给了它一个性能优势，因为使用`this.property`实际上是在引擎盖下使用一个 setter，在那个 setter 中，
Vue 可以在任何需要的地方发送更新，而不只是到处发送。构成要在模板中呈现的状态的首选机制是计算属性。

React 使得不可变状态的概念在 JavaScript 生态系统中更加广泛。状态不是通过突变(例如使用`state.myProperty`)来更新的，而是用要更新的数据来调用组件的`setState`方法。

然而，组件提供的封装意味着当使用所有这些框架时，状态管理细节之间的差异并不明显。

所有 3 个框架中的优选模式是避免直接改变从父节点传递的数据，而有利于通知所述父节点应该发生状态改变。

## 数据传递

基于组件的应用程序简化了数据传递模式:通信只在父节点与子节点之间进行，反之亦然。

在 React 中，传递 props 来传递数据，还传递允许您从子对象更新父对象状态的函数。

在 Angular 中，`Input`和`Output`绑定在组件中定义，在模板中绑定。`Output` s 的行为很像事件，因为它们是由孩子发出的，而由父母倾听。

在 Vue 中，道具从父节点传递到子节点，子节点可以将事件发送回父节点。

在所有这些框架中，在“兄弟”组件之间传递数据的方法都是以相同的方式解决的，即在树中找到最近的公共父组件，并在那里封装状态和状态更新。

## 生命周期，更新和重新渲染

如果本地状态*或* props(输入)改变，则 React、Vue 和 Angular 中的组件更新。如果您不在本地存储任何状态，您可以强制组件只在它们的属性改变时才改变。

功能组件为 React 和 Vue 执行此操作，而`ChangeDetection.OnPush`变化检测策略可用于 Angular。

在每个框架中，组件生命周期以不同的方法名称提供。

这三者都提供了一个 mounted/dismount，它指的是组件在 DOM 中被初始化，并且不再需要它。还可以监听数据和道具的更新，这通常会触发模板的重新呈现。

## 全球门店

当应用程序需要组件树中相距甚远的组件中的共享数据时，就该使用存储了。

这最初是由脸书的 flux 架构的 React 生态系统普及的。Flux 包括将`actions`传递给商店，商店知道如何根据动作类型更新商店的状态。

在 React 中选项有 redux 或 MobX，Vue 有官方支持的 Vuex，Angular 有 ngrx/store。

因此，所有这些框架都支持这种单一的全局存储模式。不同之处在于，这些库来自 Angular 和 React 的生态系统，而 Vue 的商店是由核心团队支持的。

这些“goto”存储解决方案的设计反映了使用这些框架编写代码的一些惯用方法:在 Vue 中，它是基于对象和 getter/setter 的，在 Angular 中，它是可观察的，组织良好的效果等等。React 的选择最多，“只要 JavaScript”+纯函数(redux)、反应式状态观察器(MobX)甚至是普通的 JavaScript 对象(未声明)。

## 类型和数据验证

验证应用程序中的数据类型有助于开发和调试。

JavaScript 不是静态类型的，所以在通过多个组件和函数传递数据时跟踪类型会变得很困难。

Vue 和 React 通过适当类型验证解决了这个问题。一个组件和它的道具是用类型化的道具定义的，在开发模式下，库会检查传递的道具是否与设置的道具类型相匹配。这些注释和检查在应用程序/库的生产版本中被剥离。因此，在性能至关重要的地方，检查的开销就消失了。

Angular 没有这样一个合适的验证机制，但是它有一个优点，那就是通常用 TypeScript 编写。拥有静态类型的输入和输出的开发体验非常棒。然而，这些类型在构建时会被剥离。在运行时检测类型不匹配是不可能的。大多数这种类型不匹配最终发生在 IDE 或编译器中。

React 和 Vue 还可以被工具化以利用类型系统，如 TypeScript 和 Flow，这为它们提供了与在 Angular 和 TypeScript 中开发类似的保证。

## 模板、样式和工装

围绕应用程序文件结构的最佳实践在 Angular、Vue 和 React 之间有所不同。

Angular 倾向于每个模块/组件一个文件夹，用来存放您的类型脚本、模板和样式文件。模板和样式可以内嵌在 Angular 组件中，但是最好的做法是使用单独的文件。对于大型单页应用程序来说，这是一个好主意。

Vue 被称为“渐进式框架”,因为它根据正在开发的应用程序的规模提供不同的功能。在最简单的情况下(使用 CDN 和 script 标签全局包含 Vue)，鼓励内联编写模板。Vue 还提供了一个 CLI 和与 webpack 等构建工具集成的包。在这种环境下编写组件的首选方式是单文件组件，即包含模板、脚本和样式标签的文件。Vue-loader 将模板和脚本部分一起编译成 JavaScript，并在构建时将样式标签的内容提取到样式表中。

在 React 中，因为逻辑和 JSX 模板不能分开，所以只有风格的问题。有多种答案:分别处理样式，使用 webpack 将您的`import ‘my.css'`语句提取到样式表中，或者使用 CSS-in-JS 库。

对于小项目，Vue 有更好的人机工程学，对于最大的企业用例，Angular 有最多的结构，React 介于两者之间，组件结构留给开发人员练习，但推荐使用构建工具(至少编译 JSX)。

## 测试和服务器端渲染

Angular 中的单元测试主要是在 TypeScript 组件类上完成的。为了能够测试模板逻辑，需要一个完整的 DOM 环境(比如一个无头浏览器)。

在 React 和 Vue 中，由于使用了虚拟 DOM 和渲染函数，可以分别使用 [enzyme](https://github.com/airbnb/enzyme) 和 [vue-test-utils](https://github.com/vuejs/vue-test-utils) 来测试模板逻辑。

组件的浅层渲染意味着只渲染组件子组件的第一个“层”，即。子组件中的所有组件都没有被完全评估(呈现为 HTML)，而是作为`ComponentName`留在组件树中。

这种无需完整 DOM 环境的呈现能力对于 JavaScript 应用程序的服务器端呈现也很有用。Vue 拥有 [vue-server-renderer](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer) 包和 React[React DOM server](https://reactjs.org/docs/react-dom-server.html)。

这允许节点应用程序将水合 Vue 或 React app 转换为标记(HTML ),通常作为第一次页面加载的 HTML 响应发送回来。

Angular 具有类似的编译和渲染能力，尽管这些功能较少“嵌入到现有的应用程序中”,更多的是“用这些工具构建”,因为当使用允许服务器端渲染的 [Angular Universal](https://angular.io/guide/universal) 或 Angular 的 [AoT 编译器](https://angular.io/guide/aot-compiler)将模板编译成 JavaScript 和渲染函数时，必须谨慎使用框架的一些功能。

## 结论

如今，在基于组件的框架上加倍努力，并在它们之间无缝迁移是非常可能的。

组件的概念以及如何使用它们构建应用程序是相同的，特定于框架的名称在框架间有清晰的映射。

React、Vue 和 Angular 之间唯一的区别是它们所基于的哲学和基本原理。React 非常依赖开发人员从生态系统中挑选他们喜欢的工具(或者在必要时构建它们)。Vue 很乐意从一个简单的`script`标签开始，但也提供了一个连贯的工具集来构建更大的应用
(单个文件组件、Vuex、vue-router、文档甚至是一个[风格的指南](https://vuejs.org/v2/style-guide/))。Angular 的目标是大型应用程序，并立即带来了大量的结构和冗长(使用 TypeScript ),以及深入拥抱 rxj 和 Observables。

最初发表于 2018 年 4 月 22 日 codewithhugo.com。