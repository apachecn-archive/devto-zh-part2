# Unix 环境下的程序设计:综述

> 原文：<https://dev.to/shubheksha/program-design-in-the-unix-environment-3j0>

[![](../Images/090da9b3c9697d5f0692d5efb140fe2e.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--LM0bJI8r--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1600/0%2AO-H_d2lDRBmnCgFG.jpg) 
[功劳](http://www.adamalthus.com/blog/2013/04/04/the-composable-enterprise/)

今天我们来看看 Pike 和 Kernighan 在 1983 年出版的《[Unix 环境下的程序设计](http://harmful.cat-v.org/cat-v/unix_prog_design.pdf)》一书。

这篇文章以列举 Unix 成功的原因开始，并且是对 Unix 哲学及其好处的评论。它通过举例和讨论程序偏离 Unix 哲学的权衡来做到这一点。

Unix 成功的原因:

1.  可移植性:内核和应用程序是用 C 语言编写的，因此它们可以从一个系统移植到另一个系统，而不需要用特定于该系统的汇编语言重写。
2.  相同的操作系统运行在不同的硬件上，所以用户已经很熟悉了，当新的硬件发布时，不必重新学习。
3.  尽管硬件发生了变化，但供应商可以在每台机器上安装相同的软件。
4.  这个系统并不太大，也不容易修改，因为所有的东西都是用 c 写的。
5.  它提供了一种新的理念，基于通用工具的使用，这些工具可以很好地完成一件事情，并且可以组合起来完成一项特定的任务，而不是创建只服务于一个目的的巨大的整体工具。

本文认为工具的使用和设计是密切相关的——它们是如何结合在一起的是本文的主题。

然后，本文深入研究了`cat`——用于连接和打印文件的 Unix 命令行实用程序——它将输入复制到输出。输入通常是一个或多个文件的序列或标准输入。输出是文件或标准输出。

`cat`的主要目的是作为一个连接文件的工具。它可以与管道(`|`)操作符结合使用，通过输出重定向进一步增强和扩展它的效用。

另一方面，其他系统试图将一堆相关的功能转储到一个命令中，这违背了 Unix 的理念。它还创建了可能对其他程序有用的功能锁定。

Unix 方法的优势:

1.  外壳和它可以调用的程序提供了对系统设施的统一访问。对于每个命令，shell 以相似的方式扩展文件名参数。因为有了管道，我们不需要每个命令都处理输入的前后处理。
2.  当功能被很好地分离时，增长是容易的。

示例:添加`(反引号)操作符是为了将一个程序的输出转换为另一个程序的输入，而不需要对 shell 解释的任何其他程序进行更改。shell 调用的所有程序都会自动获得这个特性。如果每个需要这个特性的程序都去解释它，那么就很难实施统一性和进行进一步的实验，因为每个新的想法都会影响所有想要使用它的程序。

然而，在`cat`的未来版本中，引入了许多新的选项，比如打印行号和不可打印的字符。

作者认为，与其将这些选项添加到`cat`本身，还不如使用现有的程序或者创建新的程序。例如，行号功能可以通过使用`pr`来提供。然而，没有程序允许打印不可打印的字符，因此保证创造一个新的。

> 这样的修改混淆了`cat`的工作是连接文件和在终端上显示文件这种常见的特殊情况。一个 UNIX 程序应该做好一件事，把不相关的任务留给其他程序。`cat`的工作是收集文件中的数据。收集数据的程序不应该改变数据；`cat`因此不该变换其输入。

每当我们把一个东西分成多个程序时，我们就牺牲了一些效率。但是由于`cat`通常不带任何选项，所以让最常见的情况最有效是有意义的。

> 单独的计划并不总是比更广泛的选择更好；哪个更好要看问题。每当一个人需要一种执行新功能的方法时，他就面临着是增加一个新选项还是编写一个新程序的选择(假设没有一个可编程工具能方便地完成这项工作)。做出选择的指导原则应该是每个程序做一件事。选项被适当地添加到已经具有正确功能的程序中。如果没有这样的程序，那么就需要一个新的程序。在这种情况下，应该使用程序设计的通常标准:程序应该尽可能通用，它的默认行为应该与最常见的用法相匹配，它应该与其他程序相配合。

* * *

让我们考虑另一个问题:处理快速终端线路。如何处理`cat`滚离屏幕顶部的输出？

有两种方法:

1.  告诉每个命令有关终端的属性，以便它做正确的事情
2.  编写一个只处理终端而不修改其他程序的命令

让我们考虑两种方法的例子:`lsc`和`ls`，它们打印出目录中的文件列表。

`lsc`根据输入改变它的输出——它在屏幕上以柱状方式显示列表，以便输出到终端时 o/p 合适，而`ls`在一列中显示所有内容。

> 通过将单列输出保留到文件或管道中，`lsc` 确保了与像`grep` 或`wc` 这样的程序的兼容性，这些程序希望每行打印一个内容。这种根据目的地对输出格式的特别调整不仅令人不快，而且是独一无二的没有标准 UNIX 命令具有这种特性。

作者认为列功能总体上是有用的&不应该仅仅被锁在`lsc`中，其他程序无法访问。他们主张一个不同的计划，其主要工作是集中。

> 类似的推理为数据流出屏幕(列化或非列化)这一普遍问题提出了一个解决方案:一个单独的程序接受任何输入，并一次在一个屏幕上打印出来。这样的节目现在已经广为流传，以 pg 等名字命名。该解决方案不影响其他程序，但可以用于所有程序。通常，一旦基本特性正确，程序就可以用选项来增强。

* * *

基于前面的例子，作者还讨论了一些不同的情况，其中一些功能被锁定在一个特定的程序中，比如终端中的输入历史，这作为一个中心服务会更好。所有的交互式程序都可以从中受益。

他们的结论是，在 Unix 中用特性/选项扩充现有命令是不可取的，这违背了它的基本原则，即让一个程序做好一件事，而几个这样的程序可以组合起来完成一个更复杂的任务。

> 在 UNIX 系统上解决问题的关键是识别正确的原语操作，并将它们放在正确的位置。UNIX 程序倾向于解决一般问题，而不是特殊情况。在一个非常宽松的意义上，程序是正交的，跨越了要做的工作的空间(尽管由于历史、方便或效率的原因有相当多的重叠)。函数被放在它们能发挥最大作用的地方:不应该在每个产生输出的程序中都有一个分页器，就像不应该在每个使用文件名的程序中都有文件名模式匹配一样。
> 
> UNIX 不需要的一点是更多的特性。它之所以成功，部分原因是因为它有一些很好的想法，这些想法能够很好地协同工作。仅仅增加功能并不能让用户做事情更容易，只会让手册更厚。在正确的地方使用正确的解决方案总是比随意的黑客攻击更有效。