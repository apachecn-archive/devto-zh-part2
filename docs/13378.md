# 测试不应该是可选的

> 原文:[https://dev . to/plain programmer/tests-should-not-be-optional-1ak](https://dev.to/plainprogrammer/tests-should-not-be-optional-1ak)

[![](../Images/6911267e93e5d437034558b85113b6d2.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--fPlWN7M3--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://james.thomps.onl/wp-content/uploads/2019/07/006d5-10mgkhw1_ulkzlbps07mq3q.jpeg)

我认为，任何没有伴随自动化测试的代码都应该被认为是有内在缺陷的。当我们写代码时，我们头脑中有一些关于适用性的概念。测试是一种表达这些概念的方式，其他人可以运行和检查，而不必钻研我们的实际实现。测试提供了一种方式来交流我们写的代码，关于它做什么，而不仅仅是它如何做一些事情。虽然“代码做什么”和“代码如何做某事”这两个概念看起来几乎是一回事，但我相信区分它们是有价值的，这种区别就是为什么我认为没有测试的代码应该被认为是有内在缺陷的。

### **什么对什么**

当我们写代码的时候，我们是说明性的，我们尽可能精确地陈述我们选择的语言允许的，或者暗示的，我们希望计算机在完成一些工作时采取的步骤。我们的实现是对在给定时间点完成某事的最佳方式的判断。这种判断包含了从编写代码的上下文中得出的假设。当我们致力于一个特定的实现时，我们是在断言我们正在编写的代码应该能够工作。但是，我们编写的代码只做了最少的保证，而它所做的那些保证是高度上下文相关的。

然而，当我们写测试的时候，我们正在走出指令性的东西，并且有希望从事一些更具描述性的东西。这是一个充满希望的前景，因为编写测试可以简单地强化实现中固有的规定，并且在许多情况下，这些规定代表了糟糕的测试。当我写测试的时候，我想描述我的软件的行为，而不是它如何完成那个行为。差别很微妙，但很重要。例如，让我们以这段实现代码作为起点:

[https://gist . github . com/planacer/3 FAE ab 94 B0 DD 5b 09 EB 8 a 2 ef 48 af 2 ba 45](https://gist.github.com/plainprogrammer/3faeab94b0dd5b09eb8a2ef48af2ba45)

有几种方法可以测试这个代码，但是我只想比较两种方法。我断言，第一个例子是一个糟糕的测试，因为它依赖于内部实现细节:

[https://gist . github . com/plain programmer/7 FCE 0 abdf 4 f 0027155 a 314 c 964900868](https://gist.github.com/plainprogrammer/7fce0abdf4f0027155a314c964900868)

这组测试虽然提供了完整的覆盖范围，但是与该方法如何完成其工作有着不可分割的联系。如果在任何时候这个方法的具体内部发生了变化，那么测试也需要改变。相比之下，在我看来，以下示例测试要好得多:

[https://gist . github . com/plain programmer/0 cf 56d 3 b 3 Fe 02 e 6 c 96d 0 e 09 b 95 fedb 01](https://gist.github.com/plainprogrammer/0cf56d3b3fe02e6c96d0e09b95fedb01)

这些测试，特别是最后两个，关注的是这个方法封装的行为，如果需要一个服务对象，或者一些其他的模式，大部分的改变被隔离到测试的上下文中，而不是测试本身，甚至可以从这个模型中重构出来。通过关注行为，内部实现可以在不需要改变测试代码的情况下发生更大的变化。只有当代码的整体行为发生变化时，测试用例才需要显著地变化。强调描述代码做什么，而不是如何做，这就是测试的价值所在。如果测试只是加强了实现中已经规定的东西，那么它们只是另一层耦合和脆弱性，需要在未来解决。好的描述性测试的重点应该放在一些代码引起的效果上。测试应该回答这个问题，代码导致了什么变化，而不是代码是如何完成变化的。

#### **光是药方就是缺陷**

回到我最初的主张，没有附带测试的代码应该被认为是有缺陷的:如果没有围绕一个可以重复和自动运行的软件的某些方面的描述，关于系统行为的确定性，在任何一层，都将总是植根于假设。虽然人工 QA 可以提供软件行为符合预期的确定性，但是这种确定性完全依赖于我们对人的可靠性的确信程度。

测试代码也充满了假设，但是这些假设是代码的一部分，因此需要检查、调整或删除。测试允许控制在任何给定的时间点有什么样的假设，这是手工 QA 不能很好地实现的。良好的人工 QA 需要细致的文档来实现可重复性，并且其规模总是受到人员配备的限制。但是，如果人工 QA 发现可以用自动化测试来编码，那么整个过程可以变得更加高效、可靠和可重复。

因此，虽然自动化测试不能取代所有形式的人工 QA，但是它们可以增加测试过程的可靠性，并且通常还可以提高速度。但是，人工 QA 和系统级测试的描述性只是问题的一个方面。较低层次的测试，比如单元和其他功能测试，如上所述，也从自动化测试中获益。虽然只通过公共接口来测试整个系统是可能的，但是测试组成该系统的单元通常要快得多，并且可以在开发期间导致更快的反馈周期。这种执行时间和反馈的速度使得较低级别的测试能够帮助驱动设计决策，指导重构，并从一开始就防止一些错误进入生产环境。

如果我们对一个软件的唯一确定性来自于它的实现方式，那么我们的确定性是难以置信的不可靠。处方是建立在假设的基础上的，这些假设最多是隐含的，对任何现在或未来目的的适用性也是完全假定的。假设的复合性与只使用规定形式的软件有关，这不是一个特性，而是一个严重的缺陷，补救措施并不十分困难或昂贵。

#### **哪怕是一点点描述也能灌输信心**

我已经走进了几个未经测试或测试不佳的代码库，我最初的冲动变得难以置信地一致:我试图弄清楚如何添加测试。如果一个系统正在运行，那么它满足某种程度的适用性，但有时它是试探性的。在这样的代码库中，我更喜欢编写尽可能高级别的测试。这牺牲了测试运行时的速度来换取覆盖率和抗脆弱性。更高层次的集成或验收测试总是运行得更慢，并且覆盖更多的单元测试。但是，它们也倾向于更容易以捕捉效果而不是方法的方式来编写。因此，它们可以帮助我们更快地建立对系统的信心。

给系统增加这种清晰的描述和信心的诀窍是知道从哪里开始。这最好由非技术涉众来回答。请他们指出系统做了哪些对业务最有价值的事情，或者如果不正确会带来最大风险的事情。然后让他们定义当前的预期行为。然后围绕该系统编写测试，以匹配所提供的描述。

这种方法通常会暴露现有实现中的缺陷。每当这种情况发生时，记下它们并将证据封装在未决的测试用例中，但是要集中精力捕捉系统当前在做什么。一旦系统的现有效果被捕获，然后把你关于错误行为的发现带给涉众，讨论它们的相对重要性，以确定何时或者是否需要解决它们。这样做的好处是，你将围绕这些问题进行一定程度的测试，这将让你知道你什么时候修复了它们，如果那个时候到来的话。

#### **将代码覆盖放到它的位置**

我反复提到代码覆盖率。我非常重视代码覆盖率。对于我积极维护的所有项目，我的目标是 100%覆盖 C0。原因有两个:信心和可测试性。拥有 100%的代码覆盖率并不能保证我的代码没有缺陷，甚至是正确的；但这确实意味着我有以某种方式测试我的每一行代码的测试。这意味着我所有的代码都可以运行。这也意味着我所有的代码都是可测试的，可以通过测试来实现。

但是，代码覆盖率不是目标。写得不好的测试也可以达到高水平的覆盖率，所以测试覆盖率证明是非常少的。但是，如果正确理解，它可以是一个有用的指标。我强烈推荐 Martin Fowler 对主题的简短评论，以获得健康的视角。

### 信心&清明

围绕代码编写测试的目标是提供期望的行为和系统效果的信心。这是测试的首要目标。第二个目标是以一种清晰方式向他人传达想要的行为。好的代码是清晰的代码，测试也是如此。测试是代码的另一种形式，因此它们也应该是清晰的。但是，重要的是要记住不同类型的清晰性:你的实现代码应该清楚地传达你的软件如何做某事，而测试代码应该清楚地传达你的软件做什么。通过这种方式，测试为理解软件系统以及它为什么有价值提供了另一个有用的角度。