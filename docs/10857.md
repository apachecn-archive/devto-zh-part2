# 使用 PostgreSQL 的零依赖发布/订阅系统

> 原文:[https://dev.to/_gdelgado/zero-dependancy-pub-子系统-带-postgresql-4pi8](https://dev.to/_gdelgado/zero-dependancy-pub--sub-system-with-postgresql-4pi8)

[![Elephants](../Images/119b4d2f0d4b886b54ff111dda86b8fe.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--twUr_cRp--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/rg9oq2qeigwna2smax7s.jpg)

胡琛在 Unsplash 上拍摄的照片。

在 [Setter](https://setter.com/) 我们有第二代 API 服务器，它处理:

*   来自内部软件的 API 请求
*   来自面向客户的 iOS 和 Android 应用的 API 请求
*   来自第三方服务的 Webhook 请求

这都是很典型的东西。

## 与我们控制之外的系统通信

在处理这些请求的过程中，我们必须与第三方服务进行沟通。

一个例子是客户订单批准，其中我们必须向客户发送电子邮件来确认订单，并向用户提供某种反馈循环。

在这种情况下，流程看起来像:

1.  从移动应用程序接收 API 请求
2.  处理 API 请求(这将涉及进行一些数据库插入/更新)
3.  将 API 请求发送给第三方电子邮件提供商(在我们的案例中，我们使用了[邮戳](http://postmarkapp.com/)，我们强烈建议使用它)

通过直接从我们的系统发出 API 请求，我们现在已经降低了成功的确定性，并且引入了不完整的状态。例如，邮戳(我们使用的电子邮件服务提供商)可能因为日常维护而关闭，因此对他们服务的请求可能会在不可预知的时间失败。这引入了一个不完整的状态，因为客户将永远不会收到电子邮件，让他们知道他们的订单确实被处理和确认。

这种事情在我们公司发生过几次。

## 消除对第三方服务的依赖

目前，我们正在进行内部 RFC 流程，以决定如何将第三方服务从我们的系统核心中分离出来。

我在这个特别的 RFC 上起了带头作用(尽管在我写它的时候我从我的同事那里得到了很多指导)，在这篇文章中我讨论了它的大部分。

我在我们公司建议的是，我们利用我们已经拥有的技术(PostgreSQL & NodeJS)以便不增加系统复杂性——而不是使用诸如 RabbitMQ 之类的工具(并不是说 RabbitMQ 不好)。

通过使用 PostgreSQL 的`LISTEN` / `NOTIFY`特性，您拥有了拥有高性能、容错发布/订阅系统所需的一切。

我创建了一个实现这个系统的示例应用程序——欢迎反馈！

[https://github.com/gDelgado14/pg-pubsub](https://github.com/gDelgado14/pg-pubsub)

以下是示例项目的相关部分(可以在 README.md 中找到):

**在发布/订阅**中实现“发布”

`migrations`文件夹包含实现系统发布方面所需的模式/触发器/和 SQL 函数。

更具体地说，创建一个`db_events`表来存储发送到发布子系统的消息。此外，还有一个触发器，它在任何对`db_events`的插入中执行一个 sql 函数。

**在发布/订阅**中实现“订阅”

在`src/services/client.ts`中，我使用`pg`模块来:

1.  连接到数据库
2.  监听从 postgres 中调用的“pub_sub”事件(我已经在迁移中定义了它)
3.  调用与系统中可能发生的各种事件相关联的任何异步函数。

* * *

现在你可以订阅任何你想要的活动。您可以在代码中定义事件。如果您使用静态类型的语言(这就是我在 TypeScript 中实现这个例子的原因),那么它真的很有帮助，这样您的消息有效负载总是与有效负载所关联的消息保持一致。

您可以在`src/services/client.ts`中看到一些示例通道/有效载荷组合。例如，如果您发布一条`sms`消息，那么进出发布/订阅系统的有效负载将始终是`{ msg: 'some string' }`

该系统的另一个令人惊叹的方面是，您可以选择在不同的机器/运行时/语言上运行您的订阅逻辑。这是因为是 postgres 将消息发送到运行时。在我的例子中，我保持了简单，发布和订阅都在同一个应用程序中进行，但是如果你不想这样的话，就不必这样了！

## 优雅地处理失败

有一件事我还没有想够，那就是如何处理消息处理失败。

例如:假设我在发布/订阅系统中发布了一条`email`消息，订阅者试图通过向邮戳发送 API 请求来处理该消息，但是邮戳关闭了。我应该如何最好地管理它？

我认为实现指数后退重试可能是正确的方法。

很想听听你对此的想法！