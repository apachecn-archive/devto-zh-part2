# 4 常规生活 JavaScript 代码气味(带 RxJS)

> 原文：<https://dev.to/hdennen/4-regular-life-javascript-code-smells-with-rxjs-5d0c>

### 大众`init`法

这通常是(但不总是)订阅顺序问题的结果。

例如:如果一个服务正在订阅一个 ReplaySubject，但是需要实际获取可能还没有准备好的数据，那么 subscribe 调用通常被放入一个 init 方法中，以确保在第一个`.next()`被调用之后`.subscribe()`被调用。

虽然这解决了直接的排序问题，但它并没有解决为什么排序一开始就是一个问题。为什么有可能在调用第一个`.next()`之前就订阅了 ReplaySubject？为什么会打破东西？为什么可观察对象是一个回放主体？

这种味道的另一个原因是同级或级间依赖。

示例:服务 A 通知服务 B 和服务 C，但服务 C 需要服务 B 对服务 A 的响应的结果对象。因此，服务 C 的 subscribe 调用放在 init 方法中，服务 A 的 Observable 成为 ReplaySubject。\_(ツ)_/

### 属性检查

99%的情况下，这是为了解决方法在不应该被调用时被调用的情况。

示例:`.unsubscribe()`在属性上被调用，但该属性上没有订阅。

添加属性检查将停止任何堆栈跟踪，但它不能解决底层的设计问题。为什么有可能在订阅任何内容之前就调用`.unsubscribe()`？这是潜在结构性问题的征兆吗？

### 旗帜

虽然 Angular 已经诱使我们相信标志与它们的 [NgIf 指令](https://angular.io/api/common/NgIf)是可以接受的，但没有其他情况会不糟糕地结束(这种情况也有可能)。

标志不可缩放。如果您添加了第二个标志，您现在就有了不是两个，而是四个潜在的状态来影响分支逻辑。O(n)表示圈复杂度。

标志需要在正确的时间切换。时间是这里的关键词。标志引入了另一个层次的顺序来控制流，虽然在开始时可能是微不足道的，但它会很快失去控制。

### 早退

这一次可能会有所反弹。是的，很方便。不，它不会造成任何直接伤害。但是如果这个函数什么都不会做，为什么它会被调用呢？

这通常表明上游分支逻辑存在缺陷或缺失。

示例:主题 A 有订户 X、Y、z。A 在`.next()`调用中的有效负载是布尔型的。如果布尔值分别为 true、false 和 true，x、Y 和 Z 的响应方法会提前返回。

假设目标 A 正在广播。间隔 200ms，每分钟有效载荷为假。虽然这导致了大量不必要的电话，但它也创造了一种模式，当你只需要在一段时间内得到通知时，订阅一些东西是可以的。

问题不在于提前回报本身，而在于它能隐瞒什么。与属性检查非常相似，它会隐藏堆栈跟踪，但不会解决或显示任何结构问题。