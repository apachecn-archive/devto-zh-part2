# 测试驱动开发的常见神话和误解

> 原文:[https://dev . to/Mr Larson 2007/common-myths-and-misconcepts-of-test-driven-development-jcn](https://dev.to/mrlarson2007/common-myths-and-misconceptions-of-test-driven-development-jcn)

这是我在 dev.to 上的第一篇帖子！我已经考虑做这件事有一段时间了，我终于有了一个足够好的想法来和大家分享。现在让我们言归正传。我喜欢使用测试驱动开发，已经用了好几年了。我觉得是每一个开发者最起码要熟悉和了解自己擅长解决什么问题的技术。

在过去的一周里，我读了这篇文章[https://blog . use journal . com/lean-testing-or-why-unit-tests-is-bad-than-you-think-b 6500139 a 009](https://blog.usejournal.com/lean-testing-or-why-unit-tests-are-worse-than-you-think-b6500139a009)。虽然我喜欢这个想法，我们应该仔细看看我们如何测试，我们使用什么样的测试，作者似乎对 TDD 非常消极。甚至在文章的评论部分，对 TDD 和单元测试的敌意仍然存在。我过去也看过类似的博文和文章。这些经验与我从单元测试和 TDD 中所看到的有很大的不同。很明显，对于 TDD 有一些误解和误解。一部分原因是出于好意的人试图教导他人，而在他们的热情中，他们给人们留下了不好的印象。其他人则是误解了 TDD 是什么。所以今天我想回顾一下这些关于 TDD 的误解和神话，并帮助人们认识到 TDD 不应该受到许多人的指责。

## [](#you-must-have-100-code-coverage)你必须有 100%的代码覆盖率！

我认为大多数人获得这种想法的地方是来自 TDD 的第一条规则或步骤，你必须从一个失败的单元测试开始，只有当你有一个失败的测试时，你才被允许编写任何生产代码。很多人认为你必须有 100%的代码覆盖率，因为没有测试就没有代码！但这是错误的。有些情况下，TDD 并不适合。一个例子是在应用程序的前端 GUI 上工作。有一些代码很难测试，但是写起来很简单。因此，在这些情况下，我们不会编写单元测试，而是隔离那些很难测试的代码，这样我们就可以测试所有其他的东西。

马丁·福勒的这篇关于测试覆盖率的文章([https://martinfowler.com/bliki/TestCoverage.html](https://martinfowler.com/bliki/TestCoverage.html))提出了一些很好的观点。高代码覆盖率并不意味着你的代码是高质量的。如果我们将代码覆盖率作为目标而不是工具，我们可能会以大量无用的测试结束，这些测试提高了我们的代码覆盖率，但对改善事情没有什么帮助，最终可能会使事情变得更糟。在上面的文章中，马丁·弗劳尔指出了这一点:

> 像编程的大多数方面一样，测试需要深思熟虑。TDD 是一个非常有用的工具，但肯定不足以帮助您获得好的测试。如果你测试的很好，我希望覆盖率在 80%或 90%以上。我对任何类似 100%的东西都持怀疑态度——它闻起来像是有人写测试来取悦覆盖率，但却没有考虑他们在做什么。

## [](#you-dont-need-to-do-any-up-front-design)你不需要做任何前期设计！

许多人听说，如果你遵循 TDD，你所有的编码问题都将得到解决！如果你只是按照这些步骤，你的代码会设计得很好，不需要做任何前期设计！其他人抱怨 TDD 造成了损害，因为在追求可测试性的过程中，他们觉得代码有太多的层次，或者只是为了测试而被迫做一些事情。

事实是，无论有没有 TDD，你都可以写出设计良好的软件。仅仅因为你遵循 TDD 并不意味着你的代码会被很好的设计或者你的代码会被很差的设计。你是开发人员/工程师。当编写任何代码时，我们必须花一些时间预先考虑如何组织代码，如何构建应用程序的主要部分，以及它们如何相互通信。

TDD 擅长的是，一旦你至少有了你想去哪里的想法，它会指引你前进，你可以在结束写大量代码之前测试这些想法。它也迫使你不断地自我检查你的工作，看看是否有任何模式出现，可能会改变你最初提出的设计。你甚至会意识到你的设计行不通，你需要重新开始。

我们 TDD 阵营中的许多人经常提倡使用依赖注入来允许我们控制在测试中使用什么依赖，并允许我们将模拟或存根注入到我们正在测试的代码中，以便测试运行得更快。但是这是 TDD 的要求吗？不，唯一的要求是测试运行速度快，并且您可以在自己的计算机上可靠地运行它们。TDD 中没有说我们不能在混合的事物中进行集成或其他类型的测试。关键是你可以控制如何设计和布局你的代码。TDD 只是允许你不断地自我反思和重构你的代码。

这里的另一个问题是，你不需要设计你的测试。这也是错误的，你需要把生产代码和测试代码放在一起。罗伯特·马丁(Robert Martin)写了一篇关于测试中设计的必要性的伟大博文([http://blog . clean coder . com/uncle-bob/2017/03/03/TDD-Harms-architecture . html](http://blog.cleancoder.com/uncle-bob/2017/03/03/TDD-Harms-Architecture.html))。这篇文章中有一段很棒的引言:

> 是的。没错。需要设计测试。设计原则适用于测试，就像它们适用于常规代码一样。测试是系统的一部分；它们必须按照与系统其他部分相同的标准进行维护。

Robert Martin 继续指出，许多 TDD 演示显示了单元测试和产品代码之间直接的一对一关系。事实上，许多从 TDD 开始的人都在模仿这种测试。这里的问题是，如果我们沿着这条路走下去，它将会以与测试高度耦合的代码结束，并且将会使以后修改事情变得很痛苦。所以测试，就像我们的产品代码一样，需要仔细考虑来避免这些问题。

## 如果我使用 TDD，我只需要单元测试！

许多人认为，如果你使用 TDD，你就不需要集成测试或任何其他类型的测试。单元测试对你来说没什么问题。我们在使用 TDD 时编写的各种测试对解决逻辑问题有很大帮助，并确保代码像开发人员期望的那样工作。他们没有做的是，当你把所有事情都联系在一起的时候，给你看问题。它们不会向您显示您遗漏了一个需求，或者您对一个现有的需求做出了错误的假设。

许多使用 TDD 已经有一段时间的人知道 TDD 擅长什么，不擅长什么，并认识到单元测试只是工具箱中的一个工具，我们还必须有验收测试、集成测试和端到端测试，以真正清除应用程序中所有可能的问题。这些测试中的任何一种都可能被过度使用和滥用。作为工程师，我们有责任为手头的工作选择正确的测试。我们是发布代码的人，由我们来选择合适的测试级别，这样当我们改变一些东西时，不会破坏其他东西，我们有信心事情会成功。

这里有一个很好的例子来说明为什么只依赖单元测试不是一件好事，这个例子来自于史蒂夫·弗里曼和纳特·普莱斯的测试指导下的面向对象软件的发展:

> Nat 曾经被带到一个从一开始就使用 TDD 的项目中。该团队一直在编写验收测试，以捕捉需求并向他们的客户代表展示进展。他们已经为系统的类编写了单元测试，并且内部是干净的和容易改变的。他们已经取得了很大的进展，客户代表已经在通过验收测试的基础上签署了所有实现的特性。
> 
> 但是验收测试并不是端到端的——它们实例化系统内部对象并直接调用它们的方法。该应用程序实际上什么也没做。它的入口点只包含一个注释:
> 
> T2`//TODO implement this`

Side point 是一本很棒的书，它解释了如何在现实世界的软件项目中使用所有级别的测试。读得好！

## 如果你不使用 TDD，你就是一个糟糕的开发人员/工程师！

由于许多 TDD 支持者的热情，当看到他们为领导 TDD 欢呼时，许多人嘴里会有一种不好的味道。事实是，没错，没有 TDD，你也能写出测试良好、设计良好的代码。我只是认为没有 TDD 会更难做到。另一方面，在遵循 TDD 的同时，您仍然可以编写设计糟糕、令人困惑的混乱代码。

还要考虑到这样一个事实，即要适应 TDD 需要大量的时间和练习。许多开发人员已经在没有 TDD 的情况下工作了很多年。如果我出现并强迫他们开始使用它，他们将会远离他们的舒适区并犯很多错误。就我个人而言，我花了几年时间才明白过来。由于各种原因，一些开发人员真的没有时间这样做。我认为如果你有时间，这是非常值得的投资。同时，我们也需要成为现实主义者，并意识到没有一种真正的编码方式。有一段时间我开始这样想，但我意识到真正重要的是结果。代码容易理解吗？代码是否在需要的地方得到了很好的测试，所以我不害怕改变它？如果需要的话，我们能轻易改变它吗？这是现实世界，我们必须讲道理。

## [](#conculsion)结论

我希望这能消除对 TDD 的一些误解。许多人对别人如何将这强加给他们或他们是如何被介绍到这的方式有着不好的品味。同样，在我们热衷于让别人知道 TDD 有多棒的时候，我们忘记了 TDD 社区中的许多人通过经验和向他人学习而学到的其他东西。记住 TDD 只是一个工具，就像我们用来编写代码的任何其他工具一样有用。