# ä½¿ç”¨ Actix-Web ä½¿ç”¨ rust éªŒè¯ Web å¾®æœåŠ¡-å®Œæ•´æ•™ç¨‹ç¬¬ 2 éƒ¨åˆ†

> åŸæ–‡:[https://dev . to/mygnu/auth-web-microservice-with-rust-using-actix-web-complete-tutorial-part-2-k3a](https://dev.to/mygnu/auth-web-microservice-with-rust-using-actix-web---complete-tutorial-part-2-k3a)

###### åŸè´´äº [gill.net.in](https://gill.net.in)

è¿™ä¸ªå¸–å­ç°åœ¨å·²ç»è¿‡æ—¶äº†è¯·é˜…è¯»æ›´æ–°ç‰ˆæœ¬ [Auth Web Microservice with rust ä½¿ç”¨ Actix-Web 1.0 -å®Œæ•´æ•™ç¨‹](https://gill.net.in/posts/auth-microservice-rust-actix-web1.0-diesel-complete-tutorial/)

##### æ¬¢è¿å›åˆ°æ•™ç¨‹çš„ç¬¬ 2 éƒ¨åˆ†

åœ¨ç¬¬ä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬æˆåŠŸåœ°å»ºç«‹äº†æˆ‘ä»¬çš„æˆæƒå¾®æœåŠ¡çš„æ‰¹é‡åŸºç¡€ã€‚å¦‚æœä½ çš„åº”ç”¨ç¨‹åºæ­£åœ¨è¿è¡Œï¼Œå¹¶ä¸”åˆ°ç›®å‰ä¸ºæ­¢æ²¡æœ‰å‡ºç°é”™è¯¯ï¼Œé‚£ä¹ˆæ­å–œä½ ã€‚å¦‚æœä½ è¿˜æ²¡æœ‰çœ‹ç¬¬ä¸€éƒ¨åˆ†çš„è¯ï¼Œæ¥çœ‹çœ‹å§ã€‚æœ¬æ•™ç¨‹çš„å®Œæ•´ä»£ç åœ¨ [Gitlab](https://gitlab.com/mygnu/rust-auth-server/tree/master) master åˆ†æ”¯ä¸Šã€‚

##### æ˜¯å¦éªŒè¯ç”¨æˆ·é‚®ç®±ï¼Ÿ

ä»ç¬¬ä¸€éƒ¨åˆ†å¼€å§‹ï¼Œæˆ‘ä»¬ç°åœ¨æœ‰äº†ä¸€ä¸ª as æœåŠ¡å™¨ï¼Œå®ƒä»è¯·æ±‚ä¸­è·å–ä¸€ä¸ªç”µå­é‚®ä»¶åœ°å€ï¼Œå¹¶å‘å‡ºä¸€ä¸ªå¸¦æœ‰é‚€è¯·å¯¹è±¡çš„ JSON å“åº”ã€‚åœ¨ç¬¬ä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘è¯´è¿‡æˆ‘ä»¬ä¼šç»™ç”¨æˆ·å‘ä¸€å°ç”µå­é‚®ä»¶ï¼Œç»è¿‡ä¸€äº›æ€è€ƒå’Œåé¦ˆï¼Œæˆ‘ä»¬ç°åœ¨å°†è·³è¿‡è¿™ä¸€éƒ¨åˆ†(æ³¨æ„ç¬¬ä¸‰éƒ¨åˆ†)ã€‚æˆ‘ä½¿ç”¨çš„æœåŠ¡æ˜¯ sparkpostï¼Œä½ ä½œä¸ºæœ¬æ•™ç¨‹çš„è¯»è€…å¯èƒ½æ²¡æœ‰ä»–ä»¬çš„å¸æˆ·(å°‘é‡ä½¿ç”¨æ˜¯å…è´¹çš„)ã€‚

**è­¦å‘Š:æœªç»é€‚å½“çš„ç”µå­é‚®ä»¶éªŒè¯ï¼Œè¯·å‹¿åœ¨ä»»ä½•çœŸæ­£çš„åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨æ­¤å˜é€šæ–¹æ³•ã€‚**

##### å·¥ä½œåŒº

ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ¥è‡ªæœåŠ¡å™¨çš„ http å“åº”æ¥éªŒè¯ç”µå­é‚®ä»¶ã€‚åˆ›å»ºç”µå­é‚®ä»¶éªŒè¯çš„æœ€ç®€å•çš„æ–¹æ³•æ˜¯è®©æˆ‘ä»¬çš„æœåŠ¡å™¨ä½¿ç”¨æŸç§é€šè¿‡ç”µå­é‚®ä»¶å‘é€åˆ°ç”¨æˆ·ç”µå­é‚®ä»¶çš„ç§˜å¯†ï¼Œå¹¶è®©ä»–ä»¬ç‚¹å‡»å¸¦æœ‰ç§˜å¯†çš„é“¾æ¥è¿›è¡ŒéªŒè¯ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¥è‡ªé‚€è¯·å¯¹è±¡çš„`UUID`ä½œä¸ºç§˜å¯†ã€‚å‡è®¾å®¢æˆ·åœ¨ç”¨ uuid `67a68837-a059-43e6-a0b8-6e57e6260f0d`è¾“å…¥ä»–ä»¬çš„ç”µå­é‚®ä»¶åæ”¶åˆ°ä¸€ä¸ªé‚€è¯·ã€‚

æˆ‘ä»¬å¯ä»¥å‘é€ä¸€ä¸ªè¯·æ±‚ï¼Œåœ¨ url ä¸­ç”¨ä¸Šé¢çš„`UUID`æ³¨å†Œä¸€ä¸ªæ–°ç”¨æˆ·ã€‚æˆ‘ä»¬çš„æœåŠ¡å™¨å¯ä»¥è·å–è¯¥ id å¹¶åœ¨æ•°æ®åº“ä¸­æ‰¾åˆ°é‚€è¯·å¯¹è±¡ï¼Œç„¶åå°†åˆ°æœŸæ—¥æœŸä¸å½“å‰æ—¶é—´è¿›è¡Œæ¯”è¾ƒã€‚å¦‚æœæ‰€æœ‰è¿™äº›æ¡ä»¶éƒ½ä¸ºçœŸï¼Œæˆ‘ä»¬å°†è®©ç”¨æˆ·æ³¨å†Œï¼Œå¦åˆ™å‘é€ä¸€ä¸ªé”™è¯¯å“åº”å›æ¥ã€‚**ç°åœ¨ï¼Œæˆ‘ä»¬å°†æŠŠé‚€è¯·å¯¹è±¡è¿”å›ç»™å®¢æˆ·ç«¯ä½œä¸ºä¸€ç§è§£å†³æ–¹æ³•ã€‚**ç”µå­é‚®ä»¶æ”¯æŒå°†åœ¨**ç¬¬ 3 éƒ¨åˆ†**ä¸­å®ç°ã€‚

##### é”™è¯¯å¤„ç†å’Œ`From`ç‰¹è´¨

Rust æä¾›äº†éå¸¸å¼ºå¤§çš„å·¥å…·ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒå°†ä¸€ç§é”™è¯¯è½¬æ¢æˆå¦ä¸€ç§ã€‚åœ¨è¿™ä¸ªåº”ç”¨ç¨‹åºä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸åŒçš„å®¢æˆ·ç«¯è¿›è¡Œä¸€äº›æ“ä½œï¼Œå³ä½¿ç”¨ diesel ä¿å­˜æ•°æ®ï¼Œä½¿ç”¨ bcrypt æ•£åˆ—å¯†ç ç­‰ã€‚è¿™äº›æ“ä½œå¯èƒ½ä¼šè¿”å›é”™è¯¯ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦å°†å®ƒä»¬è½¬æ¢æˆæˆ‘ä»¬è‡ªå®šä¹‰çš„é”™è¯¯ç±»å‹ã€‚æ˜¯ä¸€ç§å…è®¸æˆ‘ä»¬è½¬æ¢çš„ç‰¹æ€§ã€‚ç‚¹å‡»é˜…è¯»æ›´å¤šå…³äº`From`ç‰¹è´¨[çš„ä¿¡æ¯ã€‚é€šè¿‡å®ç°`From`ç‰¹å¾ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`?`æ“ä½œç¬¦](https://doc.rust-lang.org/std/convert/trait.From.html)[ä¼ æ’­è®¸å¤šä¸åŒç±»å‹çš„é”™è¯¯](https://doc.rust-lang.org/book/second-edition/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator)ï¼Œè¿™äº›é”™è¯¯å°†è¢«è½¬æ¢ä¸ºæˆ‘ä»¬çš„`ServiceError`ç±»å‹ã€‚

æˆ‘ä»¬çš„é”™è¯¯åœ¨`errors.rs`ä¸­å®šä¹‰ï¼Œè®©æˆ‘ä»¬é€šè¿‡ä¸º`From` uuid å’Œ diesel é”™è¯¯æ·»åŠ  impls æ¥å®ç°ä¸€äº›`From`ç‰¹å¾ï¼Œæˆ‘ä»¬è¿˜å°†ä¸ºæˆ‘ä»¬çš„ ServiceError æšä¸¾æ·»åŠ ä¸€ä¸ª`Unauthorized`å˜é‡ã€‚æ–‡ä»¶çœ‹èµ·æ¥å¦‚ä¸‹:

```
// errors.rs
use actix_web::{error::ResponseError, HttpResponse};
use std::convert::From;
use diesel::result::{DatabaseErrorKind, Error};
use uuid::ParseError;

#[derive(Fail, Debug)]
pub enum ServiceError {
    #[fail(display = "Internal Server Error")]
    InternalServerError,

    #[fail(display = "BadRequest: {}", _0)]
    BadRequest(String),

    #[fail(display = "Unauthorized")]
    Unauthorized,
}

// impl ResponseError trait allows to convert our errors into http responses with appropriate data
impl ResponseError for ServiceError {
    fn error_response(&self) -> HttpResponse {
        match *self {
            ServiceError::InternalServerError => HttpResponse::InternalServerError().json("Internal Server Error, Please try later"),
            ServiceError::BadRequest(ref message) => HttpResponse::BadRequest().json(message),
            ServiceError::Unauthorized => HttpResponse::Unauthorized().json("Unauthorized")
        }
    }
}

// we can return early in our handlers if UUID provided by the user is not valid
// and provide a custom message
impl From<ParseError> for ServiceError {
    fn from(_: ParseError) -> ServiceError {
        ServiceError::BadRequest("Invalid UUID".into())
    }
}

impl From<Error> for ServiceError {
    fn from(error: Error) -> ServiceError {
        // Right now we just care about UniqueViolation from diesel
        // But this would be helpful to easily map errors as our app grows
        match error {
            Error::DatabaseError(kind, info) => {
                if let DatabaseErrorKind::UniqueViolation = kind {
                    let message = info.details().unwrap_or_else(|| info.message()).to_string();
                    return ServiceError::BadRequest(message);
                }
                ServiceError::InternalServerError
            }
            _ => ServiceError::InternalServerError
        }
    }
} 
```

å¤ªå¥½äº†ï¼éšç€æˆ‘ä»¬çš„å‘å±•ï¼Œè¿™äº›éƒ½ä¼šå˜å¾—å¾ˆæ–¹ä¾¿ã€‚

##### è·å¾—ä¸€äº›å¸®åŠ©

æˆ‘ä»¬æœ‰æ—¶éƒ½éœ€è¦ä¸€äº›å¸®åŠ©ã€‚åœ¨å°†å¯†ç å­˜å‚¨åˆ°æ•°æ®åº“ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å¯¹å…¶è¿›è¡Œå“ˆå¸Œè¿ç®—ã€‚Reddit rust ç¤¾åŒºä¸Šæœ‰ä¸€ä¸ªå…³äºä½¿ç”¨ä»€ä¹ˆç®—æ³•çš„å»ºè®®ã€‚`argon2`è¿™é‡Œæ˜¯æš—ç¤ºã€‚æˆ‘åŒæ„è¿™ä¸ªå»ºè®®ï¼Œä½†æ˜¯ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘å†³å®šä½¿ç”¨`bcrypt`ã€‚é¡ºä¾¿è¯´ä¸€ä¸‹`bcrypt`ç®—æ³•åœ¨ç”Ÿäº§ä¸­è¢«å¹¿æ³›ä½¿ç”¨ï¼Œbcrypt crate æä¾›äº†ä¸€ä¸ªéå¸¸å¥½çš„æ¥å£æ¥æ•£åˆ—å’ŒéªŒè¯å¯†ç ã€‚

ä¸ºäº†å°†ä¸€äº›å…³æ³¨ç‚¹åˆ†å¼€ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæ–°æ–‡ä»¶`src/utils.rs`å¹¶å®šä¹‰äº†ä¸€ä¸ªå¦‚ä¸‹çš„å¸®åŠ©æ•£åˆ—å‡½æ•°ã€‚

```
//utils.rs
use bcrypt::{hash, DEFAULT_COST};
use errors::ServiceError;
use std::env;

pub fn hash_password(plain: &str) -> Result<String, ServiceError> {
    // get the hashing cost from the env variable or use default
    let hashing_cost: u32 = match env::var("HASH_ROUNDS") {
        Ok(cost) => cost.parse().unwrap_or(DEFAULT_COST),
        _ => DEFAULT_COST,
    };
    hash(plain, hashing_cost).map_err(|_| ServiceError::InternalServerError)
} 
```

æ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬è¿”å›äº†ä¸€ä¸ª`Result`å¹¶ä½¿ç”¨ map_error()æ¥è¿”å›æˆ‘ä»¬çš„è‡ªå®šä¹‰é”™è¯¯ã€‚è¿™æ˜¯ä¸ºäº†å…è®¸æˆ‘ä»¬ç¨åè°ƒç”¨è¿™ä¸ªå‡½æ•°æ—¶ä½¿ç”¨`?`æ“ä½œç¬¦(å¦ä¸€ç§è½¬æ¢é”™è¯¯çš„æ–¹æ³•æ˜¯ä¸º bcrypt å‡½æ•°è¿”å›çš„é”™è¯¯å®ç°`From`ç‰¹å¾)ã€‚

ç°åœ¨ï¼Œè®©æˆ‘ä»¬å°†ä¸€ä¸ªæ–¹ä¾¿çš„æ–¹æ³•æ·»åŠ åˆ°ä¸Šä¸€ç¯‡æ•™ç¨‹çš„`models.rs`ä¸­å®šä¹‰çš„`User`ç»“æ„ä¸­ã€‚æˆ‘ä»¬è¿˜ç§»é™¤äº† **remove_pwd()** æ–¹æ³•ï¼Œå–è€Œä»£ä¹‹çš„æ˜¯æˆ‘ä»¬å°†å®šä¹‰å¦ä¸€ä¸ªæ²¡æœ‰å¯†ç å­—æ®µçš„ç»“æ„`SlimUser`ã€‚æˆ‘ä»¬å®ç°äº†`From` trait æ¥ä»ç”¨æˆ·é‚£é‡Œç”Ÿæˆ **SlimUser** ã€‚è¿‡ä¸€ä¼šå„¿ï¼Œå½“æˆ‘ä»¬å¼€å§‹ä½¿ç”¨å®ƒæ—¶ï¼Œä¸€åˆ‡éƒ½ä¼šå˜å¾—å¾ˆæ¸…æ¥šã€‚

```
use chrono::{NaiveDateTime, Local};
use std::convert::From;
//... snip
impl User {
    pub fn with_details(email: String, password: String) -> Self {
        User {
            email,
            password,
            created_at: Local::now().naive_local(),
        }
    }
}
//--snip
#[derive(Debug, Serialize, Deserialize)]
pub struct SlimUser {
    pub email: String,
}

impl From<User> for SlimUser {
    fn from(user: User) -> Self {
        SlimUser {
           email: user.email
        }
    }
} 
```

åˆ«å¿˜äº†åœ¨ä½ çš„`main.rs`é‡ŒåŠ ä¸Š`extern crate bcrypt;`å’Œ`mod utils`ã€‚
å¦ä¸€ä¸ªæˆ‘åœ¨ç¬¬ä¸€éƒ¨åˆ†å¿˜è®°çš„æœ‰è¶£çš„äº‹æƒ…æ˜¯ç™»å½•æ§åˆ¶å°ã€‚è¦å¯ç”¨å®ƒï¼Œå°†ä»¥ä¸‹å†…å®¹æ·»åŠ åˆ°`main.rs`

```
extern crate env_logger;
// --snip

fn main(){
    dotenv().ok();
    std::env::set_var("RUST_LOG", "simple-auth-server=debug,actix_web=info");
    env_logger::init();
    //--snip
} 
```

##### æ³¨å†Œç”¨æˆ·

å¦‚æœæ‚¨è¿˜è®°å¾—ä¸Šä¸€ä¸ªæ•™ç¨‹ï¼Œæˆ‘ä»¬ä¸º`Invitation`åˆ›å»ºäº†ä¸€ä¸ªå¤„ç†ç¨‹åºï¼Œç°åœ¨è®©æˆ‘ä»¬ä¸ºæ³¨å†Œç”¨æˆ·åˆ›å»ºä¸€ä¸ªå¤„ç†ç¨‹åºã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä¸€äº›æ•°æ®åˆ›å»ºä¸€ä¸ª struct `RegisterUser`,å…è®¸æˆ‘ä»¬éªŒè¯é‚€è¯·ï¼Œç„¶åä»æ•°æ®åº“åˆ›å»ºå¹¶è¿”å›ä¸€ä¸ªç”¨æˆ·ã€‚

åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶`src/register_handler.rs`å¹¶å°†`mod register_handler;`æ·»åŠ åˆ°ä½ çš„`main.rs`ä¸­ã€‚

```
// register_handler.rs
use actix::{Handler, Message};
use chrono::Local;
use diesel::prelude::*;
use errors::ServiceError;
use models::{DbExecutor, Invitation, User, SlimUser};
use uuid::Uuid;
use utils::hash_password;

// UserData is used to extract data from a post request by the client
#[derive(Debug, Deserialize)]
pub struct UserData {
    pub password: String,
}

// to be used to send data via the Actix actor system
#[derive(Debug)]
pub struct RegisterUser {
    pub invitation_id: String,
    pub password: String,
}

impl Message for RegisterUser {
    type Result = Result<SlimUser, ServiceError>;
}

impl Handler<RegisterUser> for DbExecutor {
    type Result = Result<SlimUser, ServiceError>;
    fn handle(&mut self, msg: RegisterUser, _: &mut Self::Context) -> Self::Result {
        use schema::invitations::dsl::{invitations, id};
        use schema::users::dsl::users;
        let conn: &PgConnection = &self.0.get().unwrap();

        // try parsing the string provided by the user as url parameter
        // return early with error that will be converted to ServiceError
        let invitation_id = Uuid::parse_str(&msg.invitation_id)?;

        invitations.filter(id.eq(invitation_id))
            .load::<Invitation>(conn)
            .map_err(|_db_error| ServiceError::BadRequest("Invalid Invitation".into()))
            .and_then(|mut result| {
                if let Some(invitation) = result.pop() {
                    // if invitation is not expired
                    if invitation.expires_at > Local::now().naive_local() {
                        // try hashing the password, else return the error that will be converted to ServiceError
                        let password: String = hash_password(&msg.password)?;
                        let user = User::with_details(invitation.email, password);
                        let inserted_user: User = diesel::insert_into(users)
                            .values(&user)
                            .get_result(conn)?;

                        return Ok(inserted_user.into()); // convert User to SlimUser
                    }
                }
                Err(ServiceError::BadRequest("Invalid Invitation".into()))
            })
    }
} 
```

##### è§£æ url å‚æ•°

actix-web æœ‰è®¸å¤šä»è¯·æ±‚ä¸­æå–æ•°æ®çš„ç®€å•æ–¹æ³•ã€‚

æ–¹æ³•ä¹‹ä¸€æ˜¯ä½¿ç”¨è·¯å¾„æå–å™¨ã€‚

> [Path](https://actix.rs/actix-web/actix_web/struct.Path.html) æä¾›äº†å¯ä»¥ä»è¯·æ±‚è·¯å¾„ä¸­æå–çš„ä¿¡æ¯ã€‚æ‚¨å¯ä»¥ä»è·¯å¾„ä¸­ååºåˆ—åŒ–ä»»ä½•å˜é‡æ®µã€‚

è¿™å°†å…è®¸æˆ‘ä»¬ä¸ºæ¯ä¸ªæ³¨å†Œä¸ºç”¨æˆ·é‚€è¯·åˆ›å»ºä¸€ä¸ªå”¯ä¸€çš„è·¯å¾„ã€‚

è®©æˆ‘ä»¬åœ¨`app.rs`æ–‡ä»¶ä¸­ä¿®æ”¹æˆ‘ä»¬çš„æ³¨å†Œè·¯å¾„ï¼Œå¹¶æ·»åŠ ä¸€ä¸ªæˆ‘ä»¬ç¨åå°†å®ç°çš„å¤„ç†å‡½æ•°ã€‚

```
// app.rs
/// creates and returns the app after mounting all routes/resources
// add use statement at the top.
use register_routes::register_user;
//...snip
pub fn create_app(db: Addr<DbExecutor>) -> App<AppState> {
    App::with_state(AppState { db })
        //... snip
        // routes to register as a user
        .resource("/register/{invitation_id}", |r| {
           r.method(Method::POST).with(register_user);
        })

} 
```

ä½ å¯èƒ½æƒ³æš‚æ—¶æ³¨é‡Šæ‰è¿™äº›å˜åŒ–ï¼Œå› ä¸ºäº‹æƒ…è¿˜æ²¡æœ‰å®ç°ï¼Œå¹¶ä¿æŒä½ çš„åº”ç”¨ç¨‹åºç¼–è¯‘å’Œè¿è¡Œã€‚(æˆ‘å°½å¯èƒ½è¿™æ ·åšï¼Œä»¥è·å¾—æŒç»­çš„åé¦ˆ)ã€‚

æˆ‘ä»¬ç°åœ¨éœ€è¦åšçš„å°±æ˜¯å®ç° register_user()å‡½æ•°ï¼Œè¯¥å‡½æ•°ä»å®¢æˆ·ç«¯å‘é€çš„è¯·æ±‚ä¸­æå–æ•°æ®ï¼Œé€šè¿‡å‘å‚ä¸è€…å‘é€`RegisterUser`æ¶ˆæ¯æ¥è°ƒç”¨å¤„ç†ç¨‹åºã€‚é™¤äº† url å‚æ•°ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä»å®¢æˆ·ç«¯æå–å¯†ç ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å·²ç»åœ¨`register_handler.rs`ä¸­åˆ›å»ºäº†ä¸€ä¸ª`UserData`ç»“æ„ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ç±»å‹`Json`æ¥åˆ›å»ºç”¨æˆ·æ•°æ®ç»“æ„ã€‚

> Json å…è®¸å°†è¯·æ±‚ä½“ååºåˆ—åŒ–ä¸ºç»“æ„ã€‚ä¸ºäº†ä»è¯·æ±‚ä½“ä¸­æå–ç±»å‹åŒ–ä¿¡æ¯ï¼Œç±»å‹ T å¿…é¡»å®ç° serde çš„ååºåˆ—åŒ–ç‰¹å¾ã€‚

åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶`src/register_routes.rs`å¹¶å°†`mod register_routes;`æ·»åŠ åˆ°ä½ çš„`main.rs`ä¸­ã€‚

```
use actix_web::{AsyncResponder, FutureResponse, HttpResponse, ResponseError, State, Json, Path};
use futures::future::Future;

use app::AppState;
use register_handler::{RegisterUser, UserData};

pub fn register_user((invitation_id, user_data, state): (Path<String>, Json<UserData>, State<AppState>))
                     -> FutureResponse<HttpResponse> {
    let msg = RegisterUser {
        // into_inner() returns the inner string value from Path
        invitation_id: invitation_id.into_inner(),
        password: user_data.password.clone(),
    };

    state.db.send(msg)
        .from_err()
        .and_then(|db_response| match db_response {
            Ok(slim_user) => Ok(HttpResponse::Ok().json(slim_user)),
            Err(service_error) => Ok(service_error.error_response()),
        }).responder()
} 
```

##### æµ‹è¯•ä½ çš„å®ç°

å¤„ç†å®Œé”™è¯¯(å¦‚æœæœ‰)åï¼Œè®©æˆ‘ä»¬è¯•ä¸€è¯•ã€‚
è°ƒç”¨

```
curl --request POST \
  --url http://localhost:3000/invitation \
  --header 'content-type: application/json' \
  --data '{
    "email":"name@domain.com"
}' 
```

åº”è¯¥ä¼šè¿”å›ç±»ä¼¼
çš„å†…å®¹

```
{  "id":  "f87910d7-0e33-4ded-a8d8-2264800d1783",  "email":  "name@domain.com",  "expires_at":  "2018-10-27T13:02:00.909757"  } 
```

å‡è®¾æˆ‘ä»¬é€šè¿‡åˆ›å»ºä¸€ä¸ªé“¾æ¥å‘ç”¨æˆ·å‘é€äº†ä¸€å°ç”µå­é‚®ä»¶ï¼Œè¯¥é“¾æ¥æŒ‡å‘ä¸€ä¸ªä¾›ç”¨æˆ·å¡«å†™çš„è¡¨å•ã€‚ä»é‚£é‡Œï¼Œæˆ‘ä»¬å°†è®©æˆ‘ä»¬çš„å®¢æˆ·ç«¯å‘[http://localhost:3000/register/f 87910d 7-0e 33-4d ed-a8d 8-2264800d 1783](http://localhost:3000/register/f87910d7-0e33-4ded-a8d8-2264800d1783)å‘é€è¯·æ±‚ã€‚å‡ºäºæ¼”ç¤ºçš„ç›®çš„ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„æµ‹è¯•å‘½ä»¤æµ‹è¯•æ‚¨çš„åº”ç”¨ç¨‹åºã€‚

```
curl --request POST \
  --url http://localhost:3000/register/f87910d7-0e33-4ded-a8d8-2264800d1783 \
  --header 'content-type: application/json' \
  --data '{"password":"password"}' 
```

å®ƒåº”è¯¥ä¼šè¿”å›ç±»ä¼¼äº
çš„å†…å®¹

```
{  "email":  "name@domain.com"  } 
```

å†æ¬¡è¿è¡Œè¯¥å‘½ä»¤å°†å¯¼è‡´é”™è¯¯

```
 "Key (email)=(name@domain.com) already exists." 
```

æ­å–œä½ ï¼Œç°åœ¨ä½ æœ‰äº†ä¸€ä¸ª web æœåŠ¡ï¼Œå®ƒå¯ä»¥é‚€è¯·ã€éªŒè¯å’Œåˆ›å»ºä¸€ä¸ªç”¨æˆ·ï¼Œç”šè‡³å‘ä½ å‘é€ä¸€ä¸ªåŠæœ‰ç”¨çš„é”™è¯¯æ¶ˆæ¯ã€‚ğŸ‰ğŸ‰

##### è®©æˆ‘ä»¬åšéªŒè¯å§

æ ¹æ® w3.org:

> åŸºäºä»¤ç‰Œçš„èº«ä»½éªŒè¯ç³»ç»ŸèƒŒåçš„ä¸€èˆ¬æ¦‚å¿µå¾ˆç®€å•ã€‚å…è®¸ç”¨æˆ·è¾“å…¥ä»–ä»¬çš„ç”¨æˆ·åå’Œå¯†ç ï¼Œä»¥è·å¾—ä¸€ä¸ªä»¤ç‰Œï¼Œå…è®¸ä»–ä»¬è·å–ç‰¹å®šçš„èµ„æº-è€Œä¸ä½¿ç”¨ä»–ä»¬çš„ç”¨æˆ·åå’Œå¯†ç ã€‚ä¸€æ—¦è·å¾—äº†ä»¤ç‰Œï¼Œç”¨æˆ·å°±å¯ä»¥å‘è¿œç¨‹ç«™ç‚¹æä¾›ä»¤ç‰Œâ€”â€”è¯¥ä»¤ç‰Œæä¾›ä¸€æ®µæ—¶é—´å†…å¯¹ç‰¹å®šèµ„æºçš„è®¿é—®ã€‚

ç°åœ¨ï¼Œæ‚¨é€‰æ‹©å¦‚ä½•äº¤æ¢ä»¤ç‰Œå¯èƒ½ä¼šæ¶‰åŠå®‰å…¨é—®é¢˜ã€‚ä½ ä¼šå‘ç°å›´ç»•äº’è”ç½‘çš„è®¸å¤šè®¨è®º/è¾©è®ºï¼Œä»¥åŠäººä»¬ä½¿ç”¨çš„è®¸å¤šæ–¹å¼ã€‚æˆ‘å¯¹åœ¨å®¢æˆ·ç«¯å­˜å‚¨å¯ä»¥è¢«å®¢æˆ·ç«¯ JavaScript è®¿é—®çš„ä¸œè¥¿éå¸¸è°¨æ…ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™ç§æ–¹æ³•åœ¨å„åœ°æˆåƒä¸Šä¸‡çš„æ•™ç¨‹ä¸­éƒ½æœ‰æåŠã€‚è¿™é‡Œæœ‰ä¸€ä¸ªå¾ˆå¥½çš„é˜…è¯»[åœæ­¢ä½¿ç”¨ JWT ä¼šè®®](http://cryto.net/%7Ejoepie91/blog/2016/06/13/stop-using-jwt-for-sessions/)ã€‚

é™¤äº†`don't follow online tutorials blindly and do your own research`ä¹‹å¤–ï¼Œæˆ‘ä¸çŸ¥é“è¯¥ç»™è¯»è€…ä»€ä¹ˆå»ºè®®ã€‚æœ¬æ•™ç¨‹çš„ç›®çš„æ˜¯äº†è§£ Actix-web å’Œ rust not å¦‚ä½•é˜²æ­¢æ‚¨çš„æœåŠ¡å™¨å‡ºç°æ¼æ´ã€‚å‡ºäºæœ¬æ•™ç¨‹çš„è€ƒè™‘ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ http ä¸“ç”¨ cookies æ¥äº¤æ¢ä»¤ç‰Œã€‚

**è¯·å‹¿åœ¨ç”Ÿäº§ä¸­ä½¿ç”¨ã€‚**

ç°åœ¨è¿™å·²ç»ä¸ç¢äº‹äº†ğŸ˜°ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬èƒ½åšäº›ä»€ä¹ˆã€‚actix-web ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ç§ç®€æ´çš„ä¸­é—´ä»¶æ–¹å¼æ¥å¤„ç†è¿™é‡Œè®°å½•çš„ä¼šè¯ cookie[actix _ web::ä¸­é—´ä»¶::èº«ä»½](https://actix.rs/actix-web/actix_web/middleware/identity/index.html)ã€‚ä¸ºäº†å¯ç”¨è¿™ä¸ªåŠŸèƒ½ï¼Œæˆ‘ä»¬ä¿®æ”¹æˆ‘ä»¬çš„`app.rs`æ–‡ä»¶å¦‚ä¸‹ã€‚

```
use actix_web::middleware::identity::{CookieIdentityPolicy, IdentityService};
use chrono::Duration;
//--snip
pub fn create_app(db: Addr<DbExecutor>) -> App<AppState> {
    // secret is a random 32 character long base 64 string
    let secret: String = std::env::var("SECRET_KEY").unwrap_or_else(|_| "0".repeat(32));
    let domain: String = std::env::var("DOMAIN").unwrap_or_else(|_| "localhost".to_string());

    App::with_state(AppState { db })
        .middleware(Logger::default())
        .middleware(IdentityService::new(
            CookieIdentityPolicy::new(secret.as_bytes())
                .name("auth")
                .path("/")
                .domain(domain.as_str())
                .max_age(Duration::days(1)) // just for testing
                .secure(false),
        ))
        //--snip
} 
```

è¿™ç»™äº†æˆ‘ä»¬éå¸¸æ–¹ä¾¿çš„æ–¹æ³•ï¼Œåƒ`req.remember(data)`ã€`req.identity()`å’Œ`req.forget()`ç­‰ç­‰ã€‚è¿™å°†ä¾æ¬¡è®¾ç½®å’Œåˆ é™¤å®¢æˆ·ç«¯çš„èº«ä»½éªŒè¯ cookieã€‚

##### JWTï¼Ÿ

åœ¨å†™è¿™ç¯‡æ•™ç¨‹çš„æ—¶å€™ï¼Œæˆ‘ç¢°åˆ°äº†ä¸€äº›å…³äºä½¿ç”¨ä»€ä¹ˆ JWT åº“çš„è®¨è®ºã€‚é€šè¿‡ç®€å•çš„æœç´¢ï¼Œæˆ‘æ‰¾åˆ°äº†ä¸€äº›ï¼Œå¹¶å†³å®šä½¿ç”¨ [frank_jwt](https://crates.io/crates/frank_jwt) ä½†éšå [Vincent Prouillet](https://github.com/Keats) [æŒ‡å‡ºäº†ä¸å®Œæ•´çš„å†…å®¹](https://github.com/GildedHonour/frank_jwt/blob/master/src/lib.rs#L296-L323)å¹¶å»ºè®®ä½¿ç”¨ [jsonwebtoken](https://crates.io/crates/jsonwebtoken) ã€‚åœ¨ä½¿ç”¨ lib é‡åˆ°éº»çƒ¦åï¼Œæˆ‘ä»ä»–ä»¬é‚£é‡Œå¾—åˆ°äº†å¾ˆå¤§çš„å›åº”ã€‚ç°åœ¨å›è´­å·²ç»æœ‰äº†å·¥ä½œç¤ºä¾‹ï¼Œæˆ‘èƒ½å¤Ÿå®ç°ä¸‹é¢çš„é»˜è®¤è§£å†³æ–¹æ¡ˆã€‚è¯·æ³¨æ„ï¼Œè¿™ä¸æ˜¯æœ€å®‰å…¨çš„ JWT å®ç°ï¼Œæ‚¨å¯èƒ½éœ€è¦æŸ¥æ‰¾å‚è€ƒèµ„æ–™ä»¥ä½¿å…¶æ›´å¥½åœ°æ»¡è¶³æ‚¨çš„éœ€æ±‚ã€‚

åœ¨æˆ‘ä»¬åˆ›å»º auth handler å’Œ route å‡½æ•°ä¹‹å‰ï¼Œè®©æˆ‘ä»¬ä¸º jwt ç¼–ç å’Œè§£ç æ·»åŠ ä¸€äº›åŠ©æ‰‹å‡½æ•°ã€‚åˆ«å¿˜äº†åœ¨ä½ çš„`main.rs`é‡ŒåŠ ä¸Š`extern crate jsonwebtoken as jwt;`ã€‚

å¦‚æœæœ‰äººæœ‰æ›´å¥½çš„å®ç°æ–¹å¼ï¼Œæˆ‘ä¼šå¾ˆä¹æ„æ¥å— PRã€‚

```
// utils.rs
use models::SlimUser;
use std::convert::From;
use jwt::{decode, encode, Header, Validation};
use chrono::{Local, Duration};
//--snip

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    // issuer
    iss: String,
    // subject
    sub: String,
    //issued at
    iat: i64,
    // expiry
    exp: i64,
    // user email
    email: String,
}

// struct to get converted to token and back
impl Claims {
    fn with_email(email: &str) -> Self {
        Claims {
            iss: "localhost".into(),
            sub: "auth".into(),
            email: email.to_owned(),
            iat: Local::now().timestamp(),
            exp: (Local::now() + Duration::hours(24)).timestamp(),
        }
    }
}

impl From<Claims> for SlimUser {
    fn from(claims: Claims) -> Self {
        SlimUser { email: claims.email }
    }
}

pub fn create_token(data: &SlimUser) -> Result<String, ServiceError> {
    let claims = Claims::with_email(data.email.as_str());
    encode(&Header::default(), &claims, get_secret().as_ref())
        .map_err(|_err| ServiceError::InternalServerError)
}

pub fn decode_token(token: &str) -> Result<SlimUser, ServiceError> {
    decode::<Claims>(token, get_secret().as_ref(), &Validation::default())
        .map(|data| Ok(data.claims.into()))
        .map_err(|_err| ServiceError::Unauthorized)?
}

// take a string from env variable
fn get_secret() -> String {
    env::var("JWT_SECRET").unwrap_or("my secret".into())
} 
```

##### æˆæƒå¤„ç†

ä½ ç°åœ¨çŸ¥é“ç¨‹åºäº†ğŸ˜‰ï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶`src/auth_handler.rs`å¹¶å°†`mod auth_handler;`æ·»åŠ åˆ°æ‚¨çš„`main.rs`ä¸­ã€‚

```
//auth_handler.rs
use actix::{Handler, Message};
use diesel::prelude::*;
use errors::ServiceError;
use models::{DbExecutor, User, SlimUser};
use bcrypt::verify;
use actix_web::{FromRequest, HttpRequest, middleware::identity::RequestIdentity};

#[derive(Debug, Deserialize)]
pub struct AuthData {
    pub email: String,
    pub password: String,
}

impl Message for AuthData {
    type Result = Result<SlimUser, ServiceError>;
}

impl Handler<AuthData> for DbExecutor {
    type Result = Result<SlimUser, ServiceError>;
    fn handle(&mut self, msg: AuthData, _: &mut Self::Context) -> Self::Result {
        use schema::users::dsl::{users, email};
        let conn: &PgConnection = &self.0.get().unwrap();
        let mismatch_error = Err(ServiceError::BadRequest("Username and Password don't match".into()));

        let mut items = users
            .filter(email.eq(&msg.email))
            .load::<User>(conn)?;

        if let Some(user) = items.pop() {
            match verify(&msg.password, &user.password) {
                Ok(matching) => {
                    if matching { return Ok(user.into()); } else { return mismatch_error; }
                }
                Err(_) => { return mismatch_error; }
            }
        }
        mismatch_error
    }
} 
```

ä¸Šé¢çš„å¤„ç†ç¨‹åºé‡‡ç”¨äº†åŒ…å«å®¢æˆ·ç«¯å‘é€çš„ç”µå­é‚®ä»¶å’Œå¯†ç çš„`AuthData`ç»“æ„ã€‚æˆ‘ä»¬ä½¿ç”¨ç”µå­é‚®ä»¶ä»æ•°æ®åº“ä¸­æå–ç”¨æˆ·ï¼Œå¹¶ä½¿ç”¨ bcrypt éªŒè¯å‡½æ•°æ¥åŒ¹é…å¯†ç ã€‚å¦‚æœä¸€åˆ‡é¡ºåˆ©ï¼Œæˆ‘ä»¬è¿”å›ç”¨æˆ·æˆ–è€…è¿”å›`BadRequest`é”™è¯¯ã€‚

ç°åœ¨è®©æˆ‘ä»¬ç”¨ä¸‹é¢çš„å†…å®¹åˆ›å»º`src/auth_routes.rs`:

```
// auth_routes.rs
use actix_web::{AsyncResponder, FutureResponse, HttpResponse, HttpRequest, ResponseError, Json};
use actix_web::middleware::identity::RequestIdentity;
use futures::future::Future;
use utils::create_token;

use app::AppState;
use auth_handler::AuthData;

pub fn login((auth_data, req): (Json<AuthData>, HttpRequest<AppState>))
             -> FutureResponse<HttpResponse> {
    req.state()
        .db
        .send(auth_data.into_inner())
        .from_err()
        .and_then(move |res| match res {
            Ok(slim_user) => {
                let token = create_token(&slim_user)?;
                req.remember(token);
                Ok(HttpResponse::Ok().into())
            }
            Err(err) => Ok(err.error_response()),
        }).responder()
}

pub fn logout(req: HttpRequest<AppState>) -> HttpResponse {
    req.forget();
    HttpResponse::Ok().into()
} 
```

æˆ‘ä»¬çš„ç™»å½•æ–¹æ³•ä»è¯·æ±‚ä¸­æå–`AuthData`,å¹¶å°†æ¶ˆæ¯å‘é€ç»™æˆ‘ä»¬åœ¨ auth_handler.rs ä¸­å®ç°çš„`DbEexcutor` Actor handlerã€‚åœ¨è¿™é‡Œï¼Œå¦‚æœä¸€åˆ‡æ­£å¸¸ï¼Œæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªè¿”å›ç»™æˆ‘ä»¬çš„ç”¨æˆ·ï¼Œæˆ‘ä»¬ä½¿ç”¨æˆ‘ä»¬ä¹‹å‰åœ¨ utils.rs ä¸­å®šä¹‰çš„ helper å‡½æ•°æ¥åˆ›å»ºä¸€ä¸ªä»¤ç‰Œå¹¶è°ƒç”¨`req.remember(token)`ã€‚è¿™åˆä¸ºå®¢æˆ·ç«¯è®¾ç½®äº†ä¸€ä¸ªå¸¦æœ‰ä»¤ç‰Œçš„ cookie å¤´æ¥ä¿å­˜ã€‚

æˆ‘ä»¬ç°åœ¨éœ€è¦åšçš„æœ€åä¸€ä»¶äº‹æ˜¯åœ¨æˆ‘ä»¬çš„`app.rs`ä¸­ä½¿ç”¨ç™»å½•/æ³¨é”€åŠŸèƒ½ã€‚å°†`.rsource("/auth")`å…³é—­æ›´æ”¹ä¸º:

```
.resource("/auth", |r| {
            r.method(Method::POST).with(login);
            r.method(Method::DELETE).with(logout);
        }) 
```

ä½†æ˜¯ä¸è¦å¿˜è®°åœ¨æ–‡ä»¶çš„é¡¶éƒ¨æ·»åŠ `use auth_routes::{login, logout};`ã€‚

##### æµ‹è¯•è¿è¡Œæˆæƒ

å¦‚æœæ‚¨ä¸€ç›´æŒ‰ç…§æ•™ç¨‹æ“ä½œï¼Œé‚£ä¹ˆæ‚¨å·²ç»åˆ›å»ºäº†ä¸€ä¸ªå…·æœ‰ç”µå­é‚®ä»¶å’Œå¯†ç çš„ç”¨æˆ·ã€‚ä½¿ç”¨ä¸‹é¢çš„ curl å‘½ä»¤æ¥æµ‹è¯•æˆ‘ä»¬çš„æœåŠ¡å™¨ã€‚

```
curl -i --request POST \
  --url http://localhost:3000/auth \
  --header 'content-type: application/json' \
  --data '{
        "email": "name@domain.com",
        "password":"password"
}'

## response
HTTP/1.1 200 OK
set-cookie: auth=iqsB4KUUjXUjnNRl1dVx9lKiRfH24itiNdJjTAJsU4CcaetPpaSWfrNq6IIoVR5+qKPEVTrUeg==; HttpOnly; Path=/; Domain=localhost; Max-Age=86400
content-length: 0
date: Sun, 28 Oct 2018 12:36:43 GMT 
```

å¦‚æœä½ æ”¶åˆ°äº†ä¸€ä¸ª 200 çš„å“åº”ï¼Œå¦‚ä¸Šæ‰€ç¤ºï¼Œå¸¦æœ‰ä¸€ä¸ª set-cookie å¤´ï¼Œé‚£ä¹ˆæ­å–œä½ å·²ç»æˆåŠŸç™»å½•äº†ã€‚

ä¸ºäº†æµ‹è¯•æ³¨é”€ï¼Œæˆ‘ä»¬å‘`/auth`å‘é€ä¸€ä¸ªåˆ é™¤è¯·æ±‚ï¼Œç¡®ä¿æ‚¨å¾—åˆ°çš„ set-cookie å¤´åŒ…å«ç©ºæ•°æ®å’Œç«‹å³åˆ°æœŸæ—¥æœŸã€‚

```
curl -i --request DELETE \
  --url http://localhost:3000/auth

## response
HTTP/1.1 200 OK
set-cookie: auth=; HttpOnly; Path=/; Domain=localhost; Max-Age=0; Expires=Fri, 27 Oct 2017 13:01:52 GMT
content-length: 0
date: Sat, 27 Oct 2018 13:01:52 GMT 
```

##### å®ç°å—ä¿æŠ¤çš„è·¯ç”±

ä½¿ç”¨ Auth çš„å…¨éƒ¨ç›®çš„æ˜¯æœ‰åŠæ³•éªŒè¯è¯·æ±‚æ˜¯å¦æ¥è‡ªç»è¿‡èº«ä»½éªŒè¯çš„å®¢æˆ·ç«¯ã€‚Actix-web æœ‰ä¸€ä¸ªç‰¹æ€§`FromRequest`,æˆ‘ä»¬å¯ä»¥åœ¨ä»»ä½•ç±»å‹ä¸Šå®ç°å®ƒï¼Œç„¶åç”¨å®ƒä»è¯·æ±‚ä¸­æå–æ•°æ®ã€‚åœ¨è¿™é‡Œçœ‹æ–‡æ¡£[ã€‚æˆ‘ä»¬å°†åœ¨`auth_handler.rs`çš„åº•éƒ¨æ·»åŠ ä»¥ä¸‹å†…å®¹ã€‚](https://actix.rs/actix-web/actix_web/trait.FromRequest.html) 

```
//auth_handler.rs
//--snip
use actix_web::FromRequest;
use utils::decode_token;
//--snip

// we need the same data as SlimUser
// simple aliasing makes the intentions clear and its more readable
pub type LoggedUser = SlimUser;

impl<S> FromRequest<S> for LoggedUser {
    type Config = ();
    type Result = Result<LoggedUser, ServiceError>;
    fn from_request(req: &HttpRequest<S>, _: &Self::Config) -> Self::Result {
        if let Some(identity) = req.identity() {
            let user: SlimUser = decode_token(&identity)?;
            return Ok(user as LoggedUser);
        }
        Err(ServiceError::Unauthorized)
    }
} 
```

æˆ‘ä»¬é€‰æ‹©ä½¿ç”¨ç±»å‹åˆ«åï¼Œè€Œä¸æ˜¯åˆ›å»ºä¸€ä¸ªå…¨æ–°çš„ç±»å‹ã€‚å½“æˆ‘ä»¬ä»è¯·æ±‚ä¸­æå–`LoggedUser`æ—¶ï¼Œè¯»è€…ä¼šçŸ¥é“å®ƒæ˜¯ç»è¿‡èº«ä»½éªŒè¯çš„ç”¨æˆ·ã€‚FromRequest ç‰¹å¾åªæ˜¯è¯•å›¾å°† cookie ä¸­çš„å­—ç¬¦ä¸²ååºåˆ—åŒ–åˆ°æˆ‘ä»¬çš„ç»“æ„ä¸­ï¼Œå¦‚æœå¤±è´¥ï¼Œå®ƒåªæ˜¯è¿”å›æœªæˆæƒçš„é”™è¯¯ã€‚ä¸ºäº†æµ‹è¯•è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦å°†å®é™…è·¯çº¿æ·»åŠ åˆ°æˆ–åº”ç”¨ç¨‹åºã€‚æˆ‘ä»¬ç®€å•åœ°ç»™`auth_routes.rs`
æ·»åŠ å¦ä¸€ä¸ªå‡½æ•°

```
//auth_routes.rs
//--snip

pub fn get_me(logged_user: LoggedUser) -> HttpResponse {
    HttpResponse::Ok().json(logged_user)
} 
```

ä¸ºäº†è°ƒç”¨å®ƒï¼Œæˆ‘ä»¬åœ¨`app.rs`èµ„æºä¸­æ³¨å†Œäº†è¿™ä¸ªæ–¹æ³•ã€‚å®ƒçœ‹èµ·æ¥åƒä¸‹é¢çš„ã€‚

```
//app.rs
use auth_routes::{login, logout, get_me};
//--snip

.resource("/auth", |r| {
    r.method(Method::POST).with(login);
    r.method(Method::DELETE).with(logout);
    r.method(Method::GET).with(get_me);
})
//--snip 
```

##### æµ‹è¯•ç™»å½•ç”¨æˆ·

åœ¨ç»ˆç«¯ä¸­å°è¯•ä»¥ä¸‹ Curl å‘½ä»¤ã€‚

```
curl -i --request POST \
  --url http://localhost:3000/auth \
  --header 'content-type: application/json' \
  --data '{
        "email": "name@domain.com",
        "password":"password"
}'
# result would be something like
HTTP/1.1 200 OK
set-cookie: auth=HdS0iPKTBL/4MpTmoUKQ5H7wft5kP7OjP6vbyd05Ex5flLvAkKd+P2GchG1jpvV6p9GQtzPEcg==; HttpOnly; Path=/; Domain=localhost; Max-Age=86400
content-length: 0
date: Sun, 28 Oct 2018 19:16:12 GMT

## and then pass the cookie back for a get request
curl -i --request GET \
  --url http://localhost:3000/auth \
  --cookie auth=HdS0iPKTBL/4MpTmoUKQ5H7wft5kP7OjP6vbyd05Ex5flLvAkKd+P2GchG1jpvV6p9GQtzPEcg==
## result
HTTP/1.1 200 OK
content-length: 27
content-type: application/json
date: Sun, 28 Oct 2018 19:21:04 GMT

{"email":"name@domain.com"} 
```

å®ƒåº”è¯¥æˆåŠŸåœ°è¿”å›ä½ çš„ç”µå­é‚®ä»¶ä½œä¸º json å›æ¥ã€‚åªæœ‰æ‹¥æœ‰æœ‰æ•ˆçš„ auth cookie å’Œä»¤ç‰Œçš„ç™»å½•ç”¨æˆ·æˆ–è¯·æ±‚æ‰ä¼šé€šè¿‡æ‚¨æå–çš„è·¯ç”±`LoggedUser`ã€‚

##### æ¥ä¸‹æ¥æ˜¯ä»€ä¹ˆï¼Ÿ

åœ¨æœ¬æ•™ç¨‹çš„ç¬¬ 3 éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ä¸ºè¿™ä¸ªåº”ç”¨ç¨‹åºåˆ›å»º**ç”µå­é‚®ä»¶éªŒè¯**å’Œ**å‰ç«¯**ã€‚ä¸ºæ­¤ï¼Œæˆ‘æƒ³ä½¿ç”¨æŸç§ rust html æ¨¡æ¿ç³»ç»Ÿã€‚ä¸æ­¤åŒæ—¶ï¼Œæˆ‘æ­£åœ¨å­¦ä¹  angularï¼Œæ‰€ä»¥æˆ‘å¯èƒ½ä¼šåœ¨å®ƒçš„å‰é¢å®‰è£…ä¸€ä¸ªå°çš„ Angular åº”ç”¨ç¨‹åºã€‚
å¦‚æœä½ æœ‰ä»»ä½•é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·é€šè¿‡ [twitter](https://twitter.com/mygnu_) è”ç³»æˆ‘ã€‚