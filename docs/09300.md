# 不要安装 Node，直到你读完这篇文章(或者，如何以 Docker 方式运行 Node)

> 原文:[https://dev . to/youknowfordevs/don-t-install-node-until-you-ve-read-this-or-how-to-run-node-the-docker-way-38im](https://dev.to/youknowfordevs/don-t-install-node-until-you-ve-read-this-or-how-to-run-node-the-docker-way-38im)

我们需要一些应用程序或其他节点-也许我们正在创建一个微服务或只是想跟随一个教程。

但是大多数地方建议您首先为您的操作系统安装 Node。也许你用的是 Mac，所以现在你必须开始考虑你是否也应该安装家酿软件或 MacPorts。

或者你在 Ubuntu 上，所以你朝着`apt-get`的方向前进……除了在你知道它之前，为了得到最新的版本，你发现你自己正在使用`curl`把一些脚本通过管道传送到你的 shell。

窗户？您可以只使用 Windows installer，但是就像使用 macOS 一样，您要考虑是时候接受 Chocalatey 还是独家包管理器了。

在这篇博文中，我们将了解跳过所有这些，直接进入 Docker 环境如何使管理节点应用程序和开发工作流变得更加容易，以及如何让您从一开始就采用最佳实践。

# 先停靠码头

[![Docker Logo](../Images/4b17da87db3b09b0b90692dd6edded31.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s---Kb3PD8v--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://youknowfordevs.com/images/uploads/docker.png)

无论我们采用哪种方式安装特定于操作系统的节点，我们现在都有两个问题；首先，我们在每个平台上安装 Node 的方式是不同的，真讨厌。第二，我们现在已经在我们的笔记本电脑上全球安装了节点*。为什么这么难过？现在，如果我们想在不同的项目中使用不同版本的 Node，我们不得不用类似于`nvm`的东西来打发时间。(如果你计划运行一个 Python 项目，这和`virtualenv`是一样的。)*

 *所以帮你自己一个忙[安装 Docker](https://docs.docker.com/install/)。没错，不同的平台安装 Docker 的方式也会有所不同——Ubuntu 与 Mac 和 Windows 略有不同。但这种最初的努力将在以后得到回报，因为现在你将有一种*标准的*方式来安装 Node、Ruby、Python、TensorFlow、R……无论你的项目使用什么语言——或者更有可能是现在的*语言*——只是变得更容易管理。

假设您现在有了 Docker，让我们建立一个开发环境，这样您就可以回到那个教程或项目了。

# 运行节点

[![Node Logo](../Images/3c07c3f031d547f0ff38093dfc3bf5c1.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--_XFLMPyp--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://youknowfordevs.com/images/uploads/node.png)

首先，为您的项目创建一个新目录:

```
mkdir new-project && cd new-project 
```

然后启动最新版本的节点:

```
docker run -it --rm node:10.5.0-alpine 
```

如果你之前没有运行过这个版本的 Node，Docker 会帮你下载。来回移动一会儿后，您将看到通常的节点命令提示符。键入类似于`5+6`的内容并按回车键检查一切正常，然后按`[CTRL]+D`退出。

如果你将来读到这篇文章，你可能想知道最新的版本号是多少；只需前往官方节点 Docker 图片的 [Docker Hub 页面。](https://hub.docker.com/_/node/)

## 互动容器

我们执行了带有几个选项的`docker run`命令。第一部分是`-it`部分，是两个选项`-i`和`-t`的组合。正是这些选项组合在一起，意味着我们可以与运行中的容器进行交互，就像它是我们的普通外壳一样，接受来自键盘的输入，并将输出发送到我们的显示器。

## 一次性容器

当我们退出时,`--rm`选项导致容器被删除。随着时间的推移，删除容器是一个好习惯，因为这让我们认为容器是一次性的。这在部署时尤其重要，因为我们不希望容器在内部保存任何状态——任何更新或处理都应该导致写入外部服务，如连接的文件系统、云存储、队列等。通过采用这种方法，在必要时将我们的映像升级到新版本真的很容易——我们只需扔掉旧的并推出全新的。

(这也将使伸缩变得更容易，因为当我们需要做更多工作时，我们可以启动更多的容器，如果所有状态都在容器的外部被维护，这就变得简单了。)

### 加分:无宋承宪

如果你真的想养成使用 Docker 容器的好习惯，那么也要避免尝试使用 SSH 进入一个正在运行的容器来查看发生了什么。最糟糕的事情莫过于做一些调整来修复某些东西，注销，然后忘记做了什么修改。这项服务现在可能又开始运行了，你的老板会认为你是这个月的宠儿，但它是脆弱的。再次部署并覆盖这些更改。更好的办法是在部署脚本中解决问题，然后简单地拆除有问题的服务并启动另一个服务。现在，在源代码管理中可以清楚地看到这些变化，并且这些变化是可重复的。

## 版本

除了`docker run`的命令行选项之外，关于我们已经使用的节点 Docker 镜像还有一些事情需要注意(`node:10.5.0-alpine`部分)。

首先，明确您正在使用的节点的版本号是值得的，因为这使得强制更新和了解正在部署的内容变得更加容易。如果我们只指定“版本 10”:

```
docker run -it --rm node:10-alpine 
```

甚至是“节点的最新版本”:

```
docker run -it --rm node:alpine 
```

尽管第一次我们会得到`10.5.0`，但是一旦图像在某个时间点被更新，我们就不会在随后的运行中得到相同的版本。在某些时候，在命令中使用`node:10-alpine`会导致我们选择节点的版本`10.6.0`或`10.7.0`。使用`node:alpine`将在某个时候导致我们得到版本`11`和更高版本。

然而，如果我们选择一个像`10.5.0`这样的特定版本，那么尽管我们也不会自动获得更新，但当我们准备强制下载最新的变更时，在我们的构建文件中更新到`10.5.1`将是一个简单的情况。

这对于以后部署应用程序(或者与其他人共享您的代码)尤其重要，因为您希望能够控制哪个版本出现在哪里。也许更重要的是，当您进行故障诊断时，您想确切地知道使用的是什么版本。

### 受控更新

当然，想要“总是使用最新的”是很诱人的；毕竟最新的会更快不是吗？它不会有最新的安全补丁吗？这当然是真的，但是在寻求建立一个可靠的基础设施时，你应该致力于*控制*对基础的更新。这意味着，如果你有一堆在版本`10.5.0`上运行良好的代码，很好地通过了所有的测试，并且运行良好，那么迁移到 Node 的另一个版本应该是计划好的并且经过测试的。唯一真正推动版本升级的压力来自于像`10.5.1`或`10.5.2`这样的点版本，因为它们将包含安全补丁和错误修复；迁移到`10.6`或更高版本当然是一件好事，但是如果你的代码在工作，你的服务在运行，那么你肯定会考虑你的时间花在其他地方是否更好。

## 基础操作系统

[![Alpine Logo](../Images/e34ed603e78f788d0f33af9b4a61d3bd.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--lE-U5yOz--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://youknowfordevs.com/images/uploads/alpine-linux.svg)

关于节点 Docker 映像选择要注意的第二件事是，我们使用了映像的`alpine`版本，该版本使用 [Alpine Linux](https://alpinelinux.org/about/) 作为基本操作系统。这是最轻的节点映像，并且只提供最低限度的操作系统来让节点运行——毕竟，我们最有可能创建微服务。

你可能遇到过`alpine`项目，但是如果你没有，看一看；它正被用于整个 Docker 生态系统，以保持 Docker 图像的亮度。

还应该说,“轻”不仅仅意味着尺寸小——这当然很好，因为它减少了网络中传输的数据量。但是在部署服务的情况下,“轻”也意味着减少可能出错的移动部件的数量。如果你从 Ubuntu 基础映像这样的大东西开始，你会带来一堆不必要的代码，因此增加了出错的可能性，而这本来是不重要的。想象一下，一些邪恶的局外人利用 Ubuntu 的一个安全漏洞，在一个你根本不需要的服务中！

(你可能碰到过‘减少攻击面’这个说法；这正是所指的*。)*

 *所以，保持它小、紧、可控……最重要的是，*安全*。

### 构建自己的基础映像——不要！

不言而喻，你不希望建立自己的基础形象。例如，各种 Docker 节点映像是由节点项目本身维护的，所以如果有人知道如何构建一个安全、快速和可靠的映像，那就是他们。更重要的是，如果出了什么问题，会有一整个社区的人使用图像和报告问题；你总能很快找到解决办法。

# 一个开发环境

因此，我们选择了一个节点映像，并让它从命令行运行。让我们继续我们的开发环境。

为了能够更新项目目录中的文件，我们需要给节点应用程序“访问”该目录的权限。这是通过 Docker 命令上的“volume”选项实现的。试试这个:

```
docker run -it --rm -v ${PWD}:/usr/src/app node:10.5.0-alpine \
  /bin/sh -c "touch /usr/src/app/README.md" 
```

这将:

*   在你的 Docker 容器内创建一个目录*(在`/usr/src/app`)，并使其引用你当前在*你的容器外的工作目录*(即`${PWD}`部分)；*
*   启动 Bash shell(而不是 Node ),运行将创建一个`README`文件的`touch`命令。

该命令应该干净地退出。检查当前目录，确保文件已经创建:

```
$ ls -al
total 0
drwxr-xr-x 4 markbirbeck staff 136 1 Jul 13:26 .
drwxr-xr-x 10 markbirbeck staff 340 1 Jul 11:47 ..
-rw-r--r-- 1 markbirbeck staff 0 1 Jul 12:58 README.md 
```

这是创建文件的一种费力的方式，但是我们只是想检查一下我们的 Docker 容器是否能够“看到”我们的笔记本电脑项目目录，以及它是否能够更新其中的文件。

我们现在有*两种*方式来处理我们的项目:我们可以从容器内的*启动`vi`并进行编辑，这些编辑会立即反映到我们笔记本电脑上的工作目录中；或者我们可以使用我们熟悉的笔记本电脑工具——如 Visual Studio Code、Sublime Text 等——在*容器之外创建和编辑文件*,知道更改会立即镜像到容器内的`/usr/src/app`目录。*

无论哪种方式，我们现在都可以像平常在笔记本电脑上一样进行开发，但是有了 Docker 提供的易于管理的节点环境。

# 打开端口

最后一件事。假设我们通过跟随节点站点上的[小介绍开始了 Node。您将看到它建立了一个“hello world”web 服务器，并建议可以在`http://localhost:3000`查看该页面。继续在您当前的目录中创建那个`app.js`文件…但是运行它没有意义，因为按照我们的 *Docker* 开发环境方法的情况来看，这个服务器不能工作。](https://nodejs.org/en/docs/guides/getting-started-guide/)

然而，正如我们前面看到的，我们可以在主机和容器之间映射目录，也可以映射端口。第一步是将`-p`选项添加到我们的命令中，如下所示:

```
docker run -it --rm -v ${PWD}:/usr/src/app -p 3000:3000 node:10.5.0-alpine \
  /bin/sh 
```

我们现在可以通过向主机上的端口 3000 发出请求来访问容器内的端口 3000 *，这满足了节点教程的`http://localhost:3000`部分。*

但是我们还需要做最后一个小小的调整。当服务器启动时，它将监听 IP 地址`127.0.0.1`,这在我们的笔记本电脑上很好，但在容器中就不好了。我们可以使用这个地址来防止从我们的笔记本电脑外部访问我们的服务器，但是在 Docker 容器的情况下，从我们的笔记本电脑到容器有一个网络连接(把它们想象成单独的机器)，所以在容器内保持东西的‘私有’*将仅仅意味着没有东西是可访问的。*

我们需要做的就是修改节点站点上提供的文件，并将`hostname`变量从`127.0.0.1`修改为`0.0.0.0`。这将告诉服务器监听*容器内的所有* IP 地址，而不仅仅是`localhost`。如果我们愿意，我们仍然可以通过修改 Docker 命令来确保我们的服务器不能从我们的笔记本电脑外部到达

```
docker run -it --rm -v ${PWD}:/usr/src/app -p 127.0.0.1:3000:3000 \
  node:10.5.0-alpine /bin/sh 
```

即，从主机端口到容器端口的映射应该只发生在`127.0.0.1`而不是`0.0.0.0`(这是端口映射的默认设置)。

无论您是否在运行命令时修改了端口设置，一旦`app.js`文件有了这个微小的改变，服务器就可以从容器内部启动了。将目录切换到`app.js`文件所在的位置，然后启动它:

```
cd /usr/src/app
node app.js 
```

现在你应该可以通过访问`http://localhost:3000`从主机进入“hello world”页面。

# 下一步

假设一切顺利，我们现在可以继续我们所遵循的任何项目或教程。在教程告诉我们从命令行运行的任何地方，我们都确保通过启动 Bash shell 从容器内的*运行。如果项目要求我们公开一个不同的端口，那么只需改变`-p`选项(或者在必要时添加更多映射)。*

还有很多方法可以改善我们的发展环境；我们可以:

*   引入 Docker Compose 来缩短我们的命令行；
*   添加更多的目录映射，这样安装了`npm install`的模块会留在我们的容器中*；*
*   创建包含像摩卡或 TAP 这样的跑步者的测试容器；
*   启动本地 Nginx 服务器，它将镜像我们的实时部署。

但所有这些都将建立在我们这里的基本设置之上。我们将在以后的文章中深入研究这些技术。

祝你的项目好运！**