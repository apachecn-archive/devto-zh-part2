# 为了乐趣和利润的 CSS 堆叠上下文

> 原文:[https://dev . to/3zsforinsomnia/CSS-stacking-contexts-for-fun-and-profit-25ek](https://dev.to/3zsforinsomnia/css-stacking-contexts-for-fun-and-profit--25ek)

在最近的工作中，我遇到了一种情况，我们使用浏览器自带的[全屏 API](https://fullscreen.spec.whatwg.org) 全屏显示 DOM 中的一个元素。这通常是微不足道的，但这种情况有点奇怪，因为我们全屏显示的元素提供了一个篮球场的地图，上面有拍摄的位置。当用户点击其中一个镜头标记时，我们在顶部打开一个模式，显示该剧发生时的细节和相关的视频片段。

当拍摄地图没有全屏时，这很好，但是当我们打开模型时，我们突然在渲染 DOM 树的堆叠上下文(布局和显示顺序)和模型的 z 索引之间产生了冲突。

我就不赘述产品细节了，但问题是全屏显示的项目会修改浏览器的堆叠上下文。结果是，即使我们添加了 modal 作为< body >标签的第一个子元素，不管我们为它设置了什么 z-index，它都不会显示。它总是隐藏在全屏拍摄地图的后面，使它看起来好像在地图上单击拍摄标记突然没有效果。更糟糕的是，这允许用户产生多个模态，因为他们现在可以继续点击通常隐藏的镜头标记。

最后一个问题很容易解决，只允许一次打开一个模式，但是这个(单个)模式仍然是隐藏的，所以需要另一个解决方案。

这里的根本问题是，尽管模型在 DOM 中的级别比快照地图高，但是全屏 API 的使用创建了一个新的堆栈上下文，并且这个堆栈上下文优先于普通的 z 索引使用。模型仍然存在并被渲染，但是在新的堆叠环境下不可见。

这样做的原因是，使用全屏 API 添加的堆栈上下文创建了一个新的上下文，它作为树中的最后一项添加到树中。CSS 创建了一个绘画顺序(这是一个有序的集合),它是由堆叠上下文(这是一棵树)产生的。它使用堆叠上下文的后序深度优先遍历来实现这一点。我不会在这里深入探讨这意味着什么(但是你可以阅读关于使用它的[CSS](https://www.w3.org/TR/CSS2/zindex.html#outlines)和[遍历](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)，这是我强烈建议的)，但是简单地说，根据这个遍历，后来添加到树中(或出现在树中)的任何内容将出现在更接近有序集(绘画顺序)的末尾。这很重要，因为 CSS 根据项目接近末尾的程度对有序集合中的项目进行优先级排序，因为它按顺序呈现事物。较晚出现意味着它是较晚绘制的，更有可能出现在其他元素的“上方”。

由于全屏项目的堆叠上下文是在 z-index 等属性之后添加的，这导致全屏元素优先。考虑到全屏 API 的目的，这是有意义的，但这也是 **de** 将我们的模态优先化为不可见的。

幸运的是，有一种简单、非黑客的方法可以解决这个问题。该解决方案利用了这样一个事实，即当将元素设置为全屏时会修改堆叠顺序，全屏元素的同级项目会遵循 z-index 的正常用法。这可能比听起来要复杂一点，因为需要在全屏元素旁边/上方可见的元素必须重新追加到全屏元素的父元素。对于我们的例子，这不是一个问题，因为我们已经在事后将模型附加到相关动作的树上，并且可以简单地改变我们附加模型的位置。在其他情况下，您必须故意这样做。

我还在学习如何最好地利用堆栈上下文，所以如果有任何不正确的地方，我道歉。我很喜欢这个问题的一点是，这不是我们正在使用的库的问题，也不是普通的 Javascript 问题，而是数据结构问题！从我们遇到的普通问题中解脱出来。