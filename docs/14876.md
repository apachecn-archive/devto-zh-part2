# 需要多长时间？Git 知道。

> 原文:[https://dev.to/dmelidonis/how-long-will-it-take-git-knows-32hm](https://dev.to/dmelidonis/how-long-will-it-take-git-knows--32hm)

作为软件开发人员，我们所有的工作都围绕着一个源代码控制系统，无论是 [svn](https://subversion.apache.org/) 、 [hg](https://www.mercurial-scm.org/) 还是 [git](https://git-scm.com/) 。在我们为项目使用的每个存储库中，都有我们活动的痕迹、注释和时间戳，任何人都可以看到。几年前，我开始构建一个工具，允许我为一个工作项分配一个“咖啡杯大小”，然后使用与该工作相关的 git 提交并计算它需要多长时间。
[![Coffee cup sizes](../Images/8927e9b58340cb4c8dedf758caeedc46.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--4Ul4xSrb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/tj87d6pj66haw9upo9ug.png) 
我称之为 [GitCup](https://www.microsoft.com/store/apps/9NBLGGH4XFHP?cid=devbloga) ，它仍在开发中，但它的目的是帮助我用最少的努力生成更准确的时间估计。

### [](#why-you-might-ask)“为什么？”你可能会问。

我记得我工作的团队第一次决定开始使用 scrum 作为一种变得更加“敏捷”的方式。我们花了数不清的时间来争论我们的故事点是应该使用斐波那契数还是 2 的幂(1，2，4，8，16)。我们来回转换了几次，但我们不能同意哪一个更好。然后我们会一遍又一遍地争论一个故事是 4 分还是 8 分，这到底意味着什么，做起来是两倍的困难还是需要两倍的时间？你看，那时我支持斐波纳契范围(1，2，3，5，8，13)作为评价每个用户故事“复杂性”的尺度。当然，我错了。

几年后，在一家不同的公司和不同的团队，我发现自己处于混合看板/Scrum 风格的“敏捷”变体中。在某个任意的时刻，上层管理人员决定“敏捷”改造是新的“数字化转型计划”的第一步。他们聘请了一家咨询公司，我们的团队有了一位“敏捷教练”来指导我们。

### [](#pointless-story-points)无意义的故事点

我们开始使用计划扑克牌来评估我们的故事。我常常觉得我的 **5** 是别人的 **2** 。最后，如果只是为了避免显得愚蠢，每个人都会同意最资深的人。就在那时，术语[【冒名顶替综合症】](https://en.wikipedia.org/wiki/Impostor_syndrome)开始真正引起我的共鸣。事实证明，复杂性并不是一个非常客观的衡量标准。

我们的敏捷教练最初是我们的 scrum 大师。他有很多实践经验，我们都从他身上学到了很多。我们每天早上聚在一起讨论我们的进展，他会鼓励我们修改我们正在做的用户故事的估计。这样做的目的是为了尽早发现更具挑战性的故事。如果我们正在取得进展，我们会减少剩下的故事点；如果我们发现了一些不可预见的问题，并且最初的估计不再有效，我们会增加故事点。

### [](#time-matters)时间很重要

这在一段时间内有效，但很快他就去了另一个团队，我们开始看到 2 点故事被拖了几天，而 8 点故事有时在同一天内完成。很自然地，早上的谈话开始涉及关于每个故事“剩余时间”的问题，人们会开始互相问“今天能完成吗？”。我们已经用吉拉作为我们的电子版，所以过了一段时间后，我们开始在我们的故事中加入时间估计，而不是减少点数，而是减少剩余时间。所有突然出现的时间点再次被用作时间的近似值。除此之外，现在我们也有了实际的时间估计。

这让我很困扰。在计划过程中，我们花在辩论故事要点或争论剩余时间/天数上的努力，我们必须跟踪我们每天都在做什么以证明我们花在故事上的时间以及 Jiras 和时间表的每日更新(是的，我们也有这些)的事实，感觉像是一种巨大的浪费。不要误解我。我不在[【无估计】](https://twitter.com/hashtag/NoEstimates?src=hash)阵营。我很欣赏可信的评估对于规划我们的项目交付的价值。我只是希望我们没有那么多开销！

### [](#what-is-the-alternative-then)那还有什么选择呢？

那是我第一次想到使用我们的提交来跟踪我们的时间。我们的代码基于 [Subversion](https://subversion.apache.org/) ，这使得跟踪分支合并上的提交变得更加复杂，但是原理仍然是相同的:所有的历史都在那里，包括注释、时间戳和实际的代码更改。凭直觉，我知道一定有什么方法可以利用这些信息对未来的工作进行统计预测。很久以后，我发现了[概率预测](https://www.infoq.com/articles/probabilistic-project-planning)的概念，它可以用来根据以前工作项目的数据做出未来的预测。

然而，当时我找不到任何开箱即用的工具，也不愿意自己从头开始做一些东西。我们的团队因为其他原因而挣扎，所以我的调查没有进一步深入。git 库成为主流还需要几年时间，我会开发出 GitCup。

### [](#the-itch)痒

在某个时候，我去了一个新的团队。这一次，我们没有费心去跟随 scrum。这个团队很小，分布在许多不同的项目中。我们有一堆故事，我们会优先处理，并从列表的顶部开始工作。我们仍然会在早上聚在一起，谈论我们的进展，当然通常的问题会是:

“你认为这需要多长时间？”