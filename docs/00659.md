# 我应该选择 635000 个 npm 模块中的哪一个？

> 原文:[https://dev . to/ccleary 00/what-of-the-635000-NPM-modules-do-I-choose-3fgi](https://dev.to/ccleary00/which-of-the-635000-npm-modules-do-i-choose-3fgi)

***原载于 [coreycleary.me](https://www.coreycleary.me/which-of-the-635000-npm-modules-do-i-choose/)** 。这是我的内容博客的交叉帖子。我每一两周发布一次新内容，如果你想直接在收件箱里收到我的文章，你可以[注册我的时事通讯](https://www.coreycleary.me/about/)！我还定期发送备忘单、其他开发人员的优秀教程的链接以及其他赠品！*

如果您在节点或前端 JavaScript 世界呆过一段时间，您就会知道有成千上万的模块可供选择。

开发人员不断地问问题，表达痛苦，例如:

> “困扰我们的是选择哪些模块……”

> " X 模块和 Y 模块有什么区别，哪个更好？"

> “npm 很棒，但这些模块可能在 6 个月、1 年或更长时间内都没有用，这取决于它们的支持方式。”

通常问这样的问题，你会得到十种不同的答案。然后每个人都给你他们自己最喜欢的宠物模块，剩下的就是人们争论哪个是最好的。

在选择 npm 模块时很容易面临“分析麻痹”。有这么多的选择，新的被吹捧为“你真的应该切换到”它可以压倒选择一个正确的项目。而且这么多模块做相似(或相同)的事情也没什么帮助。

与其浪费时间四处搜索，梳理[npmjs.org](http://npmjs.org)，浪费更多时间不构建你的应用程序，不如让*知道在*的时候选择*哪些*模块会更好。

### 精选的名单

为了帮助解决这个问题，下面你会发现一个针对最常见问题类型的模块列表(例如，web 框架、模板、认证等)以及何时使用每一个模块。

对此有一些注意事项:您可能熟悉其中的一些甚至许多模块，但是有时您正在接触堆栈中您还没有接触的部分(可能是像身份验证或 Web Sockets 之类的东西),您需要知道哪些模块将完成工作。你可能有一个你认为更好的模块。您可能有一个用例/需求没有在这里介绍。我没有列出同一类别的 10 个不同的问题，而是缩小了范围，这样你就可以避免陷入分析瘫痪的陷阱。如果你认为你有一个没有被覆盖的用例，尽一切办法用研究来补充，但是这是为了让你更快地启动和运行。

这些模块的选择基于以下几点:

*   他们的工作完成得有多好
*   社区规模(对支持/故障排除很重要)
*   主动维护

如果你发现自己仍然没有足够的信息来做决定，我会建议 slant.co 和 nodejs.libhunt.com 帮助比较。

*注意:为了保持合理的范围，这些模块都考虑到了服务器端。许多都可以在客户机或服务器上使用，但这是“服务器优先”的方法。*

### 类别:

[HTTP 请求](#http-requests)
[Web 框架](#web-frameworks)
[验证](#validation)
[认证](#authentication)
[异步](#asynchronous)
[数据库](#database)
[进程管理](#process-management)
[Web Sockets](#web-sockets)
[API 文档](#api-documentation)
[Utilities/misc](#utilities)
[CLI](#cli)
[日志记录](#logging)

### HTTP 请求

*   *请求*:
    *   当您需要发出基于回调的 HTTP 请求时使用，例如，从一个 REST 服务到另一个 REST 服务。
*   *轴*:
    *   当您需要做出基于承诺的 HTTP 请求时使用
    *   注意:您可以使用请求-承诺，但是 axios 具有较少的依赖性，并且建立在本机承诺的基础上

### Web 框架

*   *快递*:
    *   当您希望为 API、网站或单页应用程序提供轻量级 web 框架时，请使用此选项
    *   您不介意使用开箱即用的回调来实现异步性
    *   您希望能够从与框架一起工作的广泛的模块生态系统中进行选择
    *   您需要一个大型社区来提供支持和故障排除
*   *Koa* :
    *   当你想要一个比 Express 更简单的框架时使用
    *   Koa 更像是一个中间件层，不提供模板或路由 OOTB，这使得它更适合 API 开发
    *   你想要异步/等待支持 OOTB
*   *哈皮*:
    *   当你想要一个比 Express 或 Koa 有更多“电池”,但没有 Sails 那么多“电池”的框架时使用
*   *风帆*:
    *   当你想要像 Rails 这样的东西时，使用它，这种东西包含了所有的东西(但是很多东西你可能不需要，这取决于你的应用程序)

### 验证:

*   *Ajv* :
    *   当您需要验证 JSON 时使用(比如来自 web 请求)
    *   您希望与应用程序的其他非 JS 部分共享这些模式(因为它是 JSON，所以您可以这样做)
*   *Joi* :
    *   当您需要验证输入并且喜欢` ` JavaScript const schema = joi . object()的样式时使用。keys({ id: joi.string()。guid()。必选()，用户名:joi.string()。alphanum()。最小(8)。必选()})；```而不是在 JSON 中定义模式
    *   你用的是哈比神(Joi 自带 OOTB)

### 认证:

*   *护照*:
    *   当您的网站或 API 需要认证中间件时使用
    *   您希望能够在多种身份验证类型(Oauth、脸书等)之间进行选择
    *   你需要管理会话

### 异步:

*   *异步(库)*:
    *   当您需要支持仅支持回调而不支持承诺的节点的旧版本时使用
*   *ES6 原生承诺(原生 JS，非 npm)* :
    *   当您使用高于 0.12 的 Node 版本时使用
    *   另一件要考虑的事情是你的团队对承诺的满意程度。2018 年，大部分开发者应该是。
*   *async/await(原生 JS，非 npm* ):
    *   当你逃离了回调地狱却发现了承诺地狱时使用
    *   你从承诺中得到了很多“然后”和“抓住”

### 数据库:

下面是一个混合的数据库驱动程序，ORM 和一个查询生成器。在使用 ORM 之前，我强烈建议首先确保您需要使用它。当您可以只使用原始 SQL 或查询构建器时，他们通常会添加另一个抽象层，这不一定会带来足够的回报。

*   *mysql，node-postgres* :
    *   当你不需要一个完整的 ORM，而是要用原始 SQL 查询你的数据库时使用(这些是驱动程序)
*   *node-mongodb-native* :
    *   当你不需要一个完整的 ORM，而是要直接查询 MongoDB 时使用
*   *猫鼬*:
    *   当您更愿意为 MongoDB 使用 ORM 时使用
*   *Knex* :
    *   当你不需要一个完整的 ORM 解决方案，而只是需要一些东西来简化代码中的查询时使用
    *   Knex 是一个生成 SQL 的查询构建器
    *   你有 Postgres、MSSQL、MySQL、MariaDB、SQLite3、Oracle 或 Amazon 红移数据库
*   *Objection.js* :
    *   您希望 ORM 支持 Knex 支持的一切，不使用查询 DSL(所以您编写的更接近原始 SQL)，具有基于 Promise 的 API 和良好的文档

### 流程管理:

比较一些流程经理的一个有用资源是[【http://strong-pm.io/compare】](http://strong-pm.io/compare)。*注意*:它们还包括 StrongLoop Process Manager，这很好，但是有点笨重。我建议在决定使用 StrongLoop 之前先检查一下解决方案。

*   *PM2* :
    *   当您需要一个进程管理器来处理服务崩溃时重新启动服务，并允许您控制群集时，请使用此选项
    *   *注意*:PM2 获得许可的 AGPL 许可证存在潜在的违规行为。这里有一些关于这个[的讨论。我的观点是它最有可能被使用。但是，如果您有任何问题/顾虑，请咨询您的法律部门，因为我不是律师。](https://opensource.stackexchange.com/questions/5179/can-one-use-agpl-application-without-copy-left-effects)
*   *永远*:
    *   当您需要一个进程管理器来处理服务崩溃时重新启动服务时使用
    *   您的部署规模较小(pm2 及其集群支持适用于较大规模的部署)。如果您只有少量的服务/进程，那么您可能永远都可以使用
*   *节点门*:
    *   当您希望监视应用程序中的任何代码更改并在本地开发时自动重新启动服务器时，请使用
    *   非常适合用于开发！

### Web 套接字:

对于 Web Sockets，我推荐 primus，而不是一个不同的列表。它支持所有主要的 Web Sockets 实现，并且得到了积极的支持，如果您需要一个不同的库，只需修改一行代码就可以轻松地换入和换出不同的库。

*   *骁将*:
    *   当您需要 Web Sockets，但不想被任何特定的 Web Sockets 实现所束缚时，可以使用它

### API 文档:

*   *Swagger-node* :
    *   当您需要记录您的 REST API 并能够针对端点测试请求时使用

### 公用事业/杂项:

*   *Lodash* *:*
    *   需要 JS 实用程序库时使用
    *   你用了很多 OOP
*   *拉姆达*:
    *   当您希望使用函数组合以更函数化的方式编程时，请使用
    *   你想要类似 lodash 的东西，但是在函数范式中
*   *时刻:*
    *   当您需要解析、验证、操作和显示日期/时间时使用
*   *UUID* :
    *   当您需要难以破解的随机、唯一的 id 时使用
*   *NVM:*
    *   当您希望能够在环境中安装的多个版本的节点之间切换时使用
*   *Fs-extra* :
    *   当您需要能够递归地' mkdir '、' rm -rf '以及节点中缺少的其他文件系统实用程序时使用
*   *节点邮件器*:
    *   当您需要从节点发送电子邮件时使用
*   Dotenv :
    *   当您需要将环境变量从. env 文件加载到“process.env”中时使用

### CLI:

*   *指挥官*:
    *   当您希望构建一个将所有参数作为命令行标志的 CLI 实用程序时，请使用此选项
*   *问询者*:
    *   当您希望构建一个按顺序获取选项的“交互式”CLI 实用程序时使用(类似于当您运行“npm init”时，它会询问您一系列问题来生成 package.json 文件)

### 日志记录:

*   温斯顿:
    *   当需要日志库和不同的日志输出时使用
*   班扬:
    *   当您需要一个日志库并且能够处理 JSON 作为唯一的日志输出时使用
    *   您希望为不同的组件、请求或功能使用不同的记录器(例如，这些记录器可能会以不同的方式解析事物)
*   摩根:
    *   当您使用 Express 并希望记录 HTTP 请求时使用
    *   *注意*:这个可以和 Winston 或者 Bunyan 一起使用。因为它是中间件，它知道如何处理请求并记录日志，但不像 Winston 和 Bunyan 那样处理日志输出的传输。

### 模板:

*   *帕格(原名杰德)*:
    *   当您需要一个易于阅读并且支持子布局块 OOTB 的服务器端模板引擎时使用
    *   你的输出只是 HTML
*   *中的 T1:*
    *   当您需要一个完全使用 JS 并允许空格缩进(Pug 不允许)的服务器端模板引擎时使用
    *   注意:不支持异步 JS 函数

### 测试:

*   *摩卡*:
    *   当您需要编写和运行单元测试时使用
*   *柴*:
    *   当您需要一个库来证明您在单元测试中的断言时使用
    *   *注*:这将与摩卡一起使用
*   *柴如约*:
    *   当你想证明你对承诺的断言时使用，而不是把断言放在`then`或`catch`中
*   否则:
    *   当您的测试需要一个模拟库时使用

### 工具:

*   *以斯多克*:
    *   当您希望从代码中生成 API 文档，并且正在使用较新版本的 JS 时，请使用
    *   默认情况下支持当前版本的 JS - targets `class ',所以如果您在代码中使用原型，请使用 JSdoc
*   *JSdoc* :
    *   当您想要一个支持 ES6 的代码 API 文档生成器时使用
    *   支持类和原型
*   ESlint :
    *   当您需要 linter 自动查找(并修复)代码中的语法和代码模式问题时使用

### 调试:

本机节点调试已经有了足够的基础，我建议使用现有的。几年前，引入一些 npm 模块是很有帮助的，您可能有一个特定的用例需要一个，但是现在有足够的原生支持，如果您没有在调试方面做任何疯狂的事情，那么省去额外的依赖项是有意义的。

### 结论

挑选模块可能会很难，但你只需要一些路径点就能搞清楚。当你浪费时间决定挑选什么或者甚至不知道从哪里开始时，使用这个指南来帮助你。

### 最后一件事！

我正在编写许多新内容，以帮助 Node 和 JavaScript 更容易理解。更容易，因为我觉得不需要像有时候那么复杂。如果你喜欢这篇文章，并发现它很有帮助[这里是再次链接](https://www.coreycleary.me/about/)订阅我的时事通讯！