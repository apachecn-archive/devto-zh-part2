# 在 Ruby 中测试异步线程

> 原文:[https://dev . to/app signal/testing-asynchronous-threads-in-ruby-3 ggl](https://dev.to/appsignal/testing-asynchronous-threads-in-ruby-3ggl)

线程和异步环境最初有点棘手。没有一个好的心智模型来组织互动，很容易陷入困境，以意想不到的结果收场。最重要的是，如果没有正确的工具或测试模式，测试异步代码会很困难。

将线程看作人，将共享对象看作可以拥有的“东西”,有助于组织多线程系统的工作。在这一集里，我们将通过一个例子来学习所有关于测试异步 Ruby 代码的知识。

如果你使用的是 Rails 或 Rack，或者任何一个作为 web 浏览器前端的应用程序，你就处于一个异步的环境中。齿条`#call`总是被异步调用。因此，不管您是否知道，很有可能您已经在使用多线程组件了。

## [](#testing-trigger-collect-and-check)测试:触发、采集和检查

通过遵循以下三个步骤的模式，可以同步测试异步回调 API*触发*、*采集*、*检查*。想象一下，如果每个线程都是一个独立的个体，而对象是一次只能由一个人拥有的东西。

我们将以蝙蝠侠和他的 7 套不同的衣服为例。因为这是一个实际的例子，我们可以理解当你要跑出去拯救这个城市的时候，知道是否所有的衣服都在阿尔弗雷德那里是很重要的。

## [](#example-laundry-day-at-the-batcave)例如:蝙蝠洞的洗衣日

例子是阿尔弗雷德洗蝙蝠侠的西装。SuitWashScheduler 是一个调度程序，它为每个清洗事件调用一个回调函数。调度程序在启动后一秒开始，以一秒的间隔进行七次回调。触发器是`SuitWashScheduler`的
创建。

```
class SuitWashScheduler
  def initialize(cnt)
    Thread.new {
      cnt.times {
        sleep(1.0)
        yield
      }
    }
  end
end 
```

## [](#collecting)采集

收集结果必须是线程安全的，以避免[竞争条件](https://en.wikipedia.org/wiki/Race_condition)。任何在多个线程间共享的对象都必须受到保护。保护是跟踪对象所有者的一种方式。只有所有者可以更改或查看对象。西装只能和蝙蝠侠一起在战斗中使用，或者和阿尔弗雷德一起洗。

为了保持友好，线程(在蝙蝠侠或阿尔弗雷德的比喻中)只在短时间内获得所有权，然后放弃所有权。一个`Mutex`通常用于跟踪主人。当计数器递增时，`SuitwashScheduler`回调将拥有结果计数器。在`SuitWashScheduler`线程中运行的回调表示当计数器命中目标时，所有的结果都已收到。

编写示例从设置一些全局变量开始。在实际应用中，全局变量将被类或对象属性所代替。

```
$main_thread = Thread.current
$mu = Mutex.new
$count = 0
$target = 7 
```

## [](#management-and-owners)管理和所有者

`$main_thread`和`$mu`用于管理线程并等待测试完成，而`$target`和`$count`用于跟踪测试结果。请记住，这是一个微不足道的测试，所以收集和检查结果必须简单。

测试从创建一个新的`SuitWashScheduler`实例开始，给初始化器一个迭代次数`$target`。在这种情况下，7 套衣服需要洗。
提供的块将在`SuitWashScheduler`线程中运行。对于每次迭代，`$count`递增并打印。

展望未来，我们意识到主测试线程也将检查`$count`，这意味着它也需要`$count`的所有权，因此需要一种获取`$count`所有权的方法。`$mu` `Mutex`实例是所有权令牌。在传递给`SuitWashScheduler.new`调用的块中，一个`$mu.synchronize`块占用足够长的时间来设置`$count`并检查结果。稍后会有更多关于结果的报道。

```
SuitWashScheduler.new($target) {
  $mu.synchronize {
    $count += 1
    puts $count
    $main_thread.wakeup if $target <= $count
  }
} 
```

## [](#check-are-all-suits-done)检查:西服都做好了吗？

回到主线程，我们需要等待测试完成。蝙蝠侠需要在所有 7 套衣服完成之前等待。需要检查两个条件:测试按预期更新了`$count`,或者蝙蝠侠厌倦了等待测试结束并超时。在检查`$count`是否已经到达`$target`之前，需要`$count`的所有权。就像在`SuitWashScheduler`的块中一样，使用了对`$mu.synchronize`的调用。

但这是不对的，如果我们锁住主线程，`SuitWashScheduler`线程怎么能改变`$count`？幸运的是，我们有一个巧妙的技巧来解决这个问题。`Mutex`类有一个`#sleep`方法，它放弃所有权，等待直到超时或者被唤醒。一旦通过超时或者对主线程`$mu`的`#wakeup`调用被唤醒，就会在继续之前再次尝试获取所有权。一旦获得所有权，就可以检查结果，并确定测试的通过或失败状态。

```
$mu.synchronize {
  $mu.sleep($target + 1)
  if $target != $count
    puts 'FAILED'
  else
    puts 'Passed! All suits are washed and clean'
  end
} 
```

如果您想更深入地了解这一点，您可以通过尝试创建多个调度器来让这个例子更有趣一些，并看看互斥体是如何防止`$count`变化发生冲突的。就好像蝙蝠侠送了一些西装给阿尔弗雷德洗，送了一些给干洗店。确保更改逻辑，以确保`$target`检查是所有预期产量的总和。

## [](#roundup)综述

有了正确的心智模型，使用线程和异步环境变得更加容易。在这篇文章中，我们用人来比喻线程，用物理对象(套装)来比喻共享对象，一次只能由一个线程或一个人拥有。我们认为这种抽象方式更容易理解和记忆。

我们希望这些例子能让你记住 async 的机制，但是我们希望蝙蝠侠在他所有的衣服都被洗的时候跑出来的画面不会让你记住太久。

PS 如果你看完了博客上所有蝙蝠侠的比喻，请告诉我们。

彼得·奥勒创造了相当多的高性能代码，并且不时地写一些关于它的文章。他制作了 Agoo gem，这是一个非常酷的高性能 HTTP 服务器。