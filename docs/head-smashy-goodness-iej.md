# 令人头晕目眩的善良

> 原文：<https://dev.to/ferricoxide/head-smashy-goodness-iej>

作为一名自动化工程师，生活中的一大乐趣就是当你不得不“拆分”别人组装的自动化时。总的来说，我认为自己是个糟糕的程序员。尽管看到了那些自认为是优秀程序员的人写的垃圾，这一评估还是被忽略了。我想这是你把自己和什么比较的问题:有些人把自己和他们开始的地方比较；我把自己比作一些我认为“专家”在哪里的想法。

无论如何，我最近的项目让我“改进”了另一个团队拼凑起来却没有时间改进的自动化。我看着他们留给我“改进”的代码，不禁怀疑，在宇宙中的所有时间里，他们不会有意义的改进。哦，好吧:这给了我一个学习和使用新工具集的借口。

我的第一个任务是改进他们 Sonarqube 软件的部署自动化。我离我希望的改进还有很长的路要走，但我终于明白了为什么他们从快照进行 RDS 部署要花这么长的时间。你看，当*我*写 RDS 部署-自动化，我指定*一切*。我是个控制狂，所以我就是这样。遗憾的是，我认为其他人也会采取类似的方法。糟糕的假设。

在尝试调试为什么从 RDS 快照部署一个小型(100GiB)数据库要花 90 分钟的大部分时间时，我发现 RDS 要花一天的时间才能将一个作为“标准”(“磁性”)磁盘类型实例启动的实例转换成一个作为 GP2 运行的实例。显然，在编写原始模板时，他们还没有指定 RDS 实例类型。未能指定意味着 RDS 使用其默认类型...也就是“标准”。

从该模板部署之后，他们(显然)手动将 RDS 实例类型更新为 GP2。我假设情况是这样的，因为围绕 RDS 的自动化从未被修改——在任何时间点都没有进行“栈更新”。事实上，在它们的栈定义中甚至没有任何东西允许随后重新选择实例的存储类型。

有趣的是，当一个人从另一个 RDS 的快照启动一个新 RDS 时，AWS 会尝试确保新 RDS 是相同的存储类型。如果快照是对启用 GP2 的实例拍摄的，那么它希望让新的 RDS 使用 GP2。这一切都很好:它防止了快照源代码和新 RDS 实例之间出现意外的不同性能特征。

不幸的是，在模板没有覆盖默认设置的情况下，当您从该快照进行部署时，就会陷入可怕的境地。具体来说，CloudFormation 将使用默认的“磁性”存储创建一个 RDS 实例类型。然后，创建实例并恢复数据后，RDS 会尝试转换新实例，以使用与快照源匹配的存储类型。您坐在那里，盯着 RDS 输出，想知道“您到底在‘修改’什么，为什么要花这么长时间？？?"。不经意地盯着屏幕足够长的时间，您可能会注意到挂起的修改任务是“存储”。如果您的等待麻木了，您会有一个“哦，狗屎”的时刻，从同一个快照手动创建一个新的 RDS，小心地匹配新实例和快照的存储类型。然后，当手摇 RDS 在自动化部署达到其“就绪”状态之前很久就达到就绪状态时，您会带着某种程度的怀疑进行观察。

哦，好吧，至少我现在知道*为什么*这么慢了，并相应地“改进”了模板。看起来我可能要等 10 分钟才能看到快照来源的 RDS，而不是之前的 90+。