# 编译器 106 -优化器

> 原文:[https://dev.to/lefebvre/compilers-106 优化器 ig8](https://dev.to/lefebvre/compilers-106---optimizer--ig8)

优化器“改善”了 IR，但这可能意味着很多不同的事情。改进可能意味着“运行得更快”或“使用更少的内存”。或者，您可能希望优化内存访问时间，因为 CPU 的速度非常快，有时重复计算比计算一次、存储并稍后访问更有效。

编译器系列:

*   [编译器 101–概述和词法分析器](https://dev.to/lefebvre/compilers-101---overview-and-lexer-3i0m)
*   [编译器 102-解析器](https://dev.to/lefebvre/compilers-102---parser-2gni)
*   [编译器 103-语义分析器](https://dev.to/lefebvre/compilers-103--semantic-analyzer-540k)
*   [编译器 104–IR 生成](https://dev.to/lefebvre/compilers-104---ir-generation-39e8)
*   [编译器 105–后端概述](https://dev.to/lefebvre/compilers-105---back-end-overview-15nj)

优化器对 IR 代码进行一系列转换，通常是多次转换。LLVM 提供对这些过程的完全控制。

并不是所有的 LLVM 优化都能给 Xojo 代码带来好处。我们已经将 LLVM 可用的许多复杂的优化设置提炼为对 Xojo 代码有用的三个选项，您可以从共享的构建设置中进行设置:默认、中等和积极。

默认优化进行最小程度的优化，以获得最快的编译时间。

“中等”设置进行了更多的优化，主要是为了减少数学计算所需的时间，这会导致编译时间稍微变慢。

激进设置进行了更多的数学优化，以进一步减少计算时间，但也大大增加了编译时间。

优化旨在创建与原始代码等效的东西。最终的结果是一样的，即使这样做的手段可能会非常不同。例如，优化器可能会确定它应该进行一次移位，以将整数数学运算作为单个操作，而不是一系列的加法操作。这可能会产生更小、更快的代码，但优化器可能需要更长时间来处理代码，以便做出这一决定。

为任何代码确定“最佳”优化从技术上来说都不是一个可解决的问题(np-hard)，因此优化人员使用“启发式和挥手”的组合。“挥手”意味着编译器认为这是正确的，但没有真正的方法来证明它。试探法仅仅意味着当发现相似的代码时，使用已知在以前的代码中有效的优化。

## [](#constant-folding)恒折叠

恒定折叠是可以实现的优化的一个简单例子。

这实际上意味着优化器预先计算常量表达式，以减少执行时间，并节省堆栈和寄存器空间。

例如:

```
a = 1 + 2 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

可以替换为:

```
a = 3 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

当然，并不是所有的事情在你的代码中都很明显。

## [](#optimization-issues)优化问题

某些类型的代码会使优化器的工作更加困难。这些特殊的 Xojo 特性会给优化器带来挑战:

*   异常处理:使事情变得困难，因为你不知道函数调用可能在哪里返回。
*   内存管理:当变量超出范围时，Xojo 具有确定性的对象销毁，这迫使优化器必须更紧密地跟踪事物。
*   自省:自省的使用需要大量的元数据保持可用，以便可以在运行时引用。
*   线程:协作线程让步会影响循环和其他事情。Xojo 是一种“安全”的语言，它做了许多事情来确保你的应用程序不会崩溃(而不是引发异常)，比如 Nil 对象检查、堆栈溢出检查、边界检查等。所有这些都限制了优化器的能力。
*   插件:因为这些是预编译的，所以优化器会忽略它们。

在第 7 部分中，我将介绍优化器如何展开循环。敬请关注。