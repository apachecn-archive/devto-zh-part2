# 并发和自动冲突解决

> 原文：<https://dev.to/frosnerd/concurrency-and-automatic-conflict-resolution-4i9o>

# 简介

现代软件应用程序通常需要可靠和可伸缩。通过将多个不可靠的组件组合成一个更大的分布式系统，我们可以获得比单个组件更高的可靠性和可伸缩性。

然而，与单实例部署相比，分布式系统更难推理、正确实现和维护。在分布式系统中，您必须处理许多问题:

*   不可靠的时钟
*   无限网络延迟
*   有限的网络带宽
*   非静态成员集
*   异质成分
*   任意进程暂停
*   ...

在这篇文章中，我们想要关注一个特殊的问题:*并发和冲突*。如果两个操作彼此不知道，则它们被认为是并发的。并发操作可以交错执行，也可以顺序执行——它们之间没有有意义的顺序。并发是关于一个系统如何被*设计*，不应该与*并行*混淆，后者定义了一个系统如何*操作*，即同时运行操作。

每当你处理并发性时，你很可能不得不处理冲突。每当一个资源被同时修改时，即被多个并发操作修改时，就会发生冲突。我们可以从非常不同的抽象层次来看待并发性和冲突:我们可能在谈论两个人编辑同一个文档，两个进程增加数据库中的同一个计数器，或者两个 CPU 内核修改同一个内存地址。

如何处理矛盾？一种常见的策略是使用同步技术(比如锁定)来避免它们。考虑一个桌面文本处理应用程序:每当有人打开一个文档，它就会被锁定，不能被任何人修改。数据库通常支持客户端的显式锁定，但也使用内部锁定来隔离事务。

锁定的主要缺点是，根据系统中争用的数量，进程可能不得不暂停执行，等待锁被释放。您需要考虑和处理死锁，以防两个进程正在等待另一个进程持有的锁。如果数据库中的争用率很高，事务吞吐量可能会受到影响。如果一个 Microsoft Excel 文档的争用率很高，人们可能会开始争吵:

[![word locking](../Images/960d6d95da1bc1d6af751216499e0a38.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--jbDZoYjk--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/ew2xzx3tyzdt71ay3c64.png)

然而在某些情况下，我们可以不需要任何同步。例如:像 Google Docs 或 Etherpad 这样的协作编辑器，像 Git 这样的分布式版本控制系统，或者像 DynamoDB 或 Cassandra 这样的分布式数据库，在没有任何同步的情况下处理(一些)冲突。

该职位的其余部分结构如下。首先，我们想大致了解一下冲突解决的概念，讨论两种常用的处理冲突的技术的优缺点。之后，我们将介绍两种提供自动冲突解决的替代方案。我们通过总结主要发现来结束这篇博文。

# 处理矛盾

## 合适的工作工具

有许多不同的算法和技术可用于冲突解决。找到正确的算法需要你非常仔细地看你的问题。这里有几个你可能想问自己的问题:

*   你预计会发生多少冲突？冲突是例外还是经常发生？
*   有多少方能够同时进行修改？
*   涉案各方之间有什么联系？处理发生在同一台机器上的冲突可能比通过不可靠的网络连接解决冲突更容易。
*   丢失数据可以吗？如果通过简单地选择一个冲突的更新并丢弃所有其他的更新来解决冲突是可行的，那么您可以相当容易地达到一致的状态。

如果你意识到你的需求，你可以从许多可能的技术或算法中选择一个来处理冲突。重要的一点仍然存在:为了处理冲突，我们可能必须首先发现它们。幸运的是，有不同的方法可以通过跟踪某种形式的修改历史来版本化资源更改。这可以实现，例如，像在 Git 中那样明确跟踪所有更改的完整历史，或者像在 DynamoDB 中那样使用向量时钟[1，2]。

首先，让我们来看两种“解决”冲突的方法，它们易于实现，但有一些明显的缺点:*丢弃并发性*和*解决委托*。

## 丢弃并发

有时也被称为*最后一次写入获胜* (LWW)，这种技术通过丢弃冲突中涉及的所有操作来处理冲突。例如，它在 Cassandra 中用于解决多个副本上发生的冲突更新。明显的缺点是有效地解决冲突意味着丢失数据。

使用这种技术时，您应该确保尽可能避免冲突，并准备好处理丢失的更新。在 Git 中，通过使用命令行参数`--theirs`或`--ours`,这种技术也是[可用的](http://gitready.com/advanced/2009/02/25/keep-either-file-in-merge-conflicts.html),但是你应该知道你在做什么，以免让你的同事不安。

## 决议授权

解决方案委托通过在下一个读取请求时返回值的两个版本，并要求客户端解决冲突，使任何检测到的冲突显式化。例如，如果合并算法不能通过停止合并并要求用户手动解决冲突来自动合并同一文件的两个版本，则 Git 使用这种技术。

虽然比以前的技术更优雅，但解析委托是有代价的。首先，冲突检测是一个昂贵的操作。维护一个完整的变更历史对于一个源代码库来说是可行的，但是对于一个数据库来说却不可行。向量时钟效率更高，但每次写入仍会产生操作开销。其次，通过委派冲突，你并没有真正解决它。问题只会转移到别人身上。

幸运的是，有其他替代方法不会丢失任何更新，但仍然可以在没有授权的情况下解决冲突。让我们来看两个显著的自动冲突解决技术的例子:*操作转换*，和*无冲突复制数据类型*。

# 自动解决冲突

## 运算转换

操作转换(OT) [3]旨在实现协作文本编辑器的一致性。多年来，研究人员开发了不同的扩展和变体，结果产生了 Google Wave 等应用程序。

OT 背后的主要思想是通过共享客户端执行的操作并让每个客户端异步应用它们，来保持客户端同步执行并发修改。这样，所有客户端最终都应该达到相同的一致状态。如果操作到达客户端时，它已经修改了文档本身，这可能会导致与传入操作的冲突，那么就会出现问题。这就是*转换函数*发挥作用的地方。

考虑下图所示的例子:客户 *A* 和 *B* 都在同时修改文档“abc”。 *A* 想在位置 0 插入字符“x”(*O1 = Ins(0，“x”)*)。同时， *B* 正在删除位置 2 的字符“c”(*O2 = Del(2，“c”)*)。

[![operational transformation](../Images/58205bff4aa84c663a2dbd89366f2603.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--caLLopmx--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/2uq4596z6y7vd0ljxthq.png)

现在两者都交换了它们的操作，以使另一个客户机能够跟上修改。然而，当 *A* 接收到删除操作时，该字符不再位于位置 2。这就是为什么所有的远程操作都要通过一个转换函数 *T* 来传递。在我们的特定示例中， *O2'* 是通过转换 *O2* 给定 *O1* 来计算的，在这种情况下，它将要删除的字符的位置校正为 *3* ，因为前面的操作 *O1* 在更早的位置插入了一个字符。

尽管在我们给定的例子中，应用转换函数看起来相当琐碎，但是证明给定转换函数的正确性是非常困难的。[4]发表论文的证明后来被发现是不正确的，OT 算法被证明是非常难以实现的。然而，有一种替代 OT 的方法正在积极研究中:无冲突复制数据类型。

## 无冲突复制数据类型

无冲突复制数据类型(CRDT) [5]是一种可以在并发应用程序中复制而无需手动解决冲突的数据结构。根据实现的不同，更新可以作为增量发送(对应于 OT 中的操作)，或者通过共享完整状态来发送。如果您的客户端经常通信，那么只共享单独的操作会更有效。然而，如果通信是通过非常不可靠的网络进行的，例如移动或卫星，则每隔一段时间发送完整的 CRDT 可能是更好的选择。

CRDTs 的主要思想与 OT 的思想相似。不同之处在于，客户端不必转换传入的消息，因为它们已经包含了解决与本地状态冲突所需的所有信息。在 OT 中，客户机必须明确地记住以前的操作，然后根据这个历史转换新的操作，而 CRDTs 在数据结构中保存足够的信息，以创建无需任何转换就可以合并的操作。

查看上一节的协作文本编辑器示例，我们可以使用所谓的序列 CRDTs。复制可增长数组(RGA) [6]是我们现在要仔细研究的一个例子。我在观看一个关于 JSON crdt[7]的会议时偶然发现了它。

下图说明了我们的两个客户端是如何同时修改文档“abc”的。然而，这一次我们不是将文档表示为简单的字符串，而是为每个位置添加一个惟一的标识符。该标识符，如 *A1* ，由一个全球唯一的客户标识符( *A* 和一个客户唯一的数字标识符( *1* )组成。

[![crdt](../Images/1d36e73e96b273686b39c0ebc18fcf40.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--FgyFnB_8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/j8sr3zxnasqaiprcd65t.png)

每当客户端应用操作时，它可以通过标识符而不是位置来引用字符。因为标识符是唯一的，所以当被另一个客户机接收时，操作仍然有效，即使同时发生了并发的修改。如果客户端 *A* 告诉 *B* 它在 *A0* 之后插入了*【x】*， *B* 知道在哪个位置插入。删除以类似的方式发生，但是我们实际上并没有从数据结构中删除字符，而只是用一个所谓的 tombstone 将它标记为已删除。

两个悬而未决的问题仍然存在:我们如何分配新的标识符，以及我们如何处理在同一位置的两个并发插入？

如下生成新的标识符:每个客户端跟踪与其客户端 ID 相关联的最高数字标识符。每当它插入一个新字符时，它就增加最高数字标识符，并分配一个由它自己的客户机 ID 和增加的数字组成的新标识符。

同一位置的并发插入需要以一种导致一致状态的方式来解决。假设 *A* 和 *B* 都想在 *A0* 后分别插入*【x】*和*【y】*。如果我们应用没有任何特殊规则的运算， *A* 会以 *"xyabc"* 结束， *B* 会得到 *"yxabc"* 。因为没有正确的答案，所以这实际上只是一个为所有客户端一致地决定一个版本的问题。为此，如果在下一个位置没有更高的标识符，我们只在请求的位置插入。否则，我们继续向右走，直到找到一个具有较小标识符的位置，并在那里插入。因为 *B4* > *A4* ，所以最后的文档会是*【yx ABC】*。

除了 RGA，还有许多 CRDTs 供您使用。 [Akka 分布式](https://doc.akka.io/docs/akka/2.5/distributed-data.html)模块，例如，当在 Akka 集群模式中使用时，提供基于 CRDTs 的计数器、集合和映射以及不同的一致性保证。 [Redis enterprise](https://redislabs.com/docs/under-the-hood/) 提供基于 CRDT 的复制架构。从版本 2.0 开始， [Riak](http://basho.com/posts/technical/introducing-riak-2-0/) 在他们的投资组合中有了基于 CRDTs 的类型。

然而，CRDTs 并不是灵丹妙药。它们只适用于某些特定的问题，并且会导致额外的存储开销，因为它们需要跟踪数据结构中足够的历史信息，以便能够合并传入的操作或状态。

# 结论

我们已经看到分布式系统带来了许多不同的挑战。由于节点间不可靠的通信，分布式系统中的并发变得更加难以处理。如果两个进程同时修改同一个资源，就会发生冲突。

为了解决冲突，我们可能必须首先检测它们。这可以通过记录某种形式的历史来实现。一旦我们检测到冲突，我们可以自动解决它，或者将冲突解决委托给下一级，例如应用程序代码或用户。虽然丢弃除一个冲突写入之外的所有冲突写入是一种常用技术，但它会带来数据丢失。

承诺不丢失数据的自动冲突解决技术，如 OT 或 CRDTs。然而，我们并不是免费获得这些优势的。事实证明 OT 很难正确地推理和实现。CRDTs 有很大的内存开销，因为它们在数据结构中显式地存储一些历史信息。遗憾的是，OT 和 CRDTs 都只适用于特定的问题集，没有放之四海而皆准的解决方案。

你以前用过 OT 或者 CRDTs 吗？您曾经丢失过数据而不知道您的应用程序使用 LWW 来解决冲突吗？请在评论中告诉我你的想法。

# 参考文献

*   [1]科林·j·菲奇(1988 年 2 月)。“保留部分顺序的消息传递系统中的时间戳”(PDF)。在 k .雷蒙德(编辑。).继续。第 11 届澳大利亚计算机科学会议(1988 年，ACSC)。第 56-66 页。检索于 2009 年 2 月 13 日。
*   [2] Mattern，1988 年 10 月)，“虚拟时间和分布式系统的全局状态”，m .科斯纳德，Proc .并行和分布式算法研讨会，法国波纳斯城堡:爱思唯尔，第 215–226 页
*   [3]埃利斯，C.A 吉布斯(1989 年)。“群件系统中的并发控制”。ACM SIGMOD 记录。18 (2): 399–407.
*   [4]和李锐(2010)。“协作编辑系统的基于可接受性的操作转换框架”。19 (1): 1–43.
*   [5]夏皮罗，马克；普雷吉亚，努诺；卡洛斯·巴克罗；Zawirski，Marek (2011)，无冲突复制数据类型，计算机科学讲义，6976(Proc 13 国际研讨会，SSS 2011)，法国格勒诺布尔:施普林格柏林海德堡，第 386–400 页
*   [6]Roh . g .、Jeon m .、Kim j . s .和 Lee j .，2011 年。复制的抽象数据类型:协作应用程序的构建模块。并行与分布式计算期刊，71(3)，第 354-368 页。
*   [7] Kleppmann，m .和 Beresford，A.R .，2017 年。无冲突复制的 JSON 数据类型。IEEE 并行和分布式系统汇刊，28(10)，第 2733-2746 页。