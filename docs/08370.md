# SMP 就像 1-2-3 一样简单

> 原文:[https://dev.to/patricklafferty/smp-is-as-easy-as-1-2-3-27ek](https://dev.to/patricklafferty/smp-is-as-easy-as-1-2-3-27ek)

*(还有其他可以自己讲的爆笑笑话)*

最初发布于[https://patricklafferty . ca/blog/2018/07/20/SMP-is-as-easy-as-1-2-3/](https://patricklafferty.ca/blog/2018/07/20/smp-is-as-easy-as-1-2-3/)

对称多处理( [SMP](https://en.wikipedia.org/wiki/Symmetric_multiprocessing) )是我目前正在为[土星](https://saturn-os.org)探索的一大特色。我很早就实现了多任务，因为这是微内核设计的关键部分，然而直到现在，一切都在一个内核上运行。这是典型的并发性与并行性的比较，仅仅因为事情并发运行并不意味着它们同时运行。添加 SMP 支持需要仔细的前期设计(哎呀)或大量的后续重构。在对 Saturn 做任何进一步的改进之前，我想确保它有一个坚实的核心基础，所以我现在就开始重构，尽管这仍然是可行的。

# 最初有自举处理器

我真的很好奇多核到底是如何工作的，以及你是如何设置它的。我的意思是，我们都知道多线程和多个进程以及在内核间分配工作，但操作系统实际上是如何协调这些工作的呢？计算机第一次启动时会发生什么？

乍一看，这似乎很简单。在启动时，固件运行一些测试，并做一些幕后工作，并最终将控制权交给引导加载程序，然后引导加载程序加载操作系统。当您拥有多核 CPU 时，固件会挑选一个工作核心作为“主”CPU，称为“引导处理器”(BSP)，并将其余核心(或 SMT 情况下的硬件线程)视为“应用处理器”(ap)。它在[真实模式](https://en.wikipedia.org/wiki/Real_mode)下启动每个 AP，清除中断标志，然后暂停每个 AP。与此同时，BSP 继续进入您的内核。

# [](#interprocessor-interrupts)处理器间中断

此时，我们所有的应用程序都暂停了(没有运行任何代码)，不会响应正常的中断/异常。幸运的是，有一种特殊类型的处理器间中断或 IPI，用于促进 CPU 之间的通信。通过发送特定序列的 IPI，我们可以唤醒我们的 AP 并让它们做有用的工作。为此，我们需要使用一个蹦床。

还记得我说过 APs 在实模式下启动吗？16 位无保护、无分页、分段的内存。此时，我们的 BSP 要么处于 32 位保护模式，要么处于启用分页的 64 位长模式。我们不能只让 BSP 分配一堆数据结构并把它们交给 AP，因为它不能寻址它们，因为我们只能访问第一个 1MB 的 RAM。蹦床可以让我们避开这个问题。

蹦床是一小段代码+数据，它将 AP 配置成有用的。它基本上是内核必须做的事情的读者文摘版本——设置 GDT、启用分页等——而不真正关心细节。Ie 只是填充了进入保护模式所需的最少内容，因为一旦进入保护模式，我们将替换那些内容或者使用内核已经设置好的内容。

BSP 在低位地址分配一小块内存，用于存储 AP 要使用的重要地址，其中包括堆栈指针、在保护模式下调用一次的函数地址以及一个标志，它将不断检查 AP 以修改该标志来指示进度。BSP 和 AP 通过修改标志并在继续之前等待它变为特定值来相互通信。一旦这个舞蹈完成，AP 停止并等待 BSP 完成所有剩余 AP 的初始化，然后向它发送一个中断。

# [](#locad-nda-lok-or-lock-and-load)Locad nda lok(或:锁定和加载)

既然我们有多个处理器想要处理事情，我们需要同步任何可以从多个任务访问的东西。由于微内核的微部分，没有多少数据结构可以被多个进程修改。说结构是方便的全局变量，现在我有机会重新设计它们。

由于这些内核变量的性质以及它们的访问方式，我决定实现[自旋锁](https://en.wikipedia.org/wiki/Spinlock)。一把旋转锁就像广告上说的那样:“我们能获得这把锁吗？没有吗？好吧，我们现在能拿到这把锁了吗？没有吗？好吧，...”。本质上，它只是不断地检查循环中的一个条件，如果您只希望等待几百个循环，那么最好使用它。互斥和更复杂的机制有它们的位置，中断服务程序的中间不在其中。

自旋锁用于几个关键领域，以同步访问任务的邮箱、调度程序的运行队列或任务创建。如果不用锁会怎么样？这一部分的标题是一个轻松的例子，更现实的是，整个系统崩溃，你坐在 GDB，不知道发生了什么。

# [](#schedulers-directors-and-bears-oh-my)调度、导演、熊，天啊

最初，Saturn 只有一个调度程序来控制当前正在运行的任务。添加更多的 CPU 意味着支持多个调度器，每个调度器都有自己独立的运行队列和阻塞队列。第一次设计迭代有一个复杂的过程，当调度程序注意到一个被阻塞的任务可以运行时。它将检查所有其他调度程序，看是否有任何程序可以接受这个任务，然后将这个任务注入到该调度程序的运行队列中。同样，如果调度程序用完了任务，它会尝试从另一个任务中窃取。

这很有效，就像每个月的第二个星期二一样。我决定采用一种更简洁的方法，添加第二级调度程序:director。控制器是调度计划程序的主/元计划程序。不同于每个调度程序都有自己的必须单独管理的阻塞队列，控制器将是阻塞任务的单一控制点。对于睡眠时间很短的任务，调度程序仍然有自己的睡眠队列。

这大大简化了事情，同时也更加安全。现在有一个单一的入口来安排任务:把它交给主管，他会为你找到最好的安排者。

# [](#aftermath)余波

这篇文章标志着对土星的第 800 次承诺，使它成为我开始的运行时间最长的项目之一。目前，我正在进行 64 位重写，并将在此过程中添加大量测试。你可以看看[的源代码](https://github.com/patrick-lafferty/saturn/)，或者访问【saturn-os.org】的[了解更多。](https://saturn-os.org)

如果你有任何问题或意见，纠正或建议，批评等等，我很乐意通过电子邮件或在下面的评论中联系你。我总是乐于学习新事物，纠正不好的事情。

我的系列文章的第二部分*操作系统的乐趣*，在这里我写了我写自己的操作系统*土星*的经历。

*   第 1 部分:[操作系统的乐趣](https://patricklafferty.ca/blog/2018/04/03/the-joy-of-operating-systems/)