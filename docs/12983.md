# 用一个比萨饼餐馆的例子来形象化 JavaScript 事件循环

> 原文:[https://dev . to/presto 412/visualizing-the-JavaScript-event-loop-with-a-pizza-restaurant-analogue-47a 8](https://dev.to/presto412/visualising-the-javascript-event-loop-with-a-pizza-restaurant-analogy-47a8)

考虑一家披萨店。
我们目前从一个客户那里收到的订单有两种类型——一种是精心制作的订单，需要一个橄榄浇头的披萨(1)、一个奶酪馅的披萨(2)和一个大底的披萨(3)。
另一个只是简单的一个，蛋黄酱(a)配大蒜面包(b)。

接到订单后，**主厨**开始制作第一个披萨，先拿一个大底(3)，加入馅料(2)，然后加入橄榄配料(1)。
同一个厨师也要做大蒜面包。经理突然意识到餐厅的蛋黄酱已经卖完了。经理将“获取蛋黄酱”任务**添加到**图表**中，并派唯一有空的**差使**去取一些。**

从技术上来说，如果订单被集中在一起并一起交付，顾客将不得不等到跑腿的去五个街区外的超市买蛋黄酱，并交给厨师来完成订单。但这是一家餐馆，顾客不需要一次把整个订单送到他们手中。

厨师决定继续做比萨饼，烤好后送给顾客。完成后，跑腿的拿着蛋黄酱来了，厨师拿了一些大蒜面包(b ),在上面加了蛋黄酱(a ),然后送到顾客面前。

在这里，我们了解了 Javascript 的哪些内容？

*   客户的*订单*(做披萨+做蒜蓉面包)就是 JavaScript 代码中的**函数**。
*   订单*细节*仅仅是关于如何定制比萨饼和面包，它们可以被视为被称为制作比萨饼内部的函数——订单是从上到下的——配料、馅料和尺寸。这些细节基本上代表了以相反顺序执行所有这些事件的**调用栈**。
*   餐馆里没有蛋黄酱——这是一个被触发的**事件**，它被称为一个**异步函数**，从超市里取蛋黄酱。因为餐馆不需要一起发送整个订单，所以他们以相反的顺序完成**调用堆栈**中的任务，如上面的故事所示。
*   这里的*经理*是**事件表**——他的工作是按照时间顺序记录所有发生的不幸(事件)。
*   *跑腿的*是**事件队列**，也就是说，如果他已经被要求取东西，并且要求一个新的项目，该项目必须等到跑腿的取旧的项目。
*   *主厨*就是**事件循环**，也就是不断的下订单(执行所有功能)。
*   *餐厅*是一个**浏览器**，它不需要冻结直到所有的内容都被加载，也不需要在一个完成之前等待其他事情完成。(不需要一起提供整个订单)

所以本质上，**事件循环**检查**调用堆栈**是否为空，如果是，则查看**事件队列**。如果里面有什么东西，它就把它添加到调用堆栈中并执行它。事件循环不断运行，直到他们的轮班结束(加载浏览器内容/关闭浏览器)。**事件表**跟踪所有已经被触发的**事件**，并将它们发送到事件队列中执行。

这是我解释事件循环的尝试，让我知道你是否觉得这个类比有趣！