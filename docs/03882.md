# 作为一名 Vue 开发者，你会犯这些错误吗？

> 原文:[https://dev . to/Napoleon 039/are-you-committing-these-missons-as-a-vue-developer-566k](https://dev.to/napoleon039/are-you-committing-these-mistakes-as-a-vue-developer--566k)

我最近订阅了一个关于 web 开发的很棒的播客，叫做[全栈广播](https://twitter.com/fullstackradio)，作者是 Adam Wathan。Vue.js 中有一集是关于**反模式的，来自 Vue 核心团队的 Chris Fritz 给出了很多关于 Vue 架构和 Vue 开发人员经常犯的一些错误的很好的提示。我没有包括所有谈论的内容，所以一定要听完整的播客片段，听一些精彩的对话和赞美。我将在本文末尾包含一个链接。**

这一集谈论了各种各样的话题。以下是我的笔记:

## 状态管理和事件:

对于复杂的状态，Vuex 是最好的。人们通常使用*事件总线*来管理状态，让组件订阅事件。但最终发生的是创建了大量的重复状态，这在试图保持一切同步时会产生一系列问题。在调试的情况下，没有办法知道某个变化来自哪里。

Vuex 提供了许多选项，并使事情可追溯。Vue DevTools 中有一个单独的 Vuex 选项卡，对于调试和原型制作非常有用。我们可以跟踪不同的状态变化，改变风格，并与 HMR(热模块重装)，看到立即发生的变化。对于小型项目，组件之间可能需要一两个事件进行通信，事件总线很好。

如果您发现自己正在做这些事情中的一个或多个，那么这是一个很好的迹象，表明您应该开始使用 Vuex 来管理项目中的复杂状态:

1.  当你一直传递很多道具给一个组件时
2.  让父组件跟踪子组件的状态，以便兄弟组件可以通过父组件进行交互
3.  当传递给一个组件的属性不被该组件本身使用，而是被嵌套在其中的另一个组件需要时

* * *

另一个禁忌是使用`this.$parent`而不是发出一个事件来访问和操作父节点的状态。这可能看起来微不足道，因为我们清楚地知道子组件在父组件中改变了什么。但是，如果项目是一个巨大的项目，特别是已经进行了相当长一段时间的项目，那么很难跟踪整个项目，也很难记住为什么父组件内部会发生某种变化。这似乎是一个很好的解决方案，甚至是一个可重用的解决方案。即使你不再使用它，其他开发人员(你的同事或者贡献者，如果你在操作系统上工作)可能会使用它。任何时候发生这种情况，都会使理解代码变得困难，并且很难调试。

## 自定义事件和回调道具。哪个更好？

自定义事件是我们发出某个事件并通过它传递一个值的事件:

```
this.$emit('modal-closed', this.isClosed); 
```

Enter fullscreen mode Exit fullscreen mode

另一方面，回调道具是父级作为道具传递给子级执行的正常方法。这样做不是像在*自定义事件* :
中那样将值传递回父节点

```
<button @click="onClose">Close Modal</button> 
```

Enter fullscreen mode Exit fullscreen mode

所以它们都是用来执行相同的任务的。在第一种情况下，我们通过一个事件向父节点传递一个值，然后父节点执行一个方法或者用这个值做需要做的事情。在第二种情况下，我们将要执行的方法传递给子节点本身，期望它代表父节点执行该方法。

那么哪个更好呢？

实际上没有区别。就像克里斯说的:

> 这是文体

这意味着它完全取决于用户。如果你一直在使用一种方法，没有理由改变它。尽管如果你还没有真正考虑使用哪种方法，你可能会考虑使用*自定义事件*。自定义事件系统在保密性方面要好得多。它让父母不知道不必要的信息。因为我们只传递一个值，所以只告诉父节点必要的细节。

当处理组件驱动的项目时，目标是处理组件而不用担心其他组件。通过让孩子代表父母执行一个方法，我们不仅必须依赖一个组件为另一个组件执行一个方法，而且我们也可能不知道那个特定的孩子在执行那个方法。

如果组件太多，或者特定的父级有很多子级，就可能会发生这种情况。几个月后，它可能会变得令人困惑，我们可能会发现很难只通过查看父方法来记住该方法是如何执行的。

这并不意味着使用回调道具有什么坏处。使用自定义事件感觉更像 Vue，在官方 Vue 文档中有演示。

## 什么时候使用*守望者*比较合适？计算属性更好吗？

计算属性和观察器在它们所做的事情上是如此的相似，以至于大多数新的 Vue 开发者都很困惑，不知道该选择哪一个。通常，观察器最适合用于异步任务。

如果您想在一个状态更新时更新另一个状态，那么这就需要计算属性。一个简单的例子是从`firstName`和`lastName`中派生出一个`fullName`属性。

使用观察器将变得单调乏味，因为我们必须为需要跟踪的每个属性创建一个观察器。试图通过密切监视一个属性所依赖的所有属性来改变该属性的状态需要做大量的工作。

在这种情况下，计算属性非常有用。我们需要做的就是赋予它所依赖的属性。只要这些属性中的任何一个发生变化，它就会重新评估并进行更改。该属性被缓存，这样它就不会每次都被不必要地重新评估，除非它实际上已经改变了。

> 这是计算属性相对于常规方法和观察器的性能优势。

这并不意味着观察者没有用。有些情况下，计算出的性质对我们没有帮助，我们需要方法不能提供的反应性。因此，在这种情况下，观察者是最好的选择。

在我从事的一个个人项目中，我遇到了类似的情况。我有一个用户数组，每个用户都是一个对象。有 3 个单选按钮，根据选择的按钮，必须显示特定的用户。有一些方法可以挑选出需要显示的用户。使用一个简单的 click listener 来运行这些方法非常容易(我就是这么做的)。但是，如果我们必须在计算属性和观察属性之间做出选择，那么计算属性在这种情况下将不起作用。

> 计算属性的工作方式是从一个或多个属性的状态变化中获得结果，并返回一个值。

因此，对于这一点，观察者是两者中最合适的。

如果你想了解更多关于使用方法、计算属性和观察器的知识，一定要看看这篇由 Sarah Drasner 撰写的深入的文章。

## 以正确的方式重用代码

在 Vue 中有相当多的方法可以重用代码。然而，其中有 3 个广为人知，在开发人员中非常受欢迎:

*   使用组件
*   使用指令
*   使用混合

利用组件重用代码是 Vue 的核心基础。然而，Chris 告诉我们，许多开源插件使用了指令和 mixins，而它们本可以是组件。许多开发人员正在以错误的方式使用 mixins 和指令。

> mixins 的一个很好的用例是当我们希望组件做一些不同于它们通常的特定行为的事情

* * *

指令用于在许多不同的元素之间共享行为。它们在一个元素上更有意义，而不是将该行为作为一个单独组件的一部分。我们经常会看到一些行为非常普遍，不够具体或独特，不足以保证它们有一个单独的组件。

克里斯提到了一个自动对焦功能的好例子。我们需要用它来手动操作 DOM，但是它不会被经常使用，所以我们需要一个组件。在这种情况下，指令是最好的选择。

* * *

人们似乎经常使用 mixins，有时甚至在没有必要的时候。*作用域插槽*提供了与 mixins 相同的功能，并且在大多数时候是更好的选择。我们绝对需要 mixin 的情况非常特殊。作用域槽更具组合性，我们需要的一切都由包装组件提供，我们可以选择想要包含的内容。

mixins 的一个很好的用例是当我们的组件做一些非常特殊的事情，但是根据情况我们希望它们做一些不同的事情。我们可以创建一个 mixin，它是一个返回组件选项的函数。因此，我们已经动态生成了组件行为。对于这样的动态行为，我们也需要一些变量。我们可以把它们放在这个函数中，而不是把它们和所需的放在一起。

* * *

这一集里有更多有趣的对话，还有很多东西要学。我建议至少听一遍这一集，以便对事情有更好的了解，然后订阅这个很棒的播客。

你可以在这里找到播客第一集。你可以在推特上找到上面提到的所有人- [莎拉·德拉斯纳](https://twitter.com/sarah_edo)，[克里斯·弗里茨](https://twitter.com/chrisvfritz)，[亚当·瓦森](https://twitter.com/adamwathan)。确保关注他们，这样你就能了解他们的最新工作。如果你有一些关于 Vue 的问题，我相信这些人会非常乐意帮助你。如果我错过了我应该添加到这篇文章中的任何好的提示，请在下面的评论中告诉我。