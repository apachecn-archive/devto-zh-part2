# 我如何(重新)学习面向对象程序设计不是一个银弹

> 原文:[https://dev . to/alexm 77/how-I-relearned-OOP-is-a-silver-bullet-12eg](https://dev.to/alexm77/how-i-relearned-oop-is-not-a-silver-bullet-12eg)

###### 座右铭:“如果实现很难解释，那就是个坏主意。”-蟒蛇的禅

### 我和我的小顿悟

我就是这样，一个典型的 Java 程序员，努力不落后于新趋势。我正在阅读关于 JDK 的新的和未来的补充，试图跟踪 NoSQL 解决方案，跟上无数的 Spring 框架模块，测试框架，构建工具，等等。当我说到“每年学习一门新语言”的时候，我开始努力了。我立刻被吸引住了:当其他语言似乎非常严肃地要添加所有东西和厨房水槽时，这种语言却回归了基础。Go 看起来是一种不错的语言，拥有非常丰富的标准库，可以在很短的时间内完成很多工作(我相信它的目标之一是“像 Python 一样高效”)。几个玩具应用程序之后，我非常确信事实确实如此。但是我突然“啊哈！”我意识到的瞬间:**哎，这东西没有对象！我究竟是如何如此快速地编写我的玩具项目代码的？不管怎样，用 Go 你可以得到结构，你可以把方法和这些结构联系起来，这听起来很像一个对象。但是你不会得到继承，一个“受保护的”关键字或者任何类似的复杂事物。**

现在，作为一点背景，这并不是我走出 OOP 世界的第一步。事实上，我开始用 BASIC 编程，后来转到了 Pascal 和 C 语言(用了一点 C++)。我甚至还涉猎了一点 ASM。然后在大学里有这门 OOP 课程使用 Java 作为支持。然后就一拍即合。事情开始步入正轨，我找到了一种比之前任何语言都更适合我的语言。我完成了大学学业，找到了第一份 Java 工作，从那以后，我一直试图在这方面做得更好。许多年后，我与 Erlang 和 Scala 发生了一点小摩擦(这很重要，因为它们开启了我将要与您分享的思路)。然后，当我要走的时候，我终于把两个和两个放在一起，得到了“啊哈！”我告诉过你的时刻。

我们都有自己的“啊哈！”这一个有什么特别的呢？答案很简单:当我走出自己的框框，以正确的角度看待事物时，我意识到 OOP 有时非但没有帮助，反而适得其反。很多次，取决于你在做什么。我意识到在我 15 年的经验中，没有一个客户来找我们要求对象的层次结构。一个都没有。相反，客户问的是“当我做这个/给你那个时，我需要程序做那个”。这听起来非常类似于用函数式语言描述程序。你会说，客户并不总是精通技术，他们的工作不是知道所请求的解决方案应该是什么样子。这很公平。让我们看看现实世界，研究一些典型的需求，以及我们如何去满足它们。

### 看着现实世界

为了接下来的几个例子，我们将假设我们正在使用 Java，并且我们很好地利用了 GoF 模式和坚实的原则。web 应用程序是最常见的应用程序类型之一。我们不会一步一步地分析我们是如何从规范到实现的，但是我们都知道最终的结果。它以一系列服务和一系列存储在数据库中的东西结束。服务将是无状态的(因为有状态的更难在集群中部署)，因此它们将被简化为一个类中的一组功能，几乎没有成员变量。另一方面，持久化的东西都是成员变量，除了 getters 和 setters 之外没有其他功能。我们已经应用了 OOP 的最佳实践……并且我们得到了函数式语言的典型解决方案:简单处理数据结构的函数。因为你的典型实体和地图/字典没什么区别。
当然，整个应用要比这复杂。它的一些功能来自运行它的应用程序容器。这不是无关紧要的功能，而是像事务一样重要的东西。让我们看看事务，看看容器是如何基本免费地支持它们的。要启用事务，您只需注释一些方法(如果您没有使用 Java/Jakarta EE，在这种情况下，默认情况下您会为指定的方法获取事务)，瞧！即时交易。当然，为了做到这一点，容器需要将一些生成的代码注入到 JVM 中，这可以在 JIT 编译器中抛出一个活动扳手。并且我们不能使我们的类成为 final，这阻止了一系列其他的优化。现在将这与一种更具函数友好性的语言进行对比，在这种语言中，习惯性的做法是将一个函数作为参数传递给另一个函数...)方法，该方法启动事务，调用传递给它的函数，然后关闭事务或根据需要回滚事务。奥术遇上死亡-简单。

接下来，如果我们需要建模一个比典型的 web 应用程序更有状态的系统，那会怎么样呢？现在我们在 OOP 天堂:我们有一系列组件(对象)，每个组件都有自己的状态(成员字段)和特定的动作(方法)。我们的对象现在是真正的对象，做着对象的事情。当处理一个事件时，我们会遇到一点问题，因为我们需要检查几个对象来确定我们所处的状态，这将导致一点 if..然后..我们代码中的 else 语句。但除此之外，我们的解决方案非常好。然而(我敢打赌你已经知道“然而”即将到来)，这样的解决方案无法扩展到更复杂的系统。您不需要对其进行扩展，因为在现实世界中，启动系统不太可能随着时间的推移而变得更加复杂。然而，为了这个故事，让我们假设我们现在被要求编写一个控制国际空间站的软件。将空间站上的每个系统建模为一个对象可能是可行的，但试图确定系统的状态将产生一剂(不)健康的意大利面条代码。如果我们的语言提供了强大的模式匹配功能，我们可以更好地处理这个问题，但即使是这种方法也只能带我们走这么远。我们如何前进？我们运用我最喜欢的技巧之一:我们回到基础。基本原理是，当 FSM 改变状态时，它只是对系统的当前状态和输入事件应用一个函数，并将整个系统移入一个新状态。因此，如果我们做正确的事情，并对我们的状态和输入事件进行编码，我们只需创建一个状态和事件的稀疏矩阵，在每个单元中采取行动。动作本身可能相当复杂，将由几个较小的动作组成。但是再一次，我们摆脱了对对象的所有需求，我们得到了一个数据结构和一系列函数。几乎就像一个功能性的方法正在跟踪我们；)

### 教训

现在，非常清楚的是，以上并不意味着暗示 OOP 是不好的或者你应该避免它。我挑选了一些常见需求的实例，其中简单的解决方案看起来更像函数式编程，而不像 OOP。但是有一些(部分)项目的解决方案可能更适合 OOP。我相信图形工具包就是一个很好的例子。认识到这一点后，最近的通用语言(我想要么走，要么锈)包含了面向对象和面向函数的特性。即使是一切都是对象的 Java，也一直有迭代器，并致力于用流和方法引用添加函数特性。(我特意选择在上面的例子中不提这些，因为我没有比较语言的意图，而是展示了片面思维的缺陷。)
为什么我认为这些都很重要？毕竟，尽管你可能会尝试，任何软件都会随着时间积累债务(我对此不抱幻想)，所以为什么要在开始时麻烦地让它变得更干净一点呢？嗯，在我看来，这可以帮你避免一些(很多？)那些尴尬的时刻，当客户要求一点点改变，你必须向他们解释，因为你的实现是如此复杂，这一点点改变将需要几周甚至几个月才能实现。您的解决方案越能满足客户的需求，您需要经历的这些时刻就越少。这对建立客户满意度和保持团队士气都有很大帮助。
最后，我想说的是:就像一个勤杂工带着他的工具箱来到你的门前，我们程序员也带着我们的工具箱(由语言、编程技术、构建工具的知识等等组成)来到我们客户的门前。如果我们不相信只带着一把螺丝刀或者一把锤子出现在门口的勤杂工会做得很好，我们可以绝对肯定，如果我们出现在他们的门口，脑子里只有一种语言和/或框架，我们不会很好地服务我们的客户。下次你做杂工的时候，确保你的工具箱里装了尽可能多的工具；)