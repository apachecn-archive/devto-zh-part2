# 🔁稳定与不稳定排序

> 原文:[https://dev . to/in differential Alex/-stable-vs-unstable-sorting-1l4b](https://dev.to/indifferentalex/-stable-vs-unstable-sorting-1l4b)

在我们的两个主要开发环境中运行我们的 Rails 测试套件时，我们注意到了一个问题，在 Mac OS X 上，我们有一个测试总是失败，而在 Linux 上，它每次都能顺利通过，这在某种程度上证明了一个古老的软件开发格言，即开发机器与您的生产代码将运行的机器尽可能相似的重要性。

经过调查，我们发现问题出在特定测试期望元素排序的方式上。

### [](#what-was-happening)发生了什么事

[稳定排序算法和不稳定排序算法](https://en.wikipedia.org/wiki/Category:Stable_sorts)的基本区别在于，当按照非唯一值(将多个元素组合在一起)排序时，稳定排序算法确保保持元素的原始顺序。这基本上就是我们测试的内容，元素被分组排序，并且在每个组中它们保持原来的顺序(它们被添加的顺序)。

看出这种差异的最简单的方法是通过定义一组元素的非唯一值进行排序，例如任务的“紧急程度”字段。如果排序函数只考虑这个紧急性字段，那么具有相同紧急性的两个元素的最终排序将取决于所使用的算法，并且不能保证它们的原始顺序将被保持。另一个例子是按单词的首字母而不是整个单词排序。任何排序算法都会给你一个正确排序的数组，但是只有稳定的算法才能保持每个组中元素的原始顺序。

我们创建了一个对象数组(代表文档)，然后按照它们的“类型”(一个字母数字字符串)进行排序，在数组中不必是唯一的(例如，两个文档都可以有一个“合同”类型)。然而，在我们的规范中，我们期望相同类型的文档保持我们将它们添加到数组中的顺序。在我们的 Linux 机器和 CI 上，这可以正常工作，但在我们的 MAC 上却不行。

### [](#why-the-behaviour-was-different)为什么行为不同

这个问题发生在我们的 Rails 应用程序中，所以我们通过运行一个名为[proy](https://github.com/pry/pry)的强大工具来检查 Ruby `sort`方法背后的源代码，从而确定了根本原因。排序的发生得益于一个`qsort` C 函数调用。在 Mac OS X 上，这实际上利用了一种快速排序算法，顾名思义，这种算法本身并不稳定。在 Mac OS X 实现的特定情况下(它来自 FreeBSD ),它是不稳定的。

如果我们考虑下面的数组`[21, 12, 47, 41, 33, 11, 13, 31, 43]`，我们可以看到这种不稳定性。在 Mac OS X 上通过第一个数字排序，无论是在 C 语言中(使用 qsort)还是在 Ruby 语言中(sort 或 sort_by ),我们都得到`[12, 13, 11, 21, 33, 31, 47, 43, 41]`,尽管这实际上是通过第一个数字排序的，我们看到在最终数组中`11`跟在`13`后面，即使在原始数组中它实际上出现在它之前。`41`和`43`在最后一个数组中也会被调换。这里有一个 [Mac OS X 快速排序实现](https://opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/kern/qsort.c)的例子，它准确地展示了这种行为:

[![Animation showing the Mac OS X implementation of qsort() sorting the [21, 12, 47, 41, 33, 11, 13, 31, 43] array by the first digit, obtaining [12, 13, 11, 21, 33, 31, 47, 43, 41]](../Images/f2b406851a7fa8646b0ea1bd2e2db771.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--GLtc17ho--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/svm9eo2m0xuuyz68iyf3.gif)

我们可以看到，当`13`与`47`交换时，它们交换了`11`，后者在最终数组中的`13`之后结束。

在不深入研究稳定性/不稳定性的严格证明的情况下，我们看到快速排序使用多个不相邻的指针来交换元素，这使得它们脱离了原来的顺序并混在一起。

与名字所暗示的不同，`qsort`不一定是所有操作系统上的快速排序。Mats Linander [有一篇非常好的文章](http://calmerthanyouare.org/2013/05/31/qsort-shootout.html)讲述了各种不同库中 qsort 实现的所有差异。

关于 GLIBC 的(大多数 Linux 发行版使用的)实现，他提到:

> 这个 qsort()很有趣，因为它避免了快速排序，而支持合并排序。

啊，问题就在这里！

确实很有意思，因为归并排序其实是稳定的！如果我们在 Linux 机器上运行前面的示例数组中的`qsort()`(或 ruby 中的`sort_by`)，再次只按第一个数字而不是整个数字排序，我们会看到，对于我们的示例，该算法实际上是稳定的(它返回`[12, 11, 13, 21, 33, 31, 47, 41, 43]`)。我们的测试通过了，因为我们的数组按照预期进行了排序，对我们的文档进行了分组，但在相似的文档中保持了它们的原始顺序。合并排序将元素与其直接相邻的元素进行比较，因此不会发生可能改变原始排序的“跳转”。下面是一个图解示例:

[![Animation showing a merge sort algorithm sorting the [21, 12, 47, 41, 33, 11, 13, 31, 43] array by the first digit, obtaining [12, 11, 13, 21, 33, 31, 47, 41, 43]](../Images/d81bd3707cc66bc09385017e1832caa6.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--M00WPCoQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/4x92a89oamlqq8rqjggo.gif)

### [](#what-we-changed)我们改变了什么

代码行为和测试应该尽可能具有可重复性和确定性，而不是在我们的 MAC 上允许失败的测试，我们修复了这个问题。然而 Ruby 本身并没有提供任何简单的替代方法来保证排序的稳定性，所以我们想出了自己的解决方案，(可以说)最简单的。

我们继续使用 Ruby 的排序，但不是专门按照非唯一字段排序，我们还会考虑原始数组中每个元素的索引。这样，如果我们有两个元素在排序时“绑在一起”,由于它们的索引不同，它们将总是以原来的顺序结束。

[该要点显示了所使用的解决方案](https://gist.github.com/indifferentalex/08a2434192399bcd13042deda73935c5)。使用元素及其索引的数组而不是元素和索引的某种连接进行排序的原因是，在不同元素具有不同大小/长度的情况下，我们不需要担心任何类型的填充。

稳定排序给了我们确定性的行为，并通过了我们所有环境中的测试，就像它应该的那样。✅

* * *

*大家好，我们是 [store2be](https://www.store2be.com) ，一家总部位于柏林的初创公司，为短期零售空间建立了一个支持 SaaS 的市场。如果你喜欢我们发布的内容，你可能想看看[store 2 be 技术页面](https://tech.store2be.com)或者关注我们的[媒体频道](https://medium.com/store2be-tech)。*