# 超越 9 球:Azure Cosmos DB 一致性水平

> 原文:[https://dev . to/jeremylikness/get-behind-the-9-ball-cosmosdb-consistency-levels-2jgg](https://dev.to/jeremylikness/getting-behind-the-9-ball-cosmosdb-consistency-levels-2jgg)

#### 理解强、有界陈旧性、会话、一致前缀和最终一致性级别的含义

我不是一个超级体育迷，但我爱我的 9 号球。在短暂的大学尝试和我的第一份编程工作之间，我什么都做过一点。不知何故，我设法从在书店、零售店、快餐店工作，从在汽车后备箱卖电子产品，到在台球厅全职工作了一年。我从未失去对这项运动的热情，当我看比赛或打台球时，我总是感到最放松。

<figure>[![](../Images/17066b973b8e70c7bee53520ce02f798.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--6YVHJR0L--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2AMStSlsWrueLLaKy3qm2Lbw.jpeg) 

<figcaption>9 球！</figcaption>

</figure>

台球锦标赛通常包括“竞赛”例如,“冲向 7”意味着第一个赢得 7 场比赛的人赢得这一轮比赛。在典型的锦标赛和大型台球厅中，您可能会同时进行几十场比赛。我阅读了一份出色的白皮书，其中[用棒球比赛类比](https://jlik.me/c48)解释了一致性水平。虽然它给我留下了新的认识，但我觉得少了点什么。

所以，我把我所学到的应用到我对台球的热情中，想出了这个。

如果您不熟悉的话， [CosmosDB](https://jlik.me/c49) 是一种基于云的 NoSQL 数据库服务，它支持几种不同的 API，允许您只需在门户 UI 中单击一个按钮就可以跨全球区域进行复制，并提供可用性、延迟、吞吐量和一致性的服务级别协议(SLA)。您可以为数据库选择默认的一致性级别，并基于每个应用程序或连接进一步覆盖它。

一致性级别提供了性能、可用性、陈旧性和数据排序之间的权衡。我能想到的解释这意味着什么的最简单的方法是通过台球锦标赛的镜头走过一致性水平。

### 等等，谁在乎？

为什么一致性水平如此重要？在某些情况下，数据库的本地单个实例可能非常好。然而，大多数企业应用程序要求快速周转(低延迟)和弹性(高可用性)。低延迟和高可用性可以通过分布在一个地理区域的分布式系统或多个数据库节点或集群来解决。

*   如果群集中的一个节点出现故障，其他节点可以接替它来维护可用性
*   如果一个区域中的一个集群出现故障，其他区域可以介入以保持可用性
*   将节点放在不同的区域会使数据库更接近该区域的用户，这反过来会提供更低的延迟和更快的速度

如果像扳动开关一样简单，拥有一个分布式系统就好了。不幸的是，分布式系统很复杂。[上限定理](https://en.wikipedia.org/wiki/CAP_theorem)描述了三种保证:

1.  一致性—每次读取都是最新的写入
2.  可用性—每个请求(如读取)都会得到响应
3.  分区容差—如果消息丢失或延迟，系统仍将作为一个整体运行

该定理指出，一次只能提供三种担保中的两种。三个都提供是不可能的。网络故障和延迟是一个正常的现实，所以把焦点放在一致性和可用性上。CosmosDB 提供了高可用性保证，并提供了“拨入”一致性级别以牺牲性能的能力。

额外收获:如果你想挖掘得更深，看看 [PACELC 定理](https://en.wikipedia.org/wiki/PACELC_theorem)。

### 设置

为了简单起见，假设有 20 名玩家在 10 张牌桌上进行三比三的比赛。在每张桌子上分别标上“A”和“B”。为了进一步简化模型，假设每场比赛都以“A”最终获胜而告终。每张牌桌的得分历史最终看起来像这样:

*   A — 1，B — 0
*   a-1，B-1
*   a-2，B-1
*   a-2，B-2
*   A — 3，B — 2 (A 是赢家)

一名计分员正在记录每张牌桌上的分数，还有一大群观众在观看锦标赛。现在，我将带您了解每个一致性级别的设置。

### 强烈的一致性

> 线性化。读取保证返回项目的最新版本。

<figure>[![](../Images/434cadf74bdf79c1fa62a19707e213a3.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--e-sbGye8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2A166Q_xkcJXxKZFAYg_OM6w.png) 

<figcaption>强一致性</figcaption>

</figure>

强一致性可能是最容易理解的，也是大多数传统关系数据库管理系统(RDBMS，即 SQL 或 MySQL)开发人员倾向于依赖的。本质上，任何人，任何地方，对任何给定时间点发生的事情都是一致的。

在我们的台球锦标赛中，这会产生一些开销。每当牌桌上的比分发生变化时，记分员就会吹哨子停止一切，同时分享比分。他们更新他们的分数，然后到每一张桌子通知其他记分员。最后，他们走向观众，确保每个观众都知道比分。然后他们再次吹响哨子，一切又恢复了。你可以想象这会让事情慢下来一点。

总而言之，该模型具有:

*   最高一致性—每个人都同意
*   最低性能—在我们继续之前，我们需要确保每个人都知道每个更新
*   可用性最低—没有真正的机会进行横向扩展，因为添加新的观察器只会增加开销

通过 [quorum](https://en.wikipedia.org/wiki/Quorum_(distributed_computing)) 可以在分布式系统中保持强一致性。当跨多个系统维护一个文档的多个副本时，更改被“投票表决”,并且仅当多个节点同意更改是可接受的时才被提交(类似地，对于要中止的操作，必须存在一定数量的投票)。这牺牲了延迟(您必须等待投票的到来)和吞吐量(同样，由于数据必须跨节点传递)。在我们的例子中，这是记分员与其他记分员和观众成员确认的动作。

由于维护仲裁固有的开销，强一致性的开销几乎是会话、一致前缀或最终一致性的两倍。

### 有界陈腐

> 一致的前缀。读取比写入落后 *k* 前缀或 *t* 间隔。

<figure>[![](../Images/32c801c3747c8c10594865d32ec1bda4.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--QZWclFHb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2ALDjgaE3neoC1uJOKc4wjKw.png) 

<figcaption>有界陈腐</figcaption>

</figure>

有限陈旧是一种妥协，用延迟换取强一致性。此级别不保证所有观察器在同一时间拥有相同的数据，而是允许在操作和/或时间中指定滞后。例如，该数据库被配置为最多落后 100 次操作或延迟 5 秒钟。

<figure>[![](../Images/70da25425cd376fa6870ce98f48f75fd.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--3G8l9CsX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/653/1%2AKAWOubdMiGroSd-F3SNa3w.png) 

<figcaption>在门户中配置有界过时</figcaption>

</figure>

这到底是什么意思？

在我们的比赛中，记分员不会吹哨子停止比赛。相反，游戏继续进行，分数用时间戳记录。一个集中的系统整理这些信息，并在一个记分牌上播出，每个人都可以阅读。因为从各种表格中获取分数需要时间，所以记分牌不是实时的。玩家可能会赢得锦标赛，但必须等待一段时间才能在记分牌上显示。

这里的妥协是给每个人一点喘息的空间来整理分数。在 CosmosDB 的情况下，这意味着您可以选择多个区域，因为滞后为跨这些区域复制数据提供了时间(正如您可能猜测的，这里有*和*限制，并且不允许指定“一”的操作滞后，因为这几乎与强一致性相同)。

总结一下:

*   一致性超出用户定义的阈值
*   为“最终如何”提供保证
*   这比强一致性提供了更好的性能
*   由于同步所有区域的固有滞后，可用性仍然较低
*   与强一致性一样，这大约是会话、一致前缀和最终一致性的两倍

### 会话

> 一致的前缀。单调读取、单调写入、先读后写、先写后读。

<figure>[![](../Images/6b07031d3dd84509c5dbea605dd1ebc9.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--IOlj8P_a--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2AW-ewgAQ9s5Z_Q-WwmTFOaQ.png) 

<figcaption>会话一致性</figcaption>

</figure>

会话一致性是新创建的数据库和集合的默认一致性级别，这是有充分理由的。它的成本不到强一致性和有限陈旧性的一半，并且提供了良好的性能和可用性。将会话视为您的应用程序或连接。

会话一致性的一个很好的例子是每张桌子上的记分员。由于有限的陈旧性，记分员可能会陷入这种尴尬的境地:

*   写入 A — 1 (B 仍为 0)
*   写入 B — 1
*   读取记分卡进行验证
*   Read 返回 A — 1，B — 0

是的，在 NoSQL 的世界里，你的阅读不一定要和你的写作相关联，除非你使用像强一致性这样的东西。在本例中，由于内置的延迟，有限的陈旧性不能保证最新的一致性，因此读取返回前一时间点的状态。最终，如果他们继续检查他们的记分卡，分数将会是 A-1，B-1。

会话一致性解决了这个问题。它确保写入的任何内容对于来自该会话的读取*都是当前的。其他的都是准确的，但是有延迟。所以，事情是这样的:*

*   写入 A — 1 (B 仍为 0)
*   写入 B — 1
*   读取记分卡进行验证
*   读取返回 A — 1、B — 1(保证)

如果记分员决定通过查看其他表上的分数来消磨时间，他们会看到准确的分数，但不一定是当前的分数。换句话说，表 2 当前可能在 A-1，B-1，但是记分员看到 A-1，B-0。同样，观众总有一个准确的分数可能会被延迟。在记分员写下 B — 1 几秒钟后，观众仍然可以看到 B — 0。最终，比分追上了。

总结一下:

*   会话的强一致性*—该会话的所有读取和写入都是最新的，但其他会话的写入可能会滞后*
*   来自其他会话的数据以正确的顺序出现，只是不能保证是最新的
*   这提供了良好的性能和可用性，而成本仅为强一致性和有限陈旧性的一半

如果你想超越游泳池的比喻，考虑一个社交共享的营养计划。输入他们的膳食的用户应该总是看到当天卡路里和营养成分的当前准确表示。然而，他们社交网络中的其他用户不需要实时看到这些更新。他们最终可以收到更新，并点击一个“喜欢”按钮，即使它在短暂的延迟后出现，也是一顿做得很好的健康餐。

### 一致前缀

> 返回的更新是所有更新的前缀，没有间隔。

<figure>[![](../Images/2449ca00c574b6f542982152fbb6ef34.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--nlM3X7wZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2Au2f3aV2Y0NHOZVR3YBFf2w.png) 

<figcaption>一致前缀</figcaption>

</figure>

如果您理解前面的级别，这是最容易解释的一致性级别之一。我喜欢把一致前缀想成没有操作滞后/延迟保证的有界陈旧性*。任何观察对于某个时间点都是准确的，但不一定是当前的。*

在我们的桌球锦标赛中，记分员努力记录分数并更新他们的记分卡。这些被整理并在记分牌上播出。随着有限的陈旧，观众知道记分牌总是只延迟几分钟或几分钟。使用一致的前缀，这就不那么清楚了。当许多比赛同时结束时，可能需要更长时间来汇总和更新分数。当比赛正在进行时，没有分数被改变，分数“赶上”并成为当前分数。

理想情况下，记分员有一个特殊的应用程序，使用会话一致性。观众使用的记分牌和泳池统计 app 都使用一致的前缀。

总结一下:

*   读数在特定时间点是一致的，即分数总是准确的，只是不一定是最新的
*   不能保证有多快，但在许多情况下，延迟可能是几秒钟而不是几分钟
*   良好的性能和卓越的可用性，因为各种节点可以花任何时间来同步和同意当前模型

### 最终的一致性

> 无序读取。

<figure>[![](../Images/fd7ef76e1e9bbff4bd9b03b4d86fb8c1.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--jNOcdEB8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2A6hFhjpptxbeLRnTJ3LwAqA.png) 

<figcaption>最终一致性</figcaption>

</figure>

对于台球锦标赛的观众和记分员来说，最终的一致性将是一场灾难。最终一致性很容易理解:最终，读取是一致的。不能保证这需要多长时间(比如一致前缀)，但另一个警告是不能保证更新按顺序进行。

考虑这个场景:

*   记分员输入 A — 1(现在比分是 A — 1，B — 0)
*   记分员输入 B — 1(现在比分是 A — 1，B — 1)
*   记分员输入 A — 2(现在比分是 A — 2，B — 1)
*   记分员看了比分，看到 A — 0，B — 1
*   观众看着记分牌，看到 A — 2，B — 0

在这种情况下，无序更新意味着分数可能不代表现实。即使时间不同,“A”写入可能会先于“B”写入。最终，分数会以 A-2，B-1 结束，但无法保证何时结束，也没有办法真正检查，是的，这是*当前分数*。

那么，您为什么会考虑这种一致性水平呢？

首先，因为 CosmosDB 不需要保证时间点的准确性，甚至不需要保证写入的顺序，所以这是性能最高、成本最低、可用性最高的模型。

第二，当这个级别很好时，有一些有效的场景。例如，台球联盟的自动化简讯可能会最终保持一致，因为当它在锦标赛结束后几个小时轮询数据库时，很有可能最终达到了一致。

这个类比有助于您更好地理解一致性级别吗？请在评论中留下你的想法和反馈。你也可以阅读关于 CosmosDB 一致性级别的[官方文档。](https://jlik.me/c5a)

问候，

[![](../Images/97adde39a566ae152324f60361115585.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--u6zXBAsP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://cdn-images-1.medium.com/max/197/1%2AKwXn3ElS7vnWIk8lNVhBsA.gif)

* * *