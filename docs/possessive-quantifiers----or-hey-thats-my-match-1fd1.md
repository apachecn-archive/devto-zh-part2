# 所有格量词——或者“嘿，那是我的搭配！”

> 原文：<https://dev.to/alephnaught2tog/possessive-quantifiers----or-hey-thats-my-match-1fd1>

同时分析 [Dev。为了调查](https://dev.to/devteam/state-of-the-web-data---call-for-analysis-2o75)，我发现自己在正则表达式中有一个特别明显的所有格量词的例子——这是 regex 语法中罕见的(r)部分之一，也是我从未真正得到过的部分，所以我很兴奋终于在“野外”看到了它的例子，这让我很满意。

首先，一个非常旋风的正则表达式分解:*正则表达式*是一个用特殊语法编写的字符串，用来描述它测试的字符串可以有什么。

这方面的一个很好的例子是 CSS 中的一个用于`rgb`颜色的正则表达式:我们可以写一些东西来检查一个给定的字符串和每一个可能的`rgb`颜色——所以`rgb(0,0,0)`、`rgb(0,0,1)`，一直到`rgb(255,255,255)`——但是如果我们可以描述一个颜色的样子，不是更容易吗？

我们知道它以`rgb`开始，然后是一些括号，在这些括号内将是三个数字。正则表达式可以让你做到这一点——你可以用它来测试字符串，看看它们是否匹配。你的 rgb 颜色的正则表达式就是这样描述的:rgb 颜色以`rgb`开始，然后打开括号，在这些括号内将是三个数字，然后我们关闭括号。如果我们把它逐字翻译成正则表达式，它将不是一个完美的 RGB 颜色的正则表达式，但这将是一个好的开始——它肯定会拒绝没有数字、没有括号、不以`rgb`开头的东西，等等。

### 快速笔记

*   正则表达式由分隔符表示，通常是两个`/`:所以`/apple/`是一个正则表达式，其字符与单词“apple”相同，但是`apple`不是正则表达式，它只是一个字符串。
*   当我在下面谈到正则表达式*匹配*时，我将使用它来表示被测试的整个字符串:例如，`/a/`匹配`a`而不是`apple`；`/\d+/`匹配`0`或`92819281`，但不匹配`ag3`。*找到匹配*指的是在一个更大的字符串里面找到它匹配的某个字符串部分——`/apple/`匹配“苹果”，在“橘子和苹果”里找到匹配。
*   要尝试这些，我建议使用 [Regex101](https://regex101.com/) ，因为它默认启用 PHP 选项，并且它还有语法高亮、调试器等。 **JavaScript 对下面的主要例子不起作用。**

## 量词

在正则表达式中，*量词*让你说出你想要多少。

最常见的有:`?`、`*`、`+`，还有文字，就是花括号里的一个数字，或者花括号里的两个逗号分隔的数字。我们今天只讲前三个。

*   `?`表示该单元可以出现 0 次或 1 次:该单元是可选的，但如果它在那里，它只能出现一次。`/apples?/`同时匹配`apple`和`apples`，但不匹配`applesssss`。
*   `*`表示该单元可以上升 0 次(根本不上升)，或者任何其他次数:0 可以，1 可以，15000 可以。`/apples*/`
*   `+`表示一个单位被要求至少出现一次，但如果它出现*次以上*也没关系。

最常见的是，你会看到`*`和`+`带有一个类似`.`的*通配符*(可以匹配任何非换行符的内容)，或者*类*(一组允许出现在一个位置的字符- `/[a-z]/`表示从`a`到`z`的所有字符，`/[xyz]/`只是那三个字母，等等。一些常见的字符类有一个简写符号——例如，`/\d/`与`/[0-9]/`相同:从字符`0`到字符`9`的任何字符；`/\s/`通常[1]至少匹配空格或制表符。

*   `/[a-z]\d?/`意味着我们想要一个字母，也许- `a`和`a2`后面的数字会匹配，但是`a331`会失败。
*   `/[a-z]\d*/`表示任何数字或没有数字都可以- `a`和`a12345`都匹配。
*   `/[a-z]\d+/`表示 1 到多个数字都可以- `a12`匹配，但是`a`会失败。

我们最常看到通配符或类是有道理的——如果我们匹配一个以上的东西，那么我们谈论的是比一个字符更广泛的类别的可能性很高。能够描述几乎大多数单词——“至少一个，也可能是许多个字母”。注意，它们不必是同一个字母- `/[a-z]+/` *可以*匹配“aaaaaaah”，也可以匹配“kslqm”。

## 所有格量词

有些语言让你把它们组合起来，组成一个超级超级花哨的硬核量词，比如一个所有格量词或一个懒惰量词。

所有格量词看起来像`/\d*+/`或者`/\d++/`——意思是“当你匹配这个的时候，拒绝给任何字符回匹配。”

非常清楚，对不对？是...没有。

好的，记得我说过我有一个例子吗？所以我们开始吧。我曾想开始处理调查结果，并想从数据本身剥离出一堆东西，并将其转换成我想要的格式，比如一堆`insert`语句之类的。

所以，对于标题，我特别想去掉数字。

```
1\. Which is your primary browser for development    2\. Which of the following technologies have you made use of?    2\. Which of the following technologies have you made use of?    3\. How old 
```

当我这么做的时候，我知道我还想去掉空格和标点符号，所以我开始修改。

像许多其他事情一样，我尝试从我知道会起作用的东西开始，这对于正则表达式来说通常只是确保我可以从我想要的地方开始，在我想要的地方停止。我可以看到问题是有编号的，数字后面有句点，然后是一些空格，然后在整个问题之后，在下一个数字之前有更多的空格。我在大部分问题中使用了“不是数字”,因为对于我想要的来说，它更快更准确(至少在这里——我做了一个相当大的假设，没有一个问题包含数字)。

下面是我最后使用的正则表达式:

```
# link: https://regex101.com/r/nGrjKq/3/
/(?x)
\d+     # at least one digit
\.      # a period
\s      # a space
[^\d]+  # something that isn't a digit -- at least one, and maybe more than one
\s+     # a space -- at least one, and maybe more than one
/ 
```

现在，效果很好。

所以我为什么要尝试一个所有格量词呢？

我可以很聪明地说，这是因为我知道它们通常更快(这是真的)——但老实说，这是因为我偶然按了两次`+`而失败了，我很困惑。

困惑什么？嗯，下面的正则表达式将在我们上面测试的相同字符串上失败，而第一个将工作。第 5 行还有第二个`+`——第一个版本里是`[^\d]+`，下面是`[^\d]++`。(Oofda。)

```
# failing version: https://regex101.com/r/zM15hD/1/ 
/(?x)
\d+     # at least one digit
\.      # a period
\s      # a space
[^\d]++ # something that isn't a digit -- at least one, and maybe more than one
\s+     # a space -- at least one, and maybe more than one
/ 
```

对于上面的版本，我们完全失败了:没有找到匹配。因为所有格量词是不会给任何回馈的——`+`默认是贪婪的，所以一直啃到失败。当它失败时，正则表达式引擎回溯，如果可以的话，看看它是否能通过这样做找到一个匹配——回溯，它放弃到目前为止已经消耗的，希望能找到一个匹配。

呃，怎么了？

## “不给任何回”

当正则表达式引擎试图进行匹配时，它会一直进行下去，直到它所找到的内容被它的当前状态所接受——这是一种奇特的说法“它会一直进行下去，直到它不能再匹配为止，因为它超出了字符数或者完全失败了。”如果您使用 Regex101，您会很快发现，当您编写一个不匹配的字符串时，步数通常会比匹配时多得多——因为引擎会继续遍历字符串，希望找到一个可以匹配的位置。如果它想找到短语“Dev”。在《哈姆雷特》中，它会有太多的步骤——因为它会搜索一切，希望从下一个字符开始找到它，因为它还没有找到。

正如它所说，它消耗东西。一旦某样东西被消费了，如果事情进展顺利，它就不能被再次使用——但是，如果它失败了，引擎将开始回溯，试图找到一个匹配。(顺便说一下，这通常是正则表达式效率方面最大的问题之一。)

在我们的例子中，我们想要一堆不是数字的东西，那么至少要有一个空格。当 regex 引擎遍历字符串时，它会吃掉 eeeeeverything 中不是数字的部分，直到它找到一个数字——在我们的测试字符串中，这个数字就是`2`。但是现在，它需要一个空格来匹配——所以它返回，因为“不是一个数字”肯定可能是一个空格字符，果然，它找到了一些，并使用它们来匹配`\s+`，匹配得很好。

当我们使用所有格修饰语时，我们不允许它回溯。所以同样的事情发生了:它行走，它吞噬所有不是数字的东西，它击中那个`2`，但是需要一个空间来匹配。因为我们使用了`++`，它不能回溯，所以它无法匹配——它已经消耗了那些空间。

## 故事的寓意

分享就是关爱！(呃，可能不是这里的那个吧，嗯。)

我最终做了一点调整，就是[这个正则表达式](https://regex101.com/r/7lFnEs/3)——类似，但是更具体一点，至少对于这个测试来说，只多了几个步骤。我最终放弃了下一个数字前的空格——这很容易用`trim`删除，决定保留所有格量词，因为我很少使用它们，并且我开始使用前瞻，这是我真正喜欢的，没有什么好理由。

```
# link: https://regex101.com/r/7lFnEs/3
(?x) 
\d+      # at least one digit
\.       # a period
\s       # a space
[^\d]++  # not a digit, 1 or more of them
(?=\d)   # until we see a digit ahead 
```

* * *

[1]我说“通常”是因为你可以改变一些事情的行为方式，包括那个类，还因为不同的正则表达式在不同的语言中有不同的行为方式。

[2]我使用了`/[^\d]+/`--"不是一个数字，至少一次，但也可能是多次"--因为如果我只是做了一个简单的通配符，引擎会直接向下搜索单词`old`，我会得到一个大的旧匹配，这与我想要的正好相反。因为我知道下一个问题是以数字开头的，所以我想获取问题编号之后不是数字的所有内容——因为这将是我所在问题的一部分。基本上，你认为这个问题是由数字界定的。还有，否定往往更快。