# 我今天学到了一些美好的事情

> 原文:[https://dev . to/tttaaannnggg/a-couple-of-beautiful-things-I-learn-today-3864](https://dev.to/tttaaannnggg/a-couple-of-beautiful-things-i-learned-today-3864)

我只是想发这个帖子来分享我今天参加的研讨会上的一些美丽的瞬间。

这是我自己写的，我对此相当自豪。问题是要写一个函数，它接受一个数，如果这个数是偶数就返回 true，如果不是偶数就返回 false。

```
function even(num){
    return !(num%2);
} 
```

这个函数依赖于这样一个事实，即 0 的计算结果为 false(也就是说，当它的类型被强制转换为布尔值时，它将解析为“false”)。由于我知道当一个数被整除时，模运算会给出一个零，所以我只要用 not(！)运算符。之后，当 num 是偶数时，它会给我 true，当它不是偶数时，它会给我 false。

我为自己找到了这个解决方案而感到自豪。

* * *

接下来，我们有一些东西对任何做过形式逻辑的人来说都是显而易见的，但对我来说却是一个真正的启示/成就。

作业的第一部分是再现“或”功能，即||运算符，只有！和&&运算符。第二个是仅用！和||一起工作。

```
function or(a, b){
    return !(!a&&!b);
}

function and(a, b){
    return !(!a||!b);
} 
```

之前我已经用 if/else 语句写了 or，说明了！a&&b，a&&！b 和 a&&b 作为应该返回 true 的潜在事例。找到一种方法在一行中简洁地编写它，而不使用 JS 控制流的任何装备，感觉就像是一种启示。

当然，秘密在于“or”操作符只有在两个操作数都为假时才返回假。所以我们可以把这种情况表示为！一&&！当 a 和 b 都为假时，它将解析为“真”,在所有其他情况下，它将解析为“假”。这与我们想要的功能正好相反，所以最后一步是简单地反转得到的布尔值。

类似地，我写了如下的 a & & b:

```
function and(a, b){
    if (a) if (b) return true;
    return false;
} 
```

我无法理解如何有效地约束||操作符，老实说，我需要看一眼别人的解决方案，以便理解如何概念化我自己的解决方案。

尽管如此，填充剩余部分以得到这个解决方案，并以这些方式清理它感觉很美。解决方案是优雅、完美的构造。没有一个被浪费的角色，所有人都在一起工作。没有瑕疵，没有边缘案例。只是逻辑。

我们再来看看他们:

```
function or(a, b){
    return !(!a&&!b);
}

function and(a, b){
    return !(!a||!b);
} 
```

啊，如此宁静。