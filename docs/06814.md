# 组合字符警告

> 原文:[https://dev.to/hoelzro/combining-character-caveats-34ng](https://dev.to/hoelzro/combining-character-caveats-34ng)

*最初发布于[hoelz . ro](https://hoelz.ro/blog/combining-character-caveats)T3】*

我目前正在遵循[永远流利](http://fluent-forever.com/)的方法学俄语。该方法建议，当你开始学习词汇时，你应该学习 625 个常见的，具体的，你很容易联想到图片和感觉的单词。接下来的一步是建立你的词汇量，包括你的目标语言中 1000 个最常用的单词。我最近完成了 625 个单词的基础，所以是时候继续下一个 1000 个单词了。只有一个小问题...

# [](#nobodys-perfective)人无完人(ive)

俄语和它的斯拉夫兄弟一样，有一个区别，反映在它的动词上，即所谓的*体*(我在[之前的一篇文章](https://hoelz.ro/blog/english-a-weakly-typed-language)中提到过这个)。几乎所有的动词都有对应词——一个是*完成体*，表示一个动作已经完成；另一种是*未完成态*，表示一个动作正在进行中或者习惯性发生。例如(如果你说俄语，而我把你的语言搞砸了，我道歉！):

> ясыркаждыйденьяжил。-我住在阿姆斯特丹的时候每天都吃奶酪。(使用 **есть** ，未完成“吃”)

对比:

> 我一小时前吃了一个 T1 汉堡。我是 ate a hamburger an hour ago。(美国之音 T2 吃 T3，PERFECTIVE“to eat”)

所以我的问题是:

*   我的 625 个单词的起始列表没有指出动词属于哪个方面，也没有包括每个动词的对应词。
*   我的接下来的 1000 个单词的列表包含的动词可能是我的 Anki 甲板中已经存在的一些动词的对应词。例如，我有говорить(说，不完全的)；如果这份 1000 人的名单中有сказать、говорить's 的同伙，那么把它作为一张单独的卡片包括进来就有些奇怪了。

因此，理想情况下，我想做的是将我的 Anki 卡片组中的动词与它们的对应词相关联，并从“下一个 1000 个”列表中删除我已经知道的任何动词(以及它们的对应词)。

为了做到这一点，我需要找到俄语中完成/未完成对等词的映射。对我来说幸运的是，Wiktionary 有一个关于俄语动词的综合数据集。一个小小的网络抓取魔法，我就成功了！

# [](#dont-stress-out)不要紧张

我基于 Wiktionary 数据创建的映射如下所示:

> 说吧

如果你仔细看，你会在и和а上看到一个重音符(◌́)。这不是标准俄语正字法的一部分。你看，俄语的重音是不可预测的，所以为了让像我这样的人学习这种语言，或者让以俄语为母语的人理解如何正确地发新单词的音，在字典之类的东西中经常使用重音来标记重音所在的音节。然而，我的 Anki deck 没有这些标记——我有声音文件来告诉我哪些音节要重读。所以为了比较两组数据，我需要先去掉标记。

因为标记是通过`COMBINING ACUTE ACCENT`字符添加的，所以解决方案看起来非常简单；看起来是这样的:

```
$verb .= subst(/<:Combining_Mark>/, '', :g); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

只需从动词中去掉所有的组合符号——看起来很简单，对吗？

但是当我真正执行这段代码时，我得到了原来的字符串“говори́ть”。怎么回事？

# [](#normalization)归一化

要理解为什么我的代码不起作用，理解 Unicode 范式和 Perl 6 如何实现字符串操作是有帮助的。规范化形式是规范化 Unicode 字符串的一种方式，使比较和排序更加容易。要了解这在实践中是如何工作的，让我们来看两个字符串:“á”和“a \659;”。虽然它们看起来一样，但是如果你把它们粘贴到一个可以检查 Unicode 的应用程序中(我喜欢只检查`echo "á" | xxd`)，你会发现它们实际上是两个不同的字符串。第一个是`LATIN SMALL LETTER A WITH ACUTE`；后者是`LATIN SMALL LETTER A` + `COMBINING ACUTE ACCENT`。在许多编程语言中，如果你比较这两个字符串，它们会显示为不相等，因为当你逐个代码点地考虑它们时，它们*是*不相等的。这个问题的解决方案是 [Unicode 规范化](https://en.wikipedia.org/wiki/Unicode_equivalence#Normalization)，它允许我们将一个 Unicode 字符串翻译成某种可以同等比较的规范形式。例如，在 NFC 标准化下，如果可能的话，组合字符被压缩成预先组合的形式，因此两个字符串最终都只是`LATIN SMALL LETTER A WITH ACUTE`。大多数编程语言要求您在对 Unicode 字符串进行任何比较操作之前对它们进行规范化；Perl 6 是为数不多的语言之一(据我所知，Elixir 是唯一一种也属于这种情况的语言)这里是个例外:

```
say "\c[LATIN SMALL LETTER A WITH ACUTE]" eq "a\c[COMBINING ACUTE ACCENT]"; # True 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这在 Perl 6 中“行得通”的原因是因为 Perl 6 中的 Unicode 字符串被规范化为所谓的 NFG，或“范式字素”。你可以阅读乔纳森·沃星顿对 NFG 及其实现的解释[这里(PDF)](http://www.jnthn.net/papers/2015-spw-nfg.pdf) ，这里，这里，但简而言之，NFG 意味着字符串的每个元素都是一个单一的字符，就像人类思考字符一样——当我们必须在纸上写下一个单一的字符时，我们会想到什么。

# [](#think-in-graphemes)用字形思考

我的问题是我在考虑一个*代码点*的层次，而不是一个*字形*的层次。Perl 6 将“и\769;”和朋友视为单个字符——不再有组合符号。如果您使用 NFC 标准化，在其他语言中您会遇到这个问题(但不是西里尔字符，因为它们没有带重音的预先组合的形式。).所以我解决这个问题的方法是使用`Str.trans`方法，它将一组字符映射到另一组:

```
$verb .= trans('а́е́и́о́у́я́э́ы́ёю́' => 'аеиоуяэыёю'); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

或者，我可以使用`Str.NFD`方法取回 NFD 对象，并在将它转换回`Str`之前过滤掉`COMBINING ACUTE ACCENT`代码点。这对我来说太低级了——如果将来`NFD`和相关类型支持`Str`之类的操作比如`subst`就好了。

在 IRC 上喝茶的时候，我得到的另一个建议是使用`:codes`副词:

```
$verb .= subst(rx:codes/<:Combining_Mark>/, '', :g); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

...它告诉正则表达式引擎考虑代码点，而不是字素。不幸的是，这一点尚未落实。

在我做出改变后，我得到了我想要的结果，我最终得到了一个漂亮的单词列表来添加到我的 Anki deck 中。成功！

我希望阅读这篇文章能让您对 Unicode 有一点了解，并有希望在将来节省一些使用 Unicode 的时间，无论是在 Perl 6 中还是在您最喜欢的语言中！