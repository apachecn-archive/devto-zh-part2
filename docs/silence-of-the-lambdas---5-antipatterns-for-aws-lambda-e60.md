# AWS Lambda 的 Lambdas - 5 反模式的沉默

> 原文：<https://dev.to/dgreene/silence-of-the-lambdas---5-antipatterns-for-aws-lambda-e60>

[![Silence of the Lambdas](../Images/dddd9f8d26e69047c4cfe512d6658f2a.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--KZ3LkpSD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.3pillarglobal.com/wp-content/uploads/2018/01/silence-of-the-lambdas-fb.png)

本文最初出现在:[[https://www . 3 pillar global . com/insights/silence-lambdas-5-anti-patterns-AWS-lambda](https://www.3pillarglobal.com/insights/silence-lambdas-5-anti-patterns-aws-lambda)]

众所周知，AWS 抓住一切机会推销他们的无服务器产品。无服务器容器、存储、NOSQL，甚至关系数据库都将产品软件的运行从运行它们的底层基础设施中抽象出来。AWS 无服务器领域的核心是他们的 Lambda 产品。它是功能即服务(Function-as-a-service，FaaS)，这意味着它在各种事件驱动的触发器上执行代码包，如 HTTP 调用、通知主题、S3 文件删除，甚至是预定的 cron 作业。

在 3Pillar Global，我们使用它们来为客户和内部构建无服务器产品，涵盖计算机视觉、数据处理和各种产品开发。然而，在使用它们的过程中，我们发现了一些“陷阱”,在您采用这种新的云计算模式时，您应该注意这些陷阱。我们在这里为你收集了它们，并希望这些指针有助于避开——或者至少准备好——你在 Lambda 上可能遇到的挑战。

# 像服务器一样构建 Lambdas 完整代码

当您编写在传统服务器软件上运行的代码时，您通常会利用服务器启动时间，当涉及到最终用户时，尽可能地预加载，以最大限度地减少代码执行时间。在 Lambda 中，您的服务器可以在任何时候有效地重启，因此您可以——并且愿意——支付和再支付启动成本。专注于编写精简且快速响应的代码。除非需要，否则不要加载任何不需要的东西。

如果您使用 Java 作为语言，这一点尤其重要，因为几乎所有的实践都是关于在启动时加载类的。当使用像 Spring 这样的框架时，很容易无意中引入大量的依赖树，这加剧了这种情况。我非常喜欢 Spring，但是它不太适合 Lambda 容器生命周期。我还建议在你的 package/pom/gradle/nuget 文件中添加依赖项时要残忍。如果您达到了 Lambda 代码限制(50 MB)，您可以分析您的依赖关系树，甚至可能放入一些显式排除。

也就是说，您可以通过对昂贵的资源采取单一方法来利用代码容器被重用的时间——如果它在那里，就使用它，但不要假设它在那里，如果它不在，就初始化它。所有 Lambda 容器上都有一个“/tmp”挂载，您可以将它用作暂存区，但是同样，您不能假设在不同的调用之间会使用相同的容器。作为“最后”手段，您可以利用 CloudWatch 事件来定期“ping”您的函数以保持其热度。我不建议这样做，除非它能提供显著的好处，而且即使这样，你也不能指望它总是工作，所以你仍然需要处理“冷”Lambda。

# 忽略监控服务

通常，您可以调查服务器日志中的问题。没有服务器并不意味着没有日志——默认情况下，函数输出被路由到 CloudWatch 日志。这些日志是按“流”组织的，所以找到您想要的确切执行可能很困难。通过跨 API/Lambda 调用使用关联 ID，让您的工作变得更加轻松。此外，为每个错误提供唯一的文本标识符，以便更容易地找到记录。对于与性能相关的查询，Lambda 日志记录的最后一行包括总请求时间和使用的内存。此外，X 射线还提供了对集装箱启动和跟踪功能的深入了解。利用它来了解操作的细节。

虽然 CloudWatch 日志永远不会像服务器那样耗尽驱动器空间，但日志事件的默认保留是永久的。为了避免不断增加的成本，您可能希望更改您的保留策略，使日志在可接受的时间范围内自动过期。

# 手动完成一切

AWS 的无服务器选项非常广泛，并且每周都在扩展。当试图构建一个由无服务器技术支持的生产解决方案时，您很容易被试图定义所有的部分并将它们连接在一起所淹没。令人欣慰的是，市场上出现了许多解决方案来简化这一切。AWS 有两个相关的解决方案——无服务器应用模型(SAM ),以及一个名为“Chalice”的 python 专用版本。非 AWS 解决方案——Serverless.com、Apex 和 Zappa——在本质上是相似的，尽管它们确实提供了多云支持，因为无服务器不仅仅是 AWS 的事情。

在任何情况下，都要确保能够定义服务所依赖的辅助资源(例如 IAM 角色、S3 桶、DynamoDB 表)。考虑到添加这些资源是多么容易，如果你还没有的话，现在是推行“基础设施即代码”的大好时机。通过将需求存储在源代码存储库中来控制您的支持资源，并消除手动部署和配置，极大地稳定了您的产品操作。

# 未能建立标准&约定俗成

就如何配置它而言，AWS Lambda 是非常开放的——任何匹配正确签名的函数都可以被定义为该函数的处理程序。你想怎么命名都行。如果你只是匆匆忙忙，你可能会发现自己陷入了一个难以置信的难以维护和故障诊断的代码老鼠窝。我建议您尽早建立命名和环境约定——例如，始终将您的函数处理程序命名为与函数名称相同的名称，并将方法命名为“处理程序”(或者您想要的任何模式)，只需定义一个并强制执行即可。

因为不是所有的 AWS 资源都支持“环境”的概念，所以一定要使用命名约定，比如 S3 桶名、DynamoDB 表名等等。并让 Lambda 代码在它运行的环境中传递，作为一种将所有代码映射在一起的方法。

坐下来，从逻辑上决定你在服务、功能、代码库等之间划的线。随着产品/代码变得越来越复杂，我会开始粗粒度化和拆分。拆分代码比合并代码容易得多。

最后，Lambda 的一个好处是它的多语言特性——如果需要，你可以用一种独立的受支持的语言来编写每个函数。我强烈建议让你的产品尽可能少地使用语言，但是如果需要库或功能的话，也可以选择使用其他语言(这里我想到了 Java 和 Python)。将这些作为“例外”而不是规则，以减少认知开销。

# 不要因为没有服务器就停止常规的最佳实践

由于部署无服务器代码的不同性质，人们习惯于放弃许多实践。这一点，再加上开始接触新技术的本质，导致许多人忽略了一些非常重要的编码实践。仅仅因为你的代码不再运行在显式硬件上并不能免除你的错误。您仍然应该在您的源代码控制中使用相同级别的严格性，仍然执行代码审查，并且仍然对您的代码执行静态分析。

事实上，AWS 提供了许多代码发布功能，这些功能本身是无服务器的，包括用于 git 存储库的 CodeCommit、用于 CI 构建的 CodeBuild、用于推送内容的 CodeDeploy 以及用于协调所有这些功能的 CodePipeline。此外，您仍然需要编写单元测试，并在构建时执行它们。缺少服务器不会降低测试的价值。您可以根据自己选择的语言使用标准的测试工具集；“功能即服务”的一个好处是它试图概括单一责任原则，这实际上非常适合测试。您还可以创建额外的函数来用作测试工具和/或实用程序。

最后，有几种方法来执行“本地”开发。第一种是使用特定于开发人员的环境，同时仍然将您的代码和功能部署到 AWS。这样做的好处是代码可以在与将要部署的环境相同的环境中运行，但也有一些小缺点——断点更难管理，而且部署到 AWS 会有成本(不是很多，但确实有)。除了“开发”、“测试”和“生产”之外，每个团队或每个开发人员都有一个环境，再加上这一点，您可以看到有一个维护成本。幸运的是，有多种解决方案——AWS 提供“SAM Local ”, Serverless.com 提供函数的本地调用，甚至还有 Local stack——许多 AWS 服务的“本地”实例的非常健壮的集合，甚至包括作为 Docker 容器的 runnable。可以利用这些解决方案快速部署到开发人员的机器上，以便高效地进行调试，而不会污染您的 AWS 帐户和/或 git 存储库。

# 特殊奖励 Gotchas

## 递归是没有限制的风险

最后一个警告是要小心函数的递归执行，不管是有意还是无意。在正常环境下，如果您不小心将自己置于一个无限循环中，您的 CPU 将会达到最大限度(该函数触发一个事件，该事件又触发该函数……)。在无服务器中，你将执行一次“DoW 攻击”——对你自己的钱包攻击的否认——并且你的 10-20 美元的开发账单可以在几乎没有警告的情况下飙升到数千美元。对于所有事件驱动的模型来说，这是一个反模式，但是由于 AWS 的自动伸缩能力，这确实是一个与您的工程副总裁或 CFO 进行的尴尬对话。检测或防止这种情况的一些方法是针对 Lambda 调用总数设置 CloudWatch 事件警告，或者实现计费警报。如果你的产品真的需要递归，你可以在函数调用之间传递数据(在事件对象中),以保持递归计数，并放入一个故障保险，如果达到一个非常不合理的水平——比如 10，000——就会中止执行。

## 幂等是关键

关于 Lambda 执行有一个肮脏的小秘密——你的函数可能会因为同一个根事件而被触发多次。其中一些原因是，许多潜在的来源是“至少传递一次”，因此实际上可能会多次触发；另一个原因是，在某些情况下，Lambda 实际上可能会重试执行您的代码(更多详细信息[在这里](https://docs.aws.amazon.com/lambda/latest/dg/retries-on-errors.html))。因此，你的 Lambda 代码应该都是幂等的。虽然这对于读操作来说是微不足道的，但对于写操作来说却可能变得非常复杂。处理这个问题的“最简单”的方法是利用从所有来源传入的请求 ID，并在您的应用程序逻辑中找到一种方法来查看该请求 ID 是否已经被处理。如果事件被传递，请确保在后续事件的有效负载中包含原始的源请求 ID。

# 总结

最后，产品部署的未来将绝对包括无服务器方面——在 AWS 上，这意味着 Lambda。抓住机会迁移到这些功能可以提供微服务的大部分承诺，如果你做得好，负面影响会尽可能少。

保持多云，我的朋友。