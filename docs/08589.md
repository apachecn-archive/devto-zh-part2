# JavaScript 反应性的最佳解释

> 原文:[https://dev . to/chasew Gregory/the-best-explain-of-JavaScript-reactivity-1pc 6](https://dev.to/chasewgregory/the-best-explanation-of-javascript-reactivity-1pc6)

*截图和代码片段，点击这里的链接-[JavaScript 反应性的最佳解释链接](https://medium.com/vue-mastery/the-best-explanation-of-javascript-reactivity-fea6112dd80d)

许多前端 JavaScript 框架(例如 Angular、React 和 Vue)有自己的反应性发动机。通过理解什么是反应性以及它是如何工作的，您可以提高您的开发技能，并更有效地使用 JavaScript 框架。在下面的视频和文章中，我们构建了你在 Vue 源代码中看到的那种反应。

[https://www.youtube.com/embed/7Cjb7Xj8fEI](https://www.youtube.com/embed/7Cjb7Xj8fEI)

如果你看的是这个视频而不是这篇文章，那就看下一个视频，和 Vue 的创始人尤雨溪讨论反应和代理。

💡反应系统
Vue 的反应系统在你第一次看到它工作的时候看起来就像魔术一样。以这个简单的 Vue 应用程序为例:

不知何故，Vue 只知道如果价格发生变化，它应该做三件事:

更新我们网页上的价格值。
重新计算价格*数量相乘的表达式，并更新页面。
再次调用 totalPriceWithTax 函数，更新页面。
但是等等，我听说你想知道，当价格变化时，Vue 如何知道更新什么，它如何跟踪所有的事情？

JavaScript 编程通常不是这样工作的

如果你还不明白，我们要解决的大问题是编程通常不是这样工作的。例如，如果我运行以下代码:

你觉得它会印出什么？由于我们没有使用 Vue，它将打印 10。

在 Vue 中，每当价格或数量更新时，我们都希望 total 得到更新。我们想要:

不幸的是，JavaScript 是过程性的，而不是反应性的，所以这在现实生活中行不通。为了使 total reactive，我们必须使用 JavaScript 来改变事情的行为。

⚠️问题
我们需要保存计算总数的方法，这样当价格或数量发生变化时，我们可以重新计算。

✅解决方案
首先，我们需要一些方法来告诉我们的应用程序，“我将要运行的代码，存储这个，我可能需要你在另一个时间运行它。”然后我们要运行代码，如果价格或数量变量得到更新，再次运行存储的代码。

我们可以通过记录函数来实现这一点，这样我们就可以再次运行它。

注意，我们在目标变量中存储了一个匿名函数，然后调用一个记录函数。使用 ES6 箭头语法，我也可以这样写:

记录的定义很简单:

我们正在存储目标(在我们的例子中是{ total = price * quantity })，这样我们可以稍后运行它，也许可以使用一个重放功能来运行我们记录的所有内容。

这将遍历我们存储在存储阵列中的所有匿名函数，并执行每个函数。

然后在我们的代码中，我们可以:

很简单，对吧？这里是完整的代码，如果你需要通读，并试图再次掌握它。仅供参考，我以一种特殊的方式编码，以防你想知道为什么。

⚠️问题
我们可以根据需要继续记录目标，但最好有一个更强大的解决方案，可以与我们的应用程序一起扩展。也许是一个负责维护目标列表的类，当我们需要它们重新运行时，它会得到通知。

✅解决方案:依赖类
我们可以开始解决这个问题的一个方法是将这个行为封装到它自己的类中，一个实现标准编程观察者模式的依赖类。

因此，如果我们创建一个 JavaScript 类来管理我们的依赖关系(这更接近 Vue 处理事情的方式)，它可能看起来像这样:

请注意，我们现在将匿名函数存储在订户中，而不是存储。我们现在调用 depend 函数来代替 record 函数，我们现在使用 notify 函数来代替 replay 函数。要让它运行起来:

它仍然工作，现在我们的代码感觉更可重用。唯一还觉得有点诡异的是目标的设定和运行。

⚠️问题
在未来，我们将为每个变量创建一个 Dep 类，封装创建匿名函数的行为将会很好，这些匿名函数需要被监视更新。也许一个监视函数可以处理这种行为。

因此，与其打电话:

(这只是上面的代码)

我们可以打电话给:

✅解决方案:一个观察函数
在我们的观察函数中，我们可以做一些简单的事情:

如您所见，watcher 函数接受 myFunc 参数，将其设置为我们的全局目标属性，调用 dep.depend()将我们的目标添加为订阅者，调用目标函数，并重置目标。

现在，当我们运行以下命令时:

您可能想知道为什么我们将 target 实现为一个全局变量，而不是在需要的地方将它传递给我们的函数。有一个很好的理由，这将在我们文章的结尾变得显而易见。

⚠️问题
我们只有一个 Dep 类，但我们真正想要的是每个变量都有自己的 Dep。在我们继续下一步之前，让我把东西移到属性中。

让我们假设我们的每个属性(价格和数量)都有自己的内部 Dep 类。

当我们跑步时:

由于 data.price 值是被访问的(确实如此)，我希望 price 属性的 Dep 类将我们的匿名函数(存储在 target 中)推送到它的订户数组中(通过调用 dep.depend())。由于 data.quantity 被访问，我还希望 quantity 属性 Dep 类将这个匿名函数(存储在 target 中)推入它的订户数组。

如果我有另一个匿名函数，只访问 data.price，我想把它推送到 price 属性 Dep 类。

我希望何时对 price 的订户调用 dep.notify()。我希望它们在定价时被调用。到本文结束时，我希望能够进入控制台并执行以下操作:

我们需要某种方法来挂钩数据属性(比如价格或数量)，这样当它被访问时，我们可以将目标保存到我们的订户数组中，当它被更改时，运行存储在我们的订户数组中的函数。

✅解决方案:Object.defineProperty()
我们需要了解 Object.defineProperty()函数，也就是普通的 ES5 JavaScript。它允许我们为属性定义 getter 和 setter 函数。在我向你展示我们如何在 Dep 类中使用它之前，让我向你展示最基本的用法。

如您所见，它只记录了两行。然而，它实际上并没有获得或设置任何值，因为我们忽略了这个功能。现在再补充回去吧。get()期望返回一个值，set()仍然需要更新一个值，所以我们添加一个 internalValue 变量来存储我们当前的价格值。

现在我们的 get 和 set 都正常工作了，您认为会在控制台上输出什么呢？

所以我们有办法在获取和设置值时得到通知。通过一些递归，我们可以对数据数组中的所有项运行这个函数，对吗？

仅供参考，Object.keys(data)返回对象的键数组。

现在每样东西都有 getters 和 setters，我们在控制台上可以看到。

🛠把两种想法结合在一起

当像这样的一段代码开始运行并获得 price 的值时，我们希望 price 记住这个匿名函数(target)。这样，如果价格发生变化，或者被设置为一个新值，它将触发这个函数重新运行，因为它知道这条线依赖于它。所以你可以这样想。

Get = >记住这个匿名函数，当我们的值改变时，我们将再次运行它。

Set = >运行保存的匿名函数，我们的值刚刚改变了。

或者在我们的 Dep 类中

price access(get)= >调用 dep.depend()保存当前目标

价格设置= >对价格调用 dep.notify()，重新运行所有目标

让我们结合这两个想法，并通过我们的最终代码。

现在看看我们玩的时候在我们的控制台上发生了什么。

这正是我们所希望的！价格和数量确实是反应性的！每当价格或数量的值更新时，我们的总代码就会重新运行。

Vue 文档中的这个插图现在应该开始有意义了。

你看到那个有 getters 和 setters 的漂亮的紫色数据圈了吗？应该看着眼熟吧！每个组件实例都有一个 watcher 实例(蓝色)，它从 getters(红线)收集依赖关系。当稍后调用 setter 时，它会通知观察器，从而导致组件重新呈现。这是我自己加了一些注释的图片。

是啊，这难道不是更有意义了吗？

显然，Vue 如何在幕后做到这一点要复杂得多，但您现在已经了解了基本知识。

⏪那么我们学到了什么？如何创建一个 Dep 类，它收集一个依赖项(depend)并重新运行所有的依赖项(notify)。
如何创建一个观察器来管理我们正在运行的代码，这可能需要添加(目标)为依赖项。
如何使用 Object.defineProperty()创建 getters 和 setters。
下一步是什么？
如果你喜欢和我一起学习这篇文章，你学习道路的下一步是学习与代理的反应。一定要看看我在 VueMastery.com 的关于这个话题的免费视频，我还和 Vue.js 的创始人尤雨溪聊了聊

最初发表于[www.vuemastery.com](http://www.vuemastery.com)。