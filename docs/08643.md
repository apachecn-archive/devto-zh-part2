# 建设性拖延

> 原文:[https://dev.to/pbeekums/constructive-procrastination-49a5](https://dev.to/pbeekums/constructive-procrastination-49a5)

我最近读了一篇关于拖延症的很棒的文章。虽然普遍的观点是拖延是浪费时间，但它也可以成为创造力的源泉。这让我想起了当你把头撞向一个问题时的经典建议:休息一下。走开。深呼吸。

[![](../Images/1df20435606a19dc5068b4eb3dc6062a.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--EoyjwSF6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://blog.professorbeekums.com/img/2018/procrastinate.jpeg)

一年前，我开始进一步采纳这个建议。如果我被一个问题困住了，我会推迟至少一天。我开始尝试这个是因为我十年前的一次经历。我花了几天时间研究这个并不复杂的功能。大部分时间都花在了我引进的几个 bug 上。我没有像以前那样长时间工作，而是回家了。第二天，我顿悟了，把我写的所有代码放在一边，并在几个小时内重写了所有代码。

推迟工作不仅仅在我被一个问题困住的时候有帮助。当我有一个解决问题的方法时，它也经常有帮助，但是我讨厌它。一个例子是当我在为 [Maleega](https://maleega.com) 做文件版本的时候。我想将同一附件的不同版本分组到一个电子邮件线程中:

[![](../Images/ecac010ea1ad4b8a7b1acba72e1ffda2.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--jjrFCYhW--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://blog.professorbeekums.com/img/2018/file_versions.png)

当我第一次开始的时候，我陷入了构建一个树形结构的编程兔子洞。如何存储版本的版本的版本？我该如何展示这样的东西？我需要准备什么样的边缘情况，需要构建什么样的测试？这些事情都不是不可能的，只是需要一点努力。

停止工作。和我的狗一起玩。看书。睡着了。

第二天，我意识到我所有的努力都是为了制造一个劣质产品。如果我只做一个层次的分组，这不仅是一个更容易让用户理解的模型，而且更容易编写代码。绝对没有理由存在多层次的版本。拖延让我有时间想出一个更好的解决方案，而不是花更多的时间在一个糟糕的方案上。

还有一次，我正在为 Maleega 重构用户系统，以清理我最初原型的一些技术债务。我显著地改变了用户在我的系统中的实际情况，这需要一堆新的数据库表。迁移开始是这样的:

[![](../Images/dae0fdc2bcb90d64d97f17984f6bab35.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--vfrBDLvy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://blog.professorbeekums.com/img/2018/badmigrate.png)

问题是用户 id 在许多其他需要更新的表中被引用。不适当的迁移虽然不太可能，但有可能为另一个人显示一个人的数据。这在电子邮件产品中是完全不可接受的。所以这将导致花费大量的时间来构建自动化测试和运行手动测试。

我把这方面的工作推迟了几天。最终我想出了一个愚蠢的简单解决方案。为什么不仅仅保留原始的用户 id 呢？

[![](../Images/2e613c8b60105faf78afcdd53dabfe37.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--7X0LYY3j--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://blog.professorbeekums.com/img/2018/goodmigrate.png)

这需要克服一些程序员对数据“混乱”的强迫症，但它大大减少了开发时间和产品风险。没有其他表需要更新，因为所有的用户 id 都是相同的。拖延两天为我节省了数周的工作，这是一个更安全的解决方案。

拖延并不总是有效的。有时候，我没有更好的想法，我坚持实施我试图避免的令人不快的解决方案。在这些情况下，有让拖延变成破坏性的风险。如果更好的想法从来没有出现，那么把事情推迟到更好的想法出现是行不通的。我也多次落入这个陷阱。

对我来说，确保拖延是建设性的最有效的方法是每天都回到问题上来。这并不是说拖延一天，第二天看一个问题 5 分钟，然后马上再拖延一天。这意味着付出合理的努力，试图找到一个更好的解决方案。贯穿为什么最初的解决方案有效，为什么我讨厌它。集思广益一些其他想法，即使他们马上被排除。在继续拖延被证明是合理的之前，需要进行认真的思考。

当然，拖延在任何时候都是难以自圆其说的。你今天剩下的时间到底要做什么？

仅仅因为你在一件事情上拖延并不意味着你没有其他事情可以做。总是有错误需要修复，测试需要编写，技术债务需要清理，或者其他优先级较低的特性。重要的是确保其他事情比你拖延的问题更简单。只有当只有一件事需要认真思考时，像这样分散注意力才是可行的。

这可能会妨碍大多数开发过程。冲刺规划并没有真正考虑到拖延症。但是有办法把它放进去。也许直到解决方案的计划真正准备好了，一个故事才被指出或投入冲刺。或者也许你计划拖延 2-3 天，直到你咬紧牙关。总有其他的故事可以写。或者你可以在冲刺之间休息一下，以便有足够的时间来计划下一次冲刺。

重要的是要认识到，创造更好的技术解决方案需要一定的创造力。创意不能强求。我很少强迫自己长时间坐下来想出好主意。他们经常自己来。拖延提供了所需的时间。