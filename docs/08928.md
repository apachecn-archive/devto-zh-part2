# 多少逻辑才算太多逻辑？

> 原文:[https://dev . to/pitermarx/how-much-logic-is-too-much-logic-56ni](https://dev.to/pitermarx/how-much-logic-is-too-much-logic-56ni)

今天有一个关于构造函数和它们应该有多瘦的小争论。

在这篇文章中，我将尝试解释我的立场。

总的来说，我们都同意构造函数不应该做太多。尽管如此，我申明，在某些情况下，考虑到一些规则得到尊重，在其中加入逻辑是可以接受的，甚至是有用的。

在这篇文章的剩余部分，我将把构造函数中的逻辑简称为“逻辑”,但也可以是:

*   简单的操作
*   复杂的逻辑，甚至
*   IO 访问

主要争论点是构造函数不应该有可能抛出。首先我将回顾反对它的论点，然后给出一些支持它的论点。

反对在构造函数体中包含“逻辑”的论点有 4 条

1.  难以跟踪异常/内存泄漏
2.  单一责任
3.  最小惊讶原则( [POLA](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)
4.  用于解耦/测试目的的依赖注入

#### [](#on-the-point-one-this-is-simply-not-true-in-most-cases)就第一点而言，这在大多数情况下根本不成立

难以跟踪的异常只存在于您没有自己实例化该类并且没有适当的日志记录来查看堆栈跟踪的情况下。真的不适用

内存泄漏可以追溯到 c++中，c++可以为对象分配内存，如果有未处理的异常，就永远不会释放内存。英寸这也不适用，因为这种语言是垃圾回收的。

如果没有析构函数，也没有需要释放的对象，这不是构造函数中没有逻辑的理由

#### [](#on-the-point-two-the-single-responsibility-is-arguable)在第二点上，单一责任是有争议的

这是一个合理的原则，争论点是什么是建设者的责任。

如果构造函数产生副作用或改变其他对象，这显然是不好的，但是如果“逻辑”是让对象进入有效状态，我认为在构造函数内部是有效的逻辑

#### [](#on-the-third-point-pola-lets-see-what-could-be-astonishing)关于第三点，POLA，让我们看看会有什么惊人之举

如果你给一个对象一组无效的参数，你应该惊讶于它抛出一个异常吗？

如果你给一个对象一个 connectionstring，你应该对它进入数据库感到惊讶吗？

如果对象不能进入有效状态，您应该对它不能被实例化感到惊讶吗？

这是一个很好的原则，但我不认为上述任何一种情况是惊人的

#### [](#on-the-fourth-point-inversion-of-control-i-agree-on-all-cases)关于第四点，反转控制，我同意所有情况

如果你希望你的对象是可测试的，它不应该直接实例化任何其他对象，除非这两个对象应该只一起测试

如果您希望您的对象是可测试的，它应该直接使用任何静态成员

如果你违反了这些原则，单元测试是不可能的。你的测试将不仅仅包括你的对象

我的主要论点是，我认为构造函数应该只允许对象进入有效状态。我认为这是合理的，没有争议。

构造函数的工作是使对象进入可用状态。基本上有两种方法可以做到这一点:

1.  两阶段施工。构造函数只是将对象带入一种拒绝做任何工作的状态。有一个额外的函数进行实际的初始化。
2.  一阶段构造，对象在构造后完全初始化并可用。

我认为两阶段法不是一个好方法。如果对象无效，每个方法都应该强制它不运行，并且如果这个类将被许多人重用，很有可能不会调用 *Init* 方法

我赞成一期建设。

如果你想让你的代码[保持干燥](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)，有两种方法可以做到这一点

*   在某个地方有一个包含您的初始化逻辑的方法

我认为最好的地方是在构造函数旁边有一个静态的 *Create* 方法

*   将您的逻辑放在构造函数中

这两种方法我都用过，并且相信都是有效的。对于应该使用哪一个，我没有强烈的意见。

你怎么想呢?