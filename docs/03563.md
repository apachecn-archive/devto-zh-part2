# TDD 测试

> 原文:[https://dev.to/eljayadobe/the-tdd-test-56bh](https://dev.to/eljayadobe/the-tdd-test-56bh)

# TDD 测试

我有过一些同事做 TDD 不正确的经历。

TDD 的好处是，它给开发人员施加压力，让他们使用几个可靠的原则来设计可测试性、高内聚、低耦合，以及在签入之前通过重构立即消除技术债务。

为了强调 TDD 的价值主张，我发现在 TDD 过程中添加一个简单的小步骤有助于教育开发人员如何正确地进行 TDD。

如果开发人员正确地进行了 TDD，那么额外的步骤不会降低过程的价值。

我称之为 TDD 测试。它测试 TDD 过程。

1.  添加测试
2.  运行测试- *应该会失败*
3.  写代码
4.  运行测试- *它应该通过*
5.  重构代码- *消除新产生的技术债务*
6.  运行测试- *它应该通过*
7.  签到
8.  **删除测试**
9.  签到

当然，这失去了测试的剩余价值。但是请记住，TDD 99%的价值主张是它如何指导小型设计。

(测试的残值可以从源代码控制中恢复。这就是为什么第 7 步在第 8 步之前。)

**TDD 测试**不必永远进行。直到每个人都明白 TDD 是如何工作的。

## 詹姆斯科普特

在单元测试领域的极端是 James Coplien。在他的“[为什么大多数单元测试都是浪费的](https://rbcs-us.com/documents/Why-Most-Unit-Testing-is-Waste.pdf)”文章中，他提倡保留测试长达一年，然后去掉它们。

我不同意 Coplien 的观点，但是他提出了一个有趣的例子。取决于你的软件，他所提倡的可能适用于你的情况。我不相信他的建议适用于我创建的软件类型。

在精益的[大木](https://en.wikipedia.org/wiki/Muda_(Japanese_term))的意义上，科普林正在利用*废物*。他是*而不是*在“测试是浪费时间”的意义上使用它。

我提到 Coplien 的文章是因为 TDD 测试受到了他论文的启发。**TDD 测试**只是改变了他的“...最多一年……”部分分成”...最多一分钟……”。