# 类型:我什么时候用，什么时候不用。

> 原文:[https://dev . to/tomerbendavid/types-when-I-use-when-I-dont-1p 65](https://dev.to/tomerbendavid/types-when-i-use-when-i-dont-1p65)

## [](#introduction)简介

**以下是我个人的观点**:)

如果我写一个一页的程序，我不介意没有类型，零类型， **-1 类型，我很满意**。

如果我写一个更大的应用程序，由多个团队程序员处理，并被期望维护，我认为类型是必须的！我还是很满意的！

## [](#when-i-like-types)喜欢类型的时候

今天现代语言有`type inference`，所以类型化代码看起来非常简洁，就像非类型化代码一样，`Scala, Haskell, OCaml, Kotlin, ELM`，简洁的类型化代码既漂亮又规则！

## [](#when-i-dont-like-types)不喜欢类型的时候

我们还需要**来编译它，需要时间**，但是我愿意付出这个代价，维护时间和**代码理解时间**，也是时间。时间就是时间，一秒就是一秒，我宁愿付出几秒甚至几分钟的编译时间来换取几个小时的异常 bug 和代码可读性时间。

> 类型推断+类型= >简洁易读的代码！

但有时你仍然会发现自己在等待编译器，我倾向于去喝杯咖啡:)但这就像是**不太愉快的打字时间**。

## [](#performance-penalty-for-type-inference)对类型推断的性能惩罚

你在编译时付出了代价。如前所述，**我更愿意花钱请人来编译，而不是花钱请人来阅读和理解代码。**

> 难懂的程序编译起来也比较慢。

因此，如果你写可读的代码，它会编译得更快；)

## [](#parametric-polymorphism)参数多态性

> 参数多态性:我们定义的容器的相同子类型[A]。

`Array[A]`所以你可以有一个单独的实现来处理数组，并将其用于不同的类型- `polymorphism`。

## [](#subtype-polymorphism)亚型多态性

您继承是为了拥有多个实现。但是对我来说，你最终得到了一个巨大的对象(类层次结构),就像一个全球的 mud-code 球。

> 子类型多态性-一个大球的 mud 代码，当你遍历数组时有多种类型。

## [](#simple-type-system)简单型系统

就像在`java` **中，我们仍然受益于工具**，我们的函数在做什么，程序是如何构造的。

> 简单类型系统给了我们很好的工具！
> 
> 简单类型系统给了我们很好的文档，可以被编译器检查！

你需要向编译器解释你用那些非类型推理语言是什么意思。

## [](#rich-type-system)富式系统

(像 scala，ocaml，haskell)。

> 富类型系统允许我们拥有干净简单的代码！

这听起来很不自然，但以`generics`为例，它表达了一个可以在多种类型上多态使用的代码，即代码重用。我返回 Int，Double 不在乎我返回`A`，但我确实返回`A`。

## [](#rich-type-systems-catch-bugs)富型系统捕捉 bug

> 谎言:如果它能编译，它就能工作！

我不把这当成真理。但是许多虫子消失了:

1.  空指针异常，我不记得自从使用 Scala 以来有过。
2.  Undefined 不是一个函数，用 ELM 忘掉它吧。
3.  一个误导的变量名:这是电话号码，但我收到了一封电子邮件。
4.  微型重构后忘记更改调用者的名字。

## [](#summary)总结

我的总结非常简单，对于需要新开发人员维护的代码，而不是单页项目，我使用类型化语言，对于简单的脚本和简短的代码片段，没有类型。