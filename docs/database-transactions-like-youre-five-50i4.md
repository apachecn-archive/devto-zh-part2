# 数据库事务，就像你五岁时一样

> 原文：<https://dev.to/johndougherty68/database-transactions-like-youre-five-50i4>

## 这是怎么回事？

我从事软件开发已经很多年了，并且现在已经教了一段时间的 web 开发课程。课程的一部分是关于 MySQL 的，当学期的这一部分结束时，我总觉得有太多东西被遗漏了。我一直在记录我与学生们分享的东西，试图建立他们的数据库知识，我将把它们放在这里，希望更多的人能从中受益。

## 什么是数据库事务？

现在很流行这样的解释，比如听众已经 5 岁了，所以我也同意这种说法。

一个有两个银行账户的 5 岁孩子，这是肯定的，但是一个 5 岁的孩子。

让我们假设你在你的银行应用程序上，你想从一个账户转 100 美元到另一个账户——从储蓄到支票，为了简单起见。根据您对数据库的了解，您可能已经猜到这笔钱不会真正“花”到任何地方。转移分两步进行:

1)你的储蓄账户余额减少了 100 美元

2)你的支票账户余额增加了 100 美元

很简单。

现在，假设在第一步和第二步之间的那一瞬间出了问题。银行的数据中心什么的停电了。现在，你的储蓄账户上少了 100 美元，但支票上却没有多余的 100 美元，对吗？

幸运的是，没有。如果这是怎么发生的，你会看到很多头条新闻，如“银行停电，数百万人滞留，没有周末喝酒的钱。”我肯定我记得读过。那么，是什么让这样的问题不再发生呢？

好吧，如果你像我上面描述的那样认为这种转移可能有问题，你会选择哪个选项？

1)去做吧，如果我损失了 100 美元，我就损失了 100 美元。去做吧，如果出了什么差错，就把这 100 美元放回我的储蓄账户，我以后再试试。

你会选 2 号，对吗？至少，你想知道如果转移没有完全发生，你可以回到起点，下次再试。数据库就是这么做的:它们使用所谓的 ***事务*** 。根据 techopedia 的说法，交易是

`“a logical unit that is independently executed for data retrieval or updates”`

对一个 5 岁的孩子来说这是个可怕的定义。忘了它吧。

数据库事务只是一系列必须以要么全部要么全部不发生的方式发生的步骤。就像你的两个银行账户之间的转账一样，如果一切都做不了，最好只是把一切都回滚到我们开始的地方。

在数据库中，交易不仅仅与金钱有关，而且它们随时都在发生。假设您在数据库中更改了一个客户的 ID 号，然后必须更改该客户的所有订单以反映该客户的新 ID。这可能涉及数百个步骤(1 个步骤更改客户的 ID，无数个步骤更改该客户的订单)，如果在这个过程中发生了任何事情——不仅仅是停电，还可能是另一个用户正在使用的某个订单记录这样简单的事情——最好只是得到一个解释发生了什么的错误消息，将所有东西(客户和订单)放回原来的位置，然后重试。您最不希望看到的是客户记录和 30 个订单记录被更改，剩下几十个订单记录不变。

## (此处插入酸笑话)

这就引出了酸的话题。

ACID 是数据库人员创造的一个首字母缩写词，用来描述是什么使一个事务成为一个事务(或者一个软件在可以说它是一个数据库之前必须做什么)。让我们按照字母的相反顺序来，因为我认为这样更容易理解(DICA 可能会被委员会笑掉大牙)

**(D)可撤销**——交易一旦完成(或我们所说的*)就不能撤销或以某种方式不发生。因此，一旦客户记录及其订单被完全更新，您可以重新启动整个数据中心，客户和订单仍然会发生变化。*

 *注意:这听起来可能是个愚蠢的要求，因为它太简单了。实际上，许多数据库在计算机内存中完成最繁忙的工作，只是偶尔将数据写到磁盘上。这意味着，除非数据库非常小心，否则数据可能会被更改，并且无法保存。
另外，你可能会想“如果我把钱从储蓄账户转到支票账户，然后又从支票账户转回到储蓄账户，这和撤销它是一回事，对吗？”不。从某种意义上来说，事情的结局和开始一样。另一方面，这就像是说，如果你碰巧在同一条跑道上起飞和降落，那么去法国度假就会泡汤。将资金转入支票账户和转回支票账户实际上是两个交易。现在就去试试，然后检查你的银行对账单。这里没有“倒退”:你只是像世界上最小的对冲基金交易员一样转移资金。

**(我)孤注一掷**——我的交易和你的交易没有任何关系。如果我在自动取款机上从一个账户向另一个账户转账 100 美元，你在银行里结清抵押贷款的事实与我无关。银行能够同时处理大量的交易，而不会互相影响，数据库也是如此。

**(C)持续**——一旦事务被提交，任何查看数据库的人都会看到相同的情况(当然，假设他们有权限)。如果我把这 100 美元从储蓄账户转到支票账户，我应该能够检查我的余额，并看到钱已经动了。事实上，如果我在世界另一端的自动取款机上查看我的账户，我也应该看到钱已经被转移了。数据库不会说交易已经完成，直到所有人都看到它。

#### 书呆子警报

这是 SQL 和 NoSQL 数据库之间的一个巨大差异。SQL 数据库(如 MySQL、微软 SQL Server 和 Oracle)倾向于使用*，就像我上面描述的那样。那是他们的事。像 MongoDB 这样的 NoSQL 数据库倾向于 ***最终一致性*** 。最终的一致性就像是说，如果你转账 100 美元，你可以在你的手机应用程序上看到，也许在你当地的银行，但在城市另一端或世界另一端的银行的人可能几秒钟都看不到。这并不是一个糟糕的交易-大多数人可能不在乎世界另一端的人是否能立即看到这种转移-但重要的是要知道你有哪种一致性。*

 *最终的一致性被认为不足以让某些东西变酸。听到这个消息后，NoSQL 数据库社区的许多成员决定，他们无论如何也不希望 T1 成为 ACID，相反，他们会去做:
1)基本可用——通常启动并运行
2)软状态——更新并不总是立即出现，但
3)最终一致——它们很快就会出现

否则被称为基地(明白吗？)

MongoDB 看起来在它的最新版本中获得了几乎即时的一致性，所以在 NoSQL 世界中可能很快会有变化。

#### -书呆子警报结束-

为什么最终的一致性被认为是一个好主意？因为像 MongoDB 这样的 NoSQL 数据库在像 ***分片*** 这样的事情上投资很大，这允许你将数据库分布在许多不同的服务器上，而不是放在一个大服务器上。除此之外，分片允许您向 MongoDB 设置添加一个旧的、新的、便宜的、功能强大的服务器，并让新的服务器承担一些工作。这也使得世界上不同地方的数据库更容易像一个大数据库一样运作。这非常非常酷，但有时这意味着在数据库的所有部分都知道它之前，一个事务必须经过很多次。最终一致性的支持者认为，最好是在某种程度上承认，交易可能不会立即被所有地方的每个人看到(因为，正如我提到的，这通常不是人们想要的)。

(A)托米奇——这是以前的“要么全有，要么全无”的东西。这意味着交易中的所有步骤都必须完成，或者都不做。就像原子是最小的东西一样(或者曾经是，我猜)，事务是数据库应该做的最小的工作。如果它做不到交易的每一步，就把所有东西都放回去，然后走开(可以这么说)。

那么数据库是如何做到这一切的呢？让我们回到资金转移的例子。在这种情况下，数据库会在一个称为 ***事务日志*** 的特殊文件中写入一些内容。这就像数据库的待办事项列表。当数据库被告知将储蓄帐户余额减少 100 美元，将支票帐户余额增加 100 美元时，它会在事务日志中写出这两个步骤。当它执行第 1 步时(节省 100 美元)，它会在第 1 步旁边放置一个相当于复选标记的数据库。当它执行步骤 2 时，它会在步骤 2 旁边放置另一个复选标记。然后，它注意到它已经完成了所有应该做的事情，并草草写出了两个步骤，告诉自己整个事务已经完成。
如果像停电这样的突发事件发生，数据库知道它在开始备份后需要做的第一件事就是查看待办事项列表，寻找没有被完全删除的内容。这些事情是未提交的事务，当它找到一个事务时，它会查看这些步骤，看它能够做哪些事情(例如，节省 100 美元)。为了纠正错误，数据库将撤销这些步骤(或者执行回滚，正如我们所说的)。

好吧，这可能是好的。请给我留下一些反馈，特别是如果你想看到像这样的覆盖其他东西！**