# 偏移和光标分页解释

> 原文：<https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89>

通常，在具有数据库的应用程序中，记录的数量可能会超过一页或一个查询结果集中所能容纳的数量。当您或您的用户想要检索下一页结果时，对数据进行分页的两个常见选项包括:

1.  偏移分页
2.  光标分页

### 偏移分页

当使用偏移分页检索数据时，通常允许客户端在查询中提供两个附加参数:一个*偏移*，一个*限制*。
**偏移量就是在选择记录**之前您希望跳过的记录数。随着记录数量的增加，这个过程会变得更慢，因为数据库仍然需要读取偏移的行数才能知道应该从哪里开始选择数据。这通常被描述为`O(n)`复杂性，意味着这通常是最坏的情况。此外，在频繁更改的数据集中(通常是频繁写入的大型数据库),不同页面的结果窗口通常不准确，因为您要么会完全错过结果，要么会看到重复的结果，因为结果现在已被添加到前一页。

如果我们想从数据库中获取最新帖子的第一页，查询可能是这样的:

```
Post
|> order_by(inserted_at: :desc)
|> limit(20) 
```

Enter fullscreen mode Exit fullscreen mode

然后，当我们想要第二页的结果时，我们可以包含一个偏移量:

```
Post
|> order_by(inserted_at: :desc)
|> limit(20)
|> offset(20) 
```

Enter fullscreen mode Exit fullscreen mode

虽然最初你可以用这种方法脱身，而且这绝对值得一试——随着记录数量的增加，你可以考虑其他方法来使阅读更快更准确。

### 光标分页

这就是基于光标的分页的用武之地。**光标是特定记录的唯一标识符**，它充当指向下一条记录的指针，我们希望从这条记录开始查询以获得下一页结果。通过使用游标，我们不再需要通过在查询中使用`WHERE`子句来读取我们已经看到的行(因为数据是常数，所以读取数据更快，即`O(1)`时间复杂度),并且我们通过始终在特定行之后读取而不是依赖于记录的位置保持不变来解决不准确结果的问题。

使用我们前面的例子，但是这次用游标实现分页:

```
Post
|> order_by(inserted_at: :desc)
|> limit(20)
|> where([p], p.id < ^cursor) 
```

Enter fullscreen mode Exit fullscreen mode

为了使用游标，除了返回结果集中最后一项的游标之外，我们还需要返回第一页的结果。以这种方式使用游标对于在结果集中向前移动是很好的，但是通过改变获取方向，您增加了检索记录的复杂性。

### 结论

游标分页最常用于实时数据，因为添加新记录的频率很高，而且在读取数据时，您通常会首先看到最新的结果。在不同的场景中，偏移量和游标分页最有意义，因此这取决于数据本身和添加新记录的频率。当查询静态数据时，对于使用游标来说，光是性能成本可能还不够，因为随之而来的复杂性可能超出了您的需要。