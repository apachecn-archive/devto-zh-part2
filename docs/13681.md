# 一岁的 React 项目中的遗憾

> 原文:[https://dev . to/squ geim/rev 悔-in-a-1 岁-react-project-4j7j](https://dev.to/squgeim/regrets-in-a-1-year-old-react-project-4j7j)

JavaScript 生态系统已经变得可怕。NPM 有超过 600，000 种套餐可供选择，每天增加超过 600 种，“最佳实践”正以惊人的速度受到挑战并被热门的新事物取代。

当开始一个新项目时，想要避免跳到每一个新事物上，选择什么是需要的，这是很自然的。当我们开始一个项目时，我们就是这样做的。

这些是我们从一开始就后悔做或没做的事情:

### **1。不使用选择器**

如果没有选择器，我们就不应该碰 Redux 商店。一开始的理由很简单:如果你需要专门的方法从你的存储中提取数据，你的存储就太复杂了。相反，简化它；隐藏这种复杂性只会让它恶化。

但是我们没有看到为什么选择器是必不可少的另一个原因(我觉得这个宣传得不够):重构。接受它——你现在设计的商店不是你一年后会使用的商店。需求改变，设计改变，新功能增加，功能删除；软件在发展，你的商店也需要随之发展。

事实证明，拥有一个明确定义存储所需的接口使得重构变得简单。视图(甚至是您的容器组件)不需要知道存储中的内容是如何构造的，他们所关心的只是接收到什么数据。

此外，编写单元测试变得毫不费力。只要选择器返回相同的数据，您可以随意更改存储。

### **2。没有为重组特设链编写属性类型**

我们大量使用重组。我们的表示组件被包装在一个由构建容器组件的重组 hoc 组成的链中。它们在开始时非常简单；只有一个 Redux 连接和几个 withProps 和 withHandlers。

特设链看起来不可思议，数据像瀑布一样流下来，但当你移动东西时会发生什么？很容易忘记什么流向哪里。你可以在一个特设中移除或更改一个道具，而不会意识到其他几个组件依赖于它。

解决这个问题的一个简单方法是为每个 HOC 定义清晰的 [PropTypes](https://reactjs.org/docs/typechecking-with-proptypes.html) (或者使用类似 Flow 或 TypeScript 的类型系统)。在组件上编写属性类型变得很容易，[大多数 lint 都会检查这一点](https://github.com/yannickcr/eslint-plugin-react)，但是在重组 hoc 上编写属性类型并不那么直观，据我所知，也没有 lint 规则来检查这一点。[目前还没有明确的最佳实践。这只是一个项目惯例，需要在同行代码评审中强制执行。](https://github.com/acdlite/recompose/issues/592)

### **3。将过多的控制权让给了一个库**

“我们只是建立一个快速的 MVP 来开始。我们不需要在花哨的设计上花太多时间，让我们只使用一个流行的组件库”——这是大多数项目的开始，在你知道它之前，你正在为成千上万的用户服务，你猜怎么着，一个花哨的设计成为必须拥有的。

我们用[材质 UI](http://www.material-ui.com/#/) 开始这个项目。太棒了。你有你需要的每一个组件，你有漂亮的动画，而且很容易构建。然后，我们超越了我们的“MVP”阶段。我们有了新的复杂功能，这些功能是简单的材质 UI 组件所不能完成的。使用内联样式的少量性能成本开始增加。

然后，我们使用的材质 UI 版本停产了。新版本将会重写，并带来急需的性能改进。旧版本 Material UI [在 GitHub 中的所有问题都被关闭](https://github.com/mui-org/material-ui/issues?q=label%3Av0.x+is%3Aclosed)。

因此，我们有一个相对较大的应用程序，它受困于一个旧的库，存在性能问题，无法更新到 React 的最新版本。

我们能做什么？要么停止一切，升级到更新的版本。但是在新版本中所有被删除的组件呢？找到新的组件来替换它们，并重构我们的代码来使用它们？还是直接放下素材 UI，为一切编写自定义组件？

这两样我们都做不起。我们计划分阶段重构代码以移除更大的依赖性，一旦它足够简单，我们将升级到新版本(一旦它退出测试版)。

### **4。不使用 CSS-in-JS**

正如我所说的，我们从材料 UI 开始，这对我们来说已经足够了。我们很少需要定制任何组件，每当我们需要的时候，我们遵循官方建议并使用内联样式(这是因为 Material UI 内部使用内联样式)。

此外，我提倡 React 提出的关注点的水平分离，不喜欢将一个组件分解成多个文件(单独的 CSS 和 JS 文件)。

我们从一开始就没有 CSS-in-JS 的原因是我们当时不需要它，无论我们用内联样式增加了多少性能成本，都仍然被 Material UI 正在做的事情所掩盖。这也是因为 CSS-in-JS 社区与一些做事情的方式相冲突，并且事实上的库还没有出现(仍然没有)。

现在，我们正在从物质用户界面转移到手工构建更多的用户界面，这越来越成为一个问题。我们目前只是使用 CSS，因为这是每个人都喜欢的，但我们越来越多地为每个组件划分 CSS，以便为未来迁移到 CSS-in-JS 铺平道路。

### 最后的话

这个列表并不是在开始一个 React 项目时要注意的事情的详尽列表。我肯定网上已经有很多了。这些是我不常看到的点，也是我们最痛苦的点。

* * *