# 陷入算法设计:路径简化

> 原文:[https://dev . to/vorahsa/falling-into-algorithm-design-path-simplification-43m 8](https://dev.to/vorahsa/falling-into-algorithm-design-path-simplification-43m8)

我已经做了 7 年的专业软件开发人员，我用一只手的手指就能数清设计算法的次数。即使我对“设计算法”很慷慨。但是它已经发生了，这是一个我认为很好很成功的案例。

### 问题

我正在开发的应用程序记录了位置轨迹。出于显示的目的，我们有时可以使用完整的轨迹，但完整的轨迹可能包含数千个点，因此在大多数情况下，我们需要一个简化的版本，它仍然保持与原始轨迹相同的“形状”。经过一番搜索，我发现这叫做*线简化*或*路径简化*。

当遇到这样的问题时，我通常的方法是查看问题的现有算法。但在这种情况下，大多数现有算法需要整个轨迹，我们需要在记录过程中产生这种简化版本，以便几乎不间断地记录到每个点的轨迹。简而言之，我们需要一个在线算法。

通过搜索文献(我来自一个研究背景，我发现它足够有用，可以保持对 [ACM 数字图书馆](https://dl.acm.org/)的访问)，我确实找到了一些在线简化算法。但是通读这些论文，他们觉得实现起来太复杂了，这对于当前的算法文献来说总是一个危险。

### 数据结构

由于文献失败(或者我不擅长搜索)，我需要自己设计算法。与这个问题通常被考虑的方式不同，我们的约束不是对实际路径的任何“接近度”,而是简化路径中的点数。

这就是我决定的一般结构:我将把简化路径上的点放在一个优先级队列中，优先级是简化路径上的点的可取性。在简化的路径上，我总是有第一个和最后一个点。当队列超过允许的最大值时，我会驱逐最不需要的点。然后，在任何时候，我都可以通过获取优先级队列中的点来获得简化的路径，并且在添加新点时维护路径应该和优先级队列操作一样有效。

事实上，这是一种数据结构，我不时会发现它很有用。不仅仅是一个优先级队列，而是一个具有可调优先级的优先级队列(见下面为什么需要这样做)。它在库中一般不可用，但是实现起来并不太难，我已经用一些编程语言实现过了。(我应该设法找到那段代码，并在某一天将其发布……)

我做的是，我有一个[二进制堆](https://en.wikipedia.org/wiki/Heap_%28data_structure%29)用于优先级队列，有一个单独的[映射结构](https://en.wikipedia.org/wiki/Associative_array)指向这个堆。然后，队列可以提供调整元素优先级的操作，这是通过更新在映射中找到的元素堆中的优先级，然后适当地向上和/或向下冒泡元素来实现的。这需要一点簿记，但不会太复杂。

### 优先级功能

以上当然只是这个问题的一个算法的大致结构。关键在于优先级函数的定义，因为它决定了哪些点包含在简化的轨迹中。当然，这也有一些限制，即计算成本不能太高，也不能过于依赖“全局”信息，以免在简化轨迹发生变化时需要过多的重新计算。

我经历了几次失败的尝试，幸运的是，我可以通过很少的测试就拒绝它们。说实话，我不记得这些尝试的细节了。我依稀记得其中一个是测量简化轨迹中两个相邻点的距离(我不记得它对它们做了什么)，但随着轨迹的增长，它最终开始拒绝太多的点。

我确定的点的优先级是由该点及其在简化轨迹中的两个相邻点形成的三角形的面积，面积越大优先级越高，起点和终点被认为具有无限的面积。直觉上，这是可行的，因为大三角形对应于与直线路径的大偏差，所以包含这样的点将显示路径的主要曲线。

这个优先级函数满足要求。它计算简单，并且只依赖于本地信息。当一个点从简化的轨迹中移除时，只有它的邻居需要重新计算它们的优先级，因此维护简化的轨迹也不会花费太多时间。

### 验证

我没有对这个算法做任何形式上的分析。根据路径简化算法的任何公认标准，我不知道它的表现如何。很可能存在它表现不佳的病理情况。我所做的是获取一些我们有的真实轨迹，在非常不同的情况下记录，并将绘制的路径与从完整轨迹绘制的路径进行比较。我们都觉得它表现得很好。因此，设计和实现的算法在实际情况下表现良好。我很高兴有机会做一些算法设计，并最终得到了一些非常优雅的满足我们需求的东西。

*最初发表于*[*【futurice.com】*](https://futurice.com/blog/falling-into-algorithm-design-path-simplification)*。*