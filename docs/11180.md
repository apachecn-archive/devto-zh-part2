# 最差投票平台

> 原文:[https://dev.to/walrussoup/the-worst-voting-platform-3epo](https://dev.to/walrussoup/the-worst-voting-platform-3epo)

# [](#the-worst-voting-platform)最差投票平台

最差的投票平台是由[推动者](https://pusher.com/)驱动的实时“是\否”社区投票平台。提交一个问题，大家投票赞成或反对，就这么简单。

### [](#live-demo)现场演示

您可以前往[theworstvotingplatform.com](http://theworstvotingplatform.com/)观看演示

[![The Worst Voting Platform](../Images/e06ebe001a9fceaea23e158abb3aa78d.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--2YjiThZX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/hc8i3vp7gafkiqttju6f.JPG)

### [](#the-codebase)代码库

该代码可在 Github 上获得，有三个组件可帮助您启动和运行:

[twvp-coordinator](https://github.com/WalrusSoup/twvp-coordinator) 处理广播提问和评分
T3】twvp-frontend 处理前端
[twvp-server](https://github.com/WalrusSoup/twvp-server) 是 web 服务器组件

### [](#the-idea)想法

这个项目的产生是因为我想要一个公共实时投票平台，任何地方的任何人都可以问一个是或否的问题，并从观众那里得到答案。这可能是他们晚餐想要的，如果 X 是一部好电影，等等。它来自于我的同事在午餐时用智能手机玩的一个问答游戏。我开始真的想知道他们怎么可能在几乎没有延迟的情况下，同时向世界各地的每个人展示下一个问题。Pusher 可以解决这个问题。随着这个比赛的宣布，我终于有理由玩它，看看我是否能做出一些*能*做类似事情的东西。

还有——我真的需要学习一些正确的 Javascript 代码。

### [](#design-phase)设计阶段

我对使用 pusher 发布投票事件和问题事件有很多担忧。我在要求用户进行身份验证时遇到了一些问题。实际上，我可以让我的服务器假设每个人都经过了身份验证，但这样做似乎有点奇怪(这就使身份验证失去了意义)。同样，我会获得和失去一些处理篡改投票的能力。好处是 Pusher 会在 10 点后停止滥用，坏处是他们可能会打开 9 - 10 个窗口或连接，而我仍然不知道他们是谁。对于这个问题，我还没有一个好的解决方案。

目前，我认为实现一个非常简单的 API 层来将数据输入 redis 可能更直接。

### [](#designing-the-backend)设计后端

我使用过 Node，但我对它的用途没有真正的了解。我不是节点开发人员，我的 JS 经验止于前端。大约 25 分钟后，我发现我完全不知道如何让一个进程“永远运行”。传统上，我会使用 while 循环，简单地检查、睡眠、检查、睡眠等。然而，这在 Node 中根本不起作用。我试图设计一个休眠的 while 循环，但是休眠会阻碍不相关的承诺。为了让后端工作，它需要做以下事情(顺序也很重要):

1.  等待用户提问
2.  当有空的时候广播这个问题
3.  等待 X 秒
4.  计算“是”和“否”的总数，并广播结果

我知道使用 redis 是一个安全的赌注(rpush，lpop ),对于要服务的问题的堆栈式实现来说。此外，我还可以使用 redis 来存储投票。由于懒惰，我最终只使用了两个键(字面意思是 yes 和 no 键)和一个问题堆栈。

我不仅需要它永远运行，还需要它不停地运行。我搜遍了“节点永远运行”、“节点不退出”等等。在这一点上，我绝望地困惑着，我请我的朋友，Chinnbot.tv 的作者来帮我。他给我发了一些关于 Node 中事件循环的视频。我开始有点明白如何处理这种情况，尽管我仍然对 node 如何真正知道何时不再有工作的细节有点困惑。这是我最后得到的结果:

1.  将 yes 和 no 设置为零，调用 async 函数轮询 redis 是否有新问题，如果没有问题，则休眠 5 秒。
2.  一旦我们有问题，发出一个“新问题”事件
3.  广播新问题，然后在 8 秒钟后发出“投票完毕”
4.  投票完成后将统计问题，然后广播结果
5.  5 秒钟后，我们将回到#1

我完全预料到这个模型会溢出堆栈，因为在我看来，它们都是递归操作。然而，看起来事件循环并没有这个问题，因为它会把它放在一个队列中，并在下一个节拍运行(希望我的理解是正确的)。

### Web 服务器

其他的一切都在 Javscript 领域，也可以让 web 服务器使用它。将 nginx 上游配置为 express 很容易，我使用 foreverJS 来管理它(以及后端)。我很高兴整个经历如此简单。

### [](#the-frontend)前端

我用 [Vue](https://vuejs.org/) 和[顺风](https://tailwindcss.com/)做前端。使用 Vue 总是很有趣，尤其是使用 [vue-cli](https://github.com/vuejs/vue-cli) 来生成您的配置。我想用更漂亮的，但它似乎与 eslint 中的 ES6 推荐标准不一致(对分号的分歧)。我最终只是坚持标准设置和 vue essential。我这次也是用 Atom 而不是 Sublime - **我爱死它了**。

亲爱的 JS 开发者:你更喜欢林挺的什么？

### [](#the-name)姓名

由于时间的限制，我并没有计划为这次比赛提交任何东西，而且我已经快累垮了。然而，当它成功时，我忍不住笑了。所以，它开始是一个笑话，但在这一点上我不禁有点依恋它:)

### [](#key-takeaways)关键要点

我有很多有趣的想法，关于我们如何在生产环境中实现 Pusher，用于一些真实的世界。我可以看到这个产品进入我们的堆栈，实时通知后端事件。它是如此简单和容易，以至于我需要小心，当它是正确的时候我会选择它，而不是因为我只是想玩它。我在构建这个东西的过程中获得了很多乐趣，如果我想采取下一步措施来构建“最好的投票平台”，这是一个很好的概念证明。

### [](#the-future)未来

可能是抽搐流特征。这将是一个很酷的流媒体能够提出问题，人们只需点击按钮就可以在视频上投票。我会切换到使用客户端事件来投票，而不是我自己的小后端。