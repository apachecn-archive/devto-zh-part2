# 类型安全走得太远了吗？

> 原文：<https://dev.to/donaldsebleung/has-type-safety-gone-too-far-ecn>

不可否认，类型极大地减少甚至消除了某些类型的错误，比如错误解释存储在变量/寄存器/等中的数据。所以我明白了类型安全在这方面的重要性。只需比较一下 C 和 Java——如果你不够小心，很容易在前者中意外地创建一个 segfault，但是如果你真的不走运，在后者中你最多得到一个`NullPointerException`。然而，在我看来，像 Swift 这样的现代编程语言已经走得太远了。

我什么意思？在 Swift、Kotlin 和 Go 等强调类型安全高于一切的现代编程语言中，如果不首先显式地将整数类型转换为双精度类型，甚至不能将整数与双精度类型相乘。这使得包含整型和浮点型数值计算的代码变得不必要地冗长，而这本来应该是非常简单明了的。我明白为什么在 Java 这样的语言中禁止从 double 到 integer 的隐式类型转换(因为这是一种有损转换，程序员可能并不想这样)，但是反过来防止隐式类型转换是荒谬的。“不小心”把一个整数乘以一个双精度数，可能会犯什么 bug？

另一件我觉得很烦的事是斯威夫特/科特林(还有可能去？)完全不同地对待可空类型和不可空类型。至少在 Swift 中，默认情况下一切都是不可空的(甚至引用类型！).这意味着，如果你想定义一个递归数据结构，比如一个链表，你必须显式地将它标记为可空，否则代码将无法编译。当你试图解引用一个可空类型时，你甚至不能简单地使用点符号(例如`someObject.somePropertyOrMethod`)——你必须通过在点前面加上`?`或`!`来“安全地”解引用它。所有这些都意味着程序员必须记住一套额外的规则，并且仅仅为了“类型安全”而做更多的输入。我明白这是为了减少“空指针异常”发生的机会，但是如果一个没有经验的程序员滥用`!`解引用来编译他/她的代码，那么空指针异常还是会发生！

我的观点是，足够的类型安全非常重要，尤其是对于没有经验的程序员(因此他们应该在学习 C/C++之前先学习一种更安全的语言，比如 Python/Java ),但是在像 Swift 这样的现代“类型安全”语言中，这样做的方式更类似于“直升机养育”——它试图保护您免受所有可能的危险，但这样做的控制方式从长远来看会损害开发人员。你怎么想呢?