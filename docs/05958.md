# 论 Elixir 中上下文模块和函数的命名

> 原文:[https://dev . to/ala kra/on-naming-contextual-modules-and-functions-in-elixir-1mi 4](https://dev.to/alakra/on-naming-contextual-modules-and-functions-in-elixir-1mi4)

我遵循一些非常简单的规则，使代码在我写软件时易于阅读、推理和修改。我喜欢 [Phoenix Framework](https://phoenixframework.org/) 鼓励使用[上下文](https://hexdocs.pm/phoenix/contexts.html#thinking-about-design)来描述如何将代码组织成特定的模块和功能。我甚至喜欢他们的命名惯例。

我认为这些想法可以用在任何模拟我们在世界上遇到的逻辑的项目中。事实上，我使用了[my Ticket to Ride implementation](https://github.com/alakra/ticket-to-ride-core/)中的许多想法。

## 一开始很难让代码(或 API)易于阅读

当我不知道我正在建造的东西的全部宽度时，这对我来说总是一个挑战。就像给一个故事或者博客文章写草稿一样。我试验了单词和代码的组织，只有过了一段时间，事情才开始步入正轨。

总的来说，我尽量不强调这一点，因为我坚持几个原则:

*   使用`verb-noun`样式的函数名
*   不要用听起来像公司的词来命名你的模块(比如`manager`、`strategy`、`factory`等)。)除非在您的领域中明确描述了它们。
*   为每个公共函数编写`typespecs`(即使它是你的域下的资源)
*   如果地图正在流传，考虑给它一个正式的类型作为`struct`。
*   为您在模块中使用的任何内部依赖模块起别名。

## 使用动词-名词函数名

在[乘车票](https://github.com/alakra/ticket-to-ride-core)中，我使用了以下动词前缀:

*   增加
*   开始
*   创造
*   交易
*   破坏
*   画
*   发现
*   得到
*   有
*   加入
*   离开
*   目录
*   注册
*   注销
*   履行
*   注册
*   去除
*   替换
*   重置
*   返回
*   挑选
*   设置
*   洗牌
*   开始
*   停止

这是很多动词，但它们表示一个特定的动作。这种特殊性有助于我理解一个函数将要做什么。如果我只有这个名词作为函数名，它会告诉我会发生什么，或者会有什么副作用吗？如果我使用一个像`perform`这样模糊的动词，我是否应该考虑将其重命名为其他名称？

## 命名对您的问题领域有意义的模块

我远离像`strategy`、`manager`等公司发声模块名称。因为我认为它们是误导模式，偏离了模块的目的。模块名应该指示域或资源，而不是其他任何内容。让函数名来定义它的能力和用途。

我认为[保罗·格拉厄姆](https://en.wikipedia.org/wiki/Paul_Graham_(programmer))在[书呆子的复仇](http://www.paulgraham.com/icad.html)中说的话是有道理的:

> 当我在程序中看到模式时，我认为这是麻烦的征兆。程序的形状应该只反映它需要解决的问题。代码中的任何其他规律性都是一个迹象，至少对我来说，表明我正在使用不够强大的抽象——我经常手工生成一些我需要编写的宏的扩展。

## 编写排版

我看到这个语言特性和写测试一样强大。不是因为他们在我做错事的时候纠正我，而是他们向我表明我已经走上了一条复杂的道路，感觉它可能会在以后给我带来麻烦。例如:

```
@spec claim_route(State.t, User.id, Route.t, TrainCard.t, cost()) ::
  {:ok, State.t} | {:error, :unavailable} 
```

这是从 [TtrCore 来的。Mechanics.claim_route/5](https://github.com/alakra/ticket-to-ride-core/blob/eafb3c4d78b477c90baa80b3dd424a97f83ca315/lib/ttr_core/mechanics.ex#L189) 。

当我编写一个类似这样的 typespec(超过 4 个不同类型的参数)时，我开始感到不舒服，并试图找到简化它的方法。

我喜欢的是，它向我展示了我的类型是多么的多样化，我可以在编写任何代码之前考虑是删除它们还是组合它们。没有类型信息就很难做到这一点。

此外，我还可以推理我可能的输出。目前，这些看起来是合理的。

## 为结构化数据分配类型并传递它

在将一堆类型组合成某种复合类型(如`map`或`tuple`)后，我将在我的内部 API 中传递它以完成工作。

如果处理数据的工作量有两个或更多基于域的操作，那么我觉得我的数据应该被形式化为某种命名的类型。

有时，这些数据必须离开一个域，进入另一个域，我认为只要外部域中的操作不试图以导致其意义改变的方式直接作用于数据，这是没问题的。

参见[https://hex docs . pm/phoenix/contexts . html # returning-ecto-structures-from-context-APIs](https://hexdocs.pm/phoenix/contexts.html#returning-ecto-structures-from-context-apis)作为对此类推理的一种解释。

如果需要读取该数据以便在外部域中派生新数据，那么这似乎是可以的，因为新数据与该外部域相关，并且可以在那里形式化为一种类型。

当一个类型需要与“额外的”数据相关联，而这些“额外的”数据被直接合并到跨多个域的复合数据类型上，并且仍然被同一个命名类型调用时，这就变得很危险了。

这是不对的。这导致了对代码中发生的事情的各种误解。如果需要进行这种类型的关联，就需要创建一种新的类型来封装这两种信息，或者需要修改原始类型。

我倾向于第一种选择，因为它防止单一类型的人成为知道太多事情的“上帝”类型。

## 模块中的内部模块别名

我喜欢在一开始就知道模块中我的依赖项是什么。别名为缩短模块中使用的名称提供了一个极好的副作用。

当我在一个特定的模块中看到许多别名时，我能认为我的模块知道太多的事情吗？这是否表明应该创建一个新的域或资源来处理这些问题的一部分？

## 仍然没有银子弹

这些原则都不是灵丹妙药。它们不会将我从现实世界中存在的糟糕的执行代码或复杂的逻辑中拯救出来，但它们确实保护我免于自己的混乱，并给我足够的原则来管理代码库多年。