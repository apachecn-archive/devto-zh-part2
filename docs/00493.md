# 类型作为命题，程序作为证明

> 原文:[https://dev . to/drbearhands/functional-fundamentals-types-as-proposes-programs-as-proof-56gh](https://dev.to/drbearhands/functional-fundamentals-types-as-propositions-programs-as-proofs-56gh)

这篇文章是“功能基础”系列文章的一部分。参见[简介和索引](https://dev.to/drbearhands/a-series-on-functional-fundamentals-48mb)。这也是你可以要求特定主题的地方

注意，我不是这些主题的权威人物，如果你看到你认为可能不正确或不完整的东西，请用评论指出来，让我们防止错误扩散:-)

* * *

Curry-Howard 的信件指出，制定一个数学证明和编写一个(类型化的、函数式的)程序基本上是一回事。这不仅仅是一个类比，这是一个*同构*，意味着他们的行为*完全*相同。

这有什么关系？对于编程来说，这意味着如果我们可以编译一个类型为`a`的程序，我们就有一个*证明*证明执行该程序会产生一个类型`a`。这里*不可能有*不是`a`的任何错误或其他结果。

也就是说，假设你的程序中没有无限递归，在这种情况下，程序永远不会终止，你也不会得到你的`a`。

现在，大部分这些我们已经从类型化 lambda 演算中得到了，它是函数式编程的基础。然而，在处理稍微高级一点的类型时，库里-霍华德对应关系是一个非常有用的思维框架。

要真正理解它的价值，你必须更深入地研究这个主题。在这篇文章中，我将探索*直觉主义、命题逻辑*和*简单类型*之间的同构。

## 逻辑速成班

如果你没有一步到位，不要担心，这是一个很大的过程。大学课程倾向于花一两周的时间在命题逻辑上。慢慢来，多读几遍。如果对你有帮助的话，用符号的含义替换符号。

* * *

如果你熟悉经典逻辑:直觉逻辑基本相同，但没有假设`⊢ p ∨ ¬p`和`¬¬p ⊢ p`。

如果你不熟悉经典逻辑:不要担心，你不应该理解其中的任何一个，这一节的其余部分是为你准备的。

有许多“类型”的逻辑。每个都有自己的一套规则。我们将处理*直觉主义逻辑*，也称为*构造逻辑*。像许多其他逻辑系统一样，它处理真理；一个*命题*可以为真也可以不为真。

本质上，它定义了真理公式的基础，就像加减乘除定义了数字公式一样。

就像算术中的数字一样，逻辑中的真值也有运算符。每个都接受真值并产生真值。让我们来看看这些运营商。我将用`⊤`表示真，用`⊥`表示假。

##### 连词

表示为`∧`的连词类似于编程中的 AND 运算符；当两个操作数都为真时，它变为真。

例如`p ∧ q`有如下真值表:

| `p` | `q` | `p ∧ q` |
| --- | --- | --- |
| 你在做什么 | 你在做什么 | 你在做什么 |
| 你在做什么 | ⊤ | 你在做什么 |
| ⊤ | 你在做什么 | 你在做什么 |
| ⊤ | ⊤ | ⊤ |

(至于如何解读真值表:这个真值表的第一行是指当`p`为假(`⊥`)`q`为假(`⊥`)时，`p ∧ q`也为假(`⊥`)。我们可以用其他公式代替`p`和`q`

##### 析取

表示为`∨`的析取类似于编程中的 OR 运算符；当任一操作数为真时，它变为真。

例如`p ∨ q`有如下真值表:

| `p` | `q` | `p ∨ q` |
| --- | --- | --- |
| 你在做什么 | 你在做什么 | 你在做什么 |
| 你在做什么 | ⊤ | ⊤ |
| ⊤ | 你在做什么 | ⊤ |
| ⊤ | ⊤ | ⊤ |

##### 寓意

暗示被表示为`→`。意思是“如果第一个操作数为真，那么第二个操作数也必须为真”。注意，这个“如果”不像编程中的条件句，后者更类似于“如果*且仅如果*”，处理控制流而不是事实。另一方面，隐含并不关心当条件为假时会发生什么。

例如`p → q`可以读作“p 隐含 q”并有如下真值表:

| `p` | `q` | `p → q` |
| --- | --- | --- |
| 你在做什么 | 你在做什么 | ⊤ |
| 你在做什么 | ⊤ | ⊤ |
| ⊤ | 你在做什么 | 你在做什么 |
| ⊤ | ⊤ | ⊤ |

如你所见，“p 暗示 q”只有在 p 为真时才为假，而 q 不是。

举个例子:如果我告诉你“如果你给我拿瓶啤酒，我就给你 10 美元”，如果你给我拿瓶啤酒，但我没有给你 10 美元，你就有权说我是骗子。另一方面，如果你不给我拿啤酒，但我还是给了你 10 美元，你不能真的说我撒谎，因为我没有具体说明如果你不给我拿啤酒会发生什么。(有趣的事实:当你把它表述为一个作弊检测问题时，人类在逻辑上要好得多)

#### 校样

到目前为止，我们已经学习了公式的基本组成部分。然而，与数字不同，我们需要计算某个公式的真值的情况并不多。相反，更有趣的是公式化证明。

我们说`A ⊢ B`(意思是:A 证明 B)可以从 A 中证明 B(在我们使用的任何证明系统中，在我们的例子中是直觉逻辑)。

我们也可以说`A ⊨ B`(读作:A 需要 B)来表示如果 A 为真，B 一定为真。

一个证明系统可以是不正确的(逻辑学家会说“不*音*”)或者不完整的，所以两者是不同的。

⊢和⊨是元语言中的运算符，这是一种奇特的说法，他们讲述了一些公式，但不是公式的一部分。就像 for 循环不能成为表达式的一部分一样(`5 + for (...) {...} / 7`)。

我们用逗号分隔多个公式:`A ⊢ B, C`表示我们可以从`A`证明`B`和`C`,`A, B ⊢ C`表示如果我们有`A`和`B`就可以证明`C`。

现在，让我们看看几个*公理*(公理是被认为是正确的东西):

任何事物都是自身的证明。嗯，呵呵。

也不奇怪，如果一个合取为真，它的两个操作数之一也必须为真

`p, p → q ⊢ q`:同样，非常清楚，如果我们知道 p 为真，并且 p 暗示 q ( `p → q`)，那么 q 也一定为真。

如果我们知道 p 意味着 r，q 意味着 r，只要 p 或 q 为真，r 也为真。

我们也有合取和析取的结合性和交换性，但是你们可能熟悉这些概念，还有一些公理我没有讲，因为它们与函数式编程不太相关。

当然，我们可以放弃任何我们已经证明的命题，如果我们不再关心它们，它们仍然是正确的，我们只是不把它们写下来。

例如，我们现在可以证明:

|                                            |  |
| --- | --- |
| `a → (b → c), a, b` |  |
| `⊢ b → c` | 我们用`p, p → q ⊢ q`证明`b → c`:用`a`代替`p`，用`b → c`代替`q` |
| `⊢ c` | 现在我们已经证明了`b → c`，我们可以使用`p, p → q ⊢ q`，用`b`代替`p`，用`c`代替`q`(记住`b`在以前仍然是正确的) |

## 返回功能编程

从上一个例子中，您可能已经开始对函数式编程有所了解。您所看到的逻辑运算符对应于函数式编程中的类型运算符。

在 Elm 语法中(≅是同构的运算符):

一个元组或记录是一个连接词
`type alias Foo = (A, B)` ≅ `Foo = A ∧ B`

枚举类型是析取
`type Foo = Left A | Right B` ≅ `Foo = A ∨ B`

一个函数一个蕴涵
`type alias Foo = A -> B` ≅ `Foo = A → B`

所以当你写一个类型为`String -> Int`的函数时，你是在证明如果你有一个`String` ( `String = ⊤`)或者`M ⊢ String → Int`，你就能得到一个`Int` ( `Int = ⊤`)。
前提(在`⊢`之前的东西)`M`由所有的函数和变量组成，这些函数和变量是本地的、导入的或者是你之前写的。编译器会检查你的证明是否正确(你没有编译错误)。

花点时间让它深入人心。

现在，想象你在前提中使用的一个公式是不正确的，你的证明变得无效！这是副作用的本质问题。如果我们有一些函数`p -> q`，这有一些副作用，即它依赖于一些我们不知道的非常数‘状态’`r`，它真正对应的是一个`p ∧ r → q`的证明(旁注:`r`可能是`p`的一个属性，但我们还没有讨论过那种逻辑，所以不要想太多)。或者，如果函数在某些情况下抛出错误，你可以说函数证明了`p → ( q ∨ Error )`，而不是`p → q`。要点是:命令式函数的类型签名不构成证明。这主要是一个效率特性，而不是正确性特性。

## 其他东西

这并不是库里-霍华德对应关系的全部，还有更高级的类型系统，对应于更高级的或者只是不同的逻辑。这是当今活跃研究的主题，例如试图证明某个并行实现是正确的。Rust 最主要的创新是线性类型，是从线性逻辑中衍生出来的。

然而，我认为这对于关于这个主题的第一篇文章来说已经足够了。

## 进一步阅读:

*   [隐含 vs 必然 vs 可证](https://math.stackexchange.com/questions/286077/implies-vs-entails-vs-provable)
*   我已经简单地提到了无限递归，以及它是如何破坏你的证明的。鉴于[暂停问题](https://en.wikipedia.org/wiki/Halting_problem)，这是不可避免的。这个问题的一个可能的解决方案是放弃图灵完备性，求助于[总函数编程](https://en.wikipedia.org/wiki/Total_functional_programming)。