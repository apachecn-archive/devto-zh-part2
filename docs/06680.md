# 在上下文中测试

> 原文:[https://dev.to/franiglesias/testing-in-context-4e2k](https://dev.to/franiglesias/testing-in-context-4e2k)

软件质量保证是一个非常广泛的学科，到目前为止，我一直在写关于单元测试的博客，这恰好是我们可以使用的级别或种类之一。

因此，在这种情况下，我想看看更一般的情况，把事情放在上下文中。

## [](#%C2%A0tests-tanonomy)测试经济

软件测试可以分为两大类:

*   功能测试
*   非功能测试

### [](#functional-tests)功能测试

功能测试指的是证明软件做了它所设计的任何事情的测试。也就是说，例如，管理二手产品销售的应用程序允许其用户购买和出售二手物品以及所有相关的任务，例如注册产品及其价格、描述和照片、与供应商和买家联系、管理支付以及所有其他任务。

这可以从不同层面得到证明:

*   **单元测试**:测试组织代码的基本单元，这些单元是独立工作的。
*   **集成测试**:尝试相关单元的集合，以证明它们的关系按预期工作。
*   **验收测试**:尝试软件的入口和输出点，以证明它们的行为是由涉众(对使用它感兴趣的人)定义的。

这三个层次合在一起形成了所谓的“测试金字塔”,我们将在后面对其进行评论。

在功能测试中，我们还考虑了以下内容:

*   **回归测试**:它们是可以检测代码中导致不希望的行为的变化的结果的测试。我们可以说所有的测试一旦通过就变成了回归测试，因为如果我们的代码干预改变了预期的行为，它们就会失败。
*   特性测试:它们是我们在软件没有其他测试时编写的测试，通常我们创建它们是为了在特定条件下运行软件并观察结果。我们使用这种测试作为安全网来分析遗留代码，这样我们就能够做出改变和更好的测试。

测试驱动开发可以在三个层次上实践。基本思想是，我们首先定义测试，然后，我们编写代码使测试通过。一旦完成，在我们去除冗余之后，这些测试就变成了回归测试。

### [](#non-functional-tests)非功能测试

非功能测试指的是软件如何工作。除了功能所做的以外，软件必须提供可靠性、性能、响应能力、低延迟等。，它是所有类型的应用程序和程序所共有的，可以用几种方法来衡量。这些测试证明了一些事情，例如:

*   **速度**:告诉我们软件返回结果是否在期望的时间内。
*   **Load** :它告诉我们软件是否能够支持一定的工作负载，可以通过多种方式来衡量，比如:同时连接数、可以同时管理的数据量等。
*   **恢复**:它告诉我们一个系统在出现故障后是否能够以正确的方式恢复。
*   容错:它告诉我们，如果一个系统发生故障，它所依赖的系统是否反应良好。

在某些情况下，(功能)验收测试可以帮助我们粗略地控制一些属于非功能测试的方面。例如，如果我们的系统不能访问另一个系统中的信息，它会如何反应。

非功能性测试旨在检查系统在一定范围内的行为，以及它对超出其范围的某些情况的正确反应。

这些测试遵循与功能测试相同的模式:

*   我们定义一个场景或已知的初始系统状态(给定)。
*   (当)我们在系统上执行一些动作。
*   我们观察系统的反应，看它是否与预期相符。

例如:我们可以决定某个特定的页面必须在不到一秒的时间内以某个特定的网络速度为用户交互做好准备(或者一个包含几个网络条件和期望响应时间的表)。所以:

*   假设某些条件，我们将系统置于已知状态。
*   我们测量页面准备好接受输入所需的时间。
*   我们检查该时间是否低于预期。

## [](#the-functional-tests-pyramid)(功能)测试金字塔

功能测试金字塔是一个决定我们在每一层执行的测试数量的启发式方法。

这个想法是:

*   单元测试:它们在金字塔的底层，我们应该有很多。
*   集成测试:他们在金字塔的中间，我们应该少一些。
*   验收测试:他们在金字塔的顶端，所以我们应该只有几个。

换句话说:

给定我们软件的一个特性，我们应该:

*   一些验收测试，涵盖了涉众定义的场景。
*   更大数量的集成测试，确保系统组件按预期交互工作，并确保它们知道如何在其他组件出现故障时做出反应。
*   大量的单元测试证明软件单元做了它们应该做的事情，并且它们能够管理不同的输入条件，在无效输入面前以正确的方式做出反应。

但是…，为什么？

### [](#lots-of-unit-tests)大量单元测试

一个单元测试，集中在一个单一的，孤立的软件单元，应该是:

*   易于编写:一个软件单元应该管理相对较少的用例，并以简单的方式对问题做出反应，比如抛出异常。
*   快速:在有依赖关系的情况下，它们应该加倍(为了测试的目的)使用更简单和成本更低的对象，允许快速执行测试。
*   可复制的:如果软件单元行为没有改变，我们可以根据需要重复测试，得到相同的结果。

这种条件允许我们做如下事情:

*   每当我们在软件中引入一个变化时运行测试，在任何行为改变的情况下为我们提供即时的反馈。
*   假设每一个测试都是在一个特定的场景中测试一个独特的具体的软件，如果测试失败了，我们可以立即得到问题的诊断以及问题发生在哪里。

由于这个原因，逻辑上的事情就是拥有许多可以在一天中快速执行多次的单元测试:当我们想要修复一个 bug 时，当我们引入一个变更时，当我们提交时，当我们部署时，等等。

越多越好？正如生活中的其他事情一样，越多并不总是越好，但是我们感兴趣的是，我们应用于软件单元的所有测试都覆盖了所有相关的用例，因此当其中一个用例失败时，我们可以知道我们所做的改变到底是什么导致了问题。

在单元测试中，来自参与的其他软件单元的行为用测试加倍来模拟，这将它们自己限制为返回预编程的响应，因此被测试的软件单元的输出只能归因于它自己的行为，保持合作者的行为在控制之下。

### [](#moderate-quantity-of-integration-tests)中等数量的集成测试

集成测试使用与给定过程相关的几个软件单元，与应用程序的其余部分隔离开来。

在这种情况下，我们不会用 doubles 模拟任何行为，因为我们的目标是检查这些单元是否以预期的方式交互。我们可能不得不模仿外部系统的行为(例如，为我们提供数据的 API)。当然，我们使用为测试环境精心制作的数据。

用例数量随着行为单元的数量成几何级数增长。

问题是除了案例数量的增长，集成测试比单元测试要慢，所以我们必须采取不同的方法。

集成测试不需要验证每个软件单元都执行了它的工作，我们只是用我们的单元测试验证了这一点。它将证明作为一个整体工作的软件单元的行为，特别是任何一个单元由于这样或那样的原因而失败的情况，因此我们可以确保其他单元能够管理这种情况。

### [](#only-a-few-acceptance-tests)只有几项验收测试

验收测试从用户或利益相关者的角度检查系统，因此，他们测试所有运行中的系统组件。在验收测试中，我们不模拟任何系统组件，除非我们需要与外部系统通信，或者我们需要模拟一些基础设施条件，假装它们。

我们的验收测试应该在特定的环境中运行，与生产环境相同。

一般来说，通过验收测试，我们感兴趣的是证明一些对涉众来说很重要的场景。例如:

*   一个用户想要注册一个服务，她提供了所有需要的数据，因此她应该收到一个确认，表明她已经有效地注册了该服务。
*   一个用户想要注册一项服务，但是他没有提供所需的数据或者这些数据是无效的，因此他应该收到显示要纠正哪些数据以及该过程已经中止的信息。
*   想要注册服务的用户应该接收到足够的信息，以防系统故障阻止该过程完成。

大多数验收测试都可以按照以下模型进行:

*   正确的用户输入+正确的系统->正确的系统输出，有效地完成流程
*   用户的无效输入+正确的系统->系统的信息输出
*   用户的正确输入+失败的系统->系统的信息输出

显然，许多过程都有各种各样的场景需要考虑，这增加了所需的测试。然而，它们的数量将会少于单元测试所覆盖的所有用例及条件组合，这些单元测试将相同的软件单元作为一个整体。

验收测试可以用 Gherkin 语言编写，这是一种使用自然语言定义场景特性的结构化方法。这样，利益相关者或产品所有者可以与开发人员一起定义他们。之后，它们被翻译成一种编程语言，使用的工具有 JBehave、Cucumber 或 Behat。

## [](#usefulness-of-the-test-pyramid)测试金字塔的用处

测试金字塔的第一个用途是帮助我们定义在每一层中需要多少测试。反正只是一个启发，因为三个水平之间的比例也很重要，但选择正确的一个并不容易。

当我们想要分析应用程序的行为时，测试金字塔给了我们三个分辨率级别。

*   接受水平允许我们从整体上观察申请的过程。
*   集成级别允许我们观察软件子集的过程，并且在这些测试中的失败指向单元之间的不良通信。
*   单元级别允许我们观察软件单元，在这个级别的失败允许我们诊断我们的算法。

理想情况下，有了很大比例的测试，我们会发现在验收级别失败的测试会反映在其他级别失败的测试中。

*   在集成级测试失败，而不是在单元级测试失败，将表明一些软件单元不能正常通信，例如，因为它们以无效的格式共享信息。
*   单元级的失败测试将在集成中反映出来，它们表明一些软件单元工作不良。

有时没有失败更能说明问题:

*   没有在其他层中反映出来的验收测试失败告诉我们，我们在那些层中缺少测试。相应地，我们应该编写新的测试来确保我们在集成和单元级别覆盖了那个功能。
*   其他层中没有反映出来的失败的单元测试告诉我们，我们没有对它们进行测试。单元测试失败应该反映在集成和验收失败中。

另一方面，测试金字塔帮助我们控制测试的执行，使其保持在一个实用的水平

*   验收测试非常慢。如果我们的资源相对较少(当然，前提是足够多)，我们将在尽可能短的时间内运行它们，并且我们将能够在每次部署之前自动启动它们。如果我们需要大量的验收测试，我们应该将它们作为一个独立的周期性任务来运行。
*   集成测试相当快，如果我们将它们保持在适当的水平，我们可以在每个拉取请求和部署中自动执行它们。
*   单元测试非常快，所以我们可以在每次提交时执行它们。

为了使这种结构真正有效，我们必须确保一个层面的失败会反映到其他两个层面。

显然，我们可以使用工具来优化测试的执行，这些工具可以帮助我们只执行那些受最新变更影响的测试。

## [](#smells-in-the-pyramid-of-functional-tests)功能测试金字塔中的气味

观察三个水平中测试之间的比例，我们可以诊断我们的测试组是否比例恰当。如果不是这样，目标应该是在需要的级别上增加测试的数量，以及审查那些可能有冗余测试的级别。

一般来说，相对于单元的验收水平的过多测试允许我们检测故障，但是不能准确地诊断它们。

另一方面，太多的单元测试和很少的验收测试可能会忽略许多将在生产中暴露的错误。

### [](#inverted-pyramid)倒金字塔形

倒金字塔表示单元测试很少，验收测试很多。

许多验收测试可能表明测试了不必要的场景，或者试图从外部验证系统的特定单元的操作，试图为验收测试提供单元测试的需要。

当更高级别的测试失败时，很少的单元测试使得很难或者不可能容易地确定问题在哪里。

### [](#crushed-pyramid)碾碎的金字塔

破碎的金字塔表明单元测试的验收测试太少。如果我们假设单元测试的覆盖率是足够的，这种气味告诉我们的是，我们必须进行更多的集成和验收测试。

在这种情况下，测试不能告诉我们应用程序作为一个整体是如何运行的，我们可能过于依赖手动测试，不太可信，也不太准确。因此，我们将无法识别与不同软件单元之间的不良通信相关的问题案例。

### [](#shape-of-diabolo)空竹的形状

这将表明我们只有很少的集成测试，验收测试正在做他们的工作。我们将不得不在集成层面上分析验收测试和移动测试。

在验收级别失败的情况下，我们会发现，如果单元测试没有失败，我们就无法知道我们单元的什么交互出现了故障。

### [](#diamond-shape)菱形

菱形告诉我们集成测试正在做单元测试的工作。这一级别的失败不能说明它是由于集成问题还是特定软件单元中的问题。

解决方案是创建更多的单元测试，帮助我们更好地辨别。

### [](#square-shape)方形

如果不是金字塔，我们有一个类似正方形或长方形的形状，我们在每一层都有相似数量的测试。这表明，要么我们有很少的单元测试，要么我们有太多的集成和验收测试，这些测试可能在做较低层次的工作。