# æ‰€ä»¥ä½ æœ‰ä¸€å †äº‹æƒ…è¦åšã€‚ä¸ºä»€ä¹ˆä¸å»ºä¸€æ¡ç®¡é“ï¼Ÿ

> åŸæ–‡:[https://dev . to/krofdrakula/so-you-have-bunch-of-things-to-do-why-not-build-a-pipeline-3100](https://dev.to/krofdrakula/so-you-have-a-bunch-of-things-to-do-why-not-build-a-pipeline-31o0)

å¼€å‘è½¯ä»¶æ—¶ï¼Œç¼–å†™å¯è¯»æ€§å¥½çš„ä»£ç æ˜¯ä¸ªå¥½ä¸»æ„ã€‚è€Œä¸”ï¼Œåƒä»»ä½•ä¸€ä¸ªå¥½çš„è®²æ•…äº‹çš„äººä¸€æ ·ï¼Œä½ æƒ³è¦çœç•¥ä¸é‡è¦çš„ç»†èŠ‚ã€‚æ‚¨è¿˜å¸Œæœ›ç•™ä¸‹é¢åŒ…å±‘ï¼Œä»¥ä¾¿è¯»è€…åœ¨éœ€è¦æ—¶äº†è§£ç»†èŠ‚ã€‚

åä¸‹æ¥ï¼Œå–ä¸€æ¯çƒ­é¥®ï¼Œè®©æˆ‘ä»¬ç›´æ¥è¿›å…¥æ­£é¢˜ã€‚

[![](../Images/30bae69daea509e3f0d4331879959df5.png)T2ã€‘](https://i.giphy.com/media/Lp4L5KOAHjCpUidRuq/giphy.gif)

## [](#the-elements-of-a-good-story)ä¸€ä¸ªå¥½æ•…äº‹çš„è¦ç´ 

æ•…äº‹ã€ç¨‹åºã€æµç¨‹ã€å‡½æ•°ã€ç®—æ³•æœ‰ä»€ä¹ˆå…±åŒç‚¹ï¼Ÿ

å®ƒä»¬éƒ½æœ‰å¼€å§‹ã€ä¸­é—´å’Œç»“æŸã€‚

å½“æˆ‘ä»¬æè¿°è¿‡ç¨‹æ—¶ï¼Œæˆ‘ä»¬ä»æè¿°æˆ‘ä»¬éœ€è¦æ‰§è¡Œçš„å…ˆå†³æ¡ä»¶å’Œææ–™å¼€å§‹ï¼Œè¿‡ç¨‹çš„*è¾“å…¥*ã€‚æˆ‘ä»¬æè¿°äº†æ‰§è¡Œè¯¥è¿‡ç¨‹æ‰€éœ€çš„æ­¥éª¤ã€‚å½“ä¸€åˆ‡éƒ½ç»“æŸæ—¶ï¼Œæè¿°è¿˜åŒ…æ‹¬é¢„æœŸçš„ç»“æœï¼Œå³*è¾“å‡º*ã€‚

å¦‚æœæ‚¨è®¤ä¸ºè¿™å¬èµ·æ¥éå¸¸åƒä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œé‚£ä¹ˆæ‚¨ç»å¯¹æ˜¯æ­£ç¡®çš„ã€‚ä½†æ˜¯ï¼Œå¦‚æœæ‚¨ä¸ç†è§£è¿™ç§æ¨è®ºï¼Œä¸è¦æ‹…å¿ƒï¼Œé€šè¿‡è¿™ç¯‡æ–‡ç« ï¼Œæ‚¨å°†ç†Ÿæ‚‰è¿™ä¸ªæ¦‚å¿µã€‚ğŸ˜

## [](#defining-inputs)å®šä¹‰è¾“å…¥

[![](../Images/3112b31eb460fecbfa628281ed2cea58.png)T2ã€‘](https://i.giphy.com/media/3ornjKd18tFIZ8PUKQ/giphy.gif)

è®©æˆ‘ä»¬ç©¿ä¸Šæˆ‘ä»¬çš„è§’è‰²æ‰®æ¼”æœè£…ã€‚æ‚¨åœ¨è¿™ä¸ªæ•…äº‹ä¸­çš„è§’è‰²å°†æ˜¯ä¸€ä¸ªåˆ†æå¸ˆï¼Œå…¶ä»»åŠ¡æ˜¯æäº¤å…³äºé€‰å®šå­æ•°æ®é›†çš„æŠ¥å‘Šã€‚æ‚¨å°†è·å¾—ä¸€ä¸ªå­ç¼–è¾‘åˆ—è¡¨ï¼Œä»¥ä¾¿æ ¹æ®é¡µé¢ç”Ÿæˆå‡ ç§ç±»å‹çš„æŠ¥å‘Šã€‚

ä½ çš„ä»»åŠ¡æ˜¯ä¸ºæ¯ä¸ªç»™å®šçš„å­ç¼–è¾‘é¦–é¡µç”Ÿæˆä¸€äº›æŠ¥å‘Š:

1.  æ¯ç¯‡æ–‡ç« å­—æ•°çš„ä¸­ä½æ•°
2.  æ¯ä¸ªå¸–å­çš„è¯„è®ºæ•°é‡çš„ä¸­ä½æ•°
3.  é™„æœ‰å›¾ç‰‡çš„å¸–å­ä¸æ‰€æœ‰å¸–å­çš„æ¯”ç‡

è‡³äº URLï¼Œæ‚¨å¯ä»¥é€‰æ‹©ï¼Œä½†æ˜¯åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨`/r/dataisbeautiful`:

[https://www.reddit.com/r/dataisbeautiful/](https://www.reddit.com/r/dataisbeautiful/)

çœ‹å®Œä¹‹åï¼Œå°è¯•ä¸€ä¸‹ JSON URLï¼Œè¿™æ ·æ‚¨å°±ä¼šå¯¹æ•°æ®çš„ç»“æ„æœ‰æ‰€äº†è§£:

`const fetch = require('node-fetch');` `const url = 'https://www.reddit.com/r/dataisbeautiful.json'; fetch(url) .then(response => response.json()) .then(json => console.log(json));`

## [](#defining-steps)å®šä¹‰æ­¥éª¤

[![](../Images/ff4c4de1278c9e66e566955adcfa9be9.png)T2ã€‘](https://i.giphy.com/media/xThta8UkUaoqJoJQC4/giphy.gif)

æ‰€ä»¥é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æŠŠé—®é¢˜åˆ†è§£æˆæ˜ç¡®çš„æ­¥éª¤ã€‚ç²’åº¦è¶Šç»†ï¼Œå°±è¶Šå®¹æ˜“ç†è§£ã€è°ƒè¯•å’Œé‡ç”¨ã€‚æ¸¸æˆè§„åˆ™æ˜¯**åšä¸€ä»¶äº‹ï¼Œå¹¶ä¸”åšå¥½**ã€‚

æˆ‘ä»¬å…ˆæ‹¿ç¬¬ä¸€ä»½æŠ¥å‘Šï¼ŒæŠŠæ­¥éª¤å†™ä¸‹æ¥ã€‚ç²’åº¦è¶Šç»†è¶Šå¥½ã€‚

1.  ç”Ÿæˆ URL
2.  è·å– JSON æ•°æ®
3.  æå–å¸–å­
4.  æå–æ¯ç¯‡æ–‡ç« çš„æ–‡æœ¬å’Œæ ‡é¢˜
5.  ä¸ºæ¯ä¸ªæ–‡æœ¬ç”Ÿæˆå­—æ•°ç»Ÿè®¡
6.  è®¡ç®—æ‰€æœ‰æ–‡æœ¬çš„ä¸­å€¼

ç†æƒ³æƒ…å†µä¸‹ï¼Œæ‚¨åº”è¯¥å¯¹æ¯ä¸€æ­¥éƒ½è¿›è¡Œæµ‹è¯•ã€‚ä¸ºäº†ç®€æ´èµ·è§ï¼Œæˆ‘çœç•¥äº†æœ¬æ–‡ä¸­çš„æµ‹è¯•ï¼Œä½†æ˜¯å¦‚æœæˆ‘åœ¨ä»£ç å®¡æŸ¥ä¸­å®¡æŸ¥æ‚¨çš„ä»£ç ï¼Œè¿™è‚¯å®šè¡Œä¸é€šï¼

### [](#step-1-generate-url)ç¬¬ä¸€æ­¥:ç”Ÿæˆç½‘å€

è¿™ä¸ªå¾ˆç®€å•:è·å–ä¸€ä¸ª Reddit URLï¼Œåˆ é™¤å°¾éƒ¨çš„æ–œæ (å¦‚æœæœ‰çš„è¯)å¹¶è¿½åŠ `.json`å­—ç¬¦ä¸²ã€‚

```
const getRedditJSONUrl = url => url.replace(/\/?$/, '.json'); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

### [](#step-2-fetch-json-data)ç¬¬äºŒæ­¥:å– JSON æ•°æ®

ç”¨`fetch`è¿›è¡Œç®€å•çš„è°ƒç”¨å¹¶å°†å“åº”è½¬æ¢æˆ JSON å°±å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ã€‚

```
const fetchData = url => fetch(url).then(response => response.json()); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

### [](#step-3-extract-posts)ç¬¬ä¸‰æ­¥:æå–å¸–å­

æˆ‘ä»¬çŸ¥é“æ¯ä¸ªé¡µé¢éƒ½åŒ…å«äº†`data.children`å±æ€§ï¼Œå®ƒä¿å­˜äº†æˆ‘ä»¬æ„Ÿå…´è¶£çš„æ–‡ç« çš„æ•°ç»„ã€‚

```
const extractPosts = redditPage => redditPage.data.children; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

### [](#step-4-extract-post-text-for-each-post)ç¬¬å››æ­¥:æå–æ¯ä¸ªå¸–å­çš„å¸–å­æ–‡æœ¬

æ¯ä¸ªå¸–å­çš„æ ‡é¢˜å¯ä»¥åœ¨`data.title`å±æ€§ä¸­æ‰¾åˆ°ï¼Œæ–‡æœ¬åœ¨`data.selftext`ä¸­æ‰¾åˆ°ã€‚æˆ‘ä»¬å°†ä½¿ç”¨æ¢è¡Œç¬¦`\n`å°†å®ƒä»¬è¿æ¥èµ·æ¥ã€‚

```
const extractPostTextAndTitle = post => post.data.title + '\n' + post.data.selftext; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

### [](#step-5-generate-word-count-for-each-text)ç¬¬äº”æ­¥:ç”Ÿæˆæ¯ç¯‡æ–‡ç« çš„å­—æ•°

è¿™ä¸ªæœ‰ç‚¹æ£˜æ‰‹ã€‚æ²¡æœ‰å¿«é€Ÿå¯é åœ°ç»Ÿè®¡å­—æ•°çš„æ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ä½¿ç”¨æ¥è‡ª NPM çš„æ›´å¤æ‚çš„æ•ˆç”¨å‡½æ•°ï¼Œ [`@iarna/word-count`](https://www.npmjs.com/package/@iarna/word-count) ã€‚

æ³¨æ„ï¼Œæˆ‘ä»¬ä»ç„¶åœ¨åˆ›å»ºä¸€ä¸ªåŒ…è£…åº“å‡½æ•°çš„å‡½æ•°ã€‚è¿™æ˜¯ä¸ºäº†åœ¨æˆ‘ä»¬éœ€è¦æ”¹å˜å®ç°çš„æƒ…å†µä¸‹ï¼Œæˆ–è€…å¦‚æœå‡½æ•°è°ƒç”¨ç”±äºæˆ‘ä»¬è¿™è¾¹çš„ä»£ç é‡æ„è€Œæ”¹å˜ï¼Œå°†æˆ‘ä»¬ä¸åº“éš”ç¦»å¼€æ¥ã€‚

```
const _wordCount = require('@iarna/word-count');

const countWords = text => _wordCount(text); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

### [](#step-6-calculate-the-median)ç¬¬å…­æ­¥:è®¡ç®—ä¸­ä½æ•°

ä¸ºäº†è®¡ç®—ä¸€ç»„æ•°å­—çš„ä¸­å€¼ï¼Œæˆ‘ä»¬å°†å®ƒä»¬ä»æœ€å°åˆ°æœ€å¤§æ’åºã€‚ä¸­ä½æ•°æ˜¯å°†æœ‰åºé›†åˆ†æˆç›¸ç­‰ä¸¤åŠçš„å€¼ã€‚å¯¹äºå…·æœ‰å¥‡æ•°ä¸ªå€¼çš„é›†åˆï¼Œå®ƒå°†æ˜¯ä¸­é—´å€¼ã€‚å¯¹äºå‡åŒ€è®¡æ•°çš„é›†åˆï¼Œå®ƒå°†æ˜¯ä¸­é—´ä¸¤ä¸ªå€¼çš„ä¸­ç‚¹ã€‚

è¿™æ˜¯ä¸€ç»„å¥‡æ•°å’Œå¶æ•°çš„ä¸­é—´å€¼:

```
[1 1 2 3 5 8 13] ~ size = 7
       ^ median = 3

[1 1 2 3 5 8 13 21] ~ size = 8
        ^ median = (3+5)/2 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

ä¸‹é¢æ˜¯å®ç°:

```
const numberValueSorter = (a, b) => a - b;

const calculateMedian = list => {
  // an empty list has no median
  if (list.length == 0) return undefined;

  // sort the values
  const sorted = Array.from(list).sort(numberValueSorter);

  if (sorted.length % 2 == 0) {
    // we're dealing with an even-sized set, so take the midpoint
    // of the middle two values
    const a = sorted.length / 2 - 1;
    const b = a + 1;
    return (list[a] + list[b]) / 2;
  } else {
    // pick the middle value
    const i = Math.floor(sorted.length / 2);
    return list[i];
  }
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

## [](#connecting-the-steps)è¿æ¥æ­¥éª¤

[![](../Images/61f1c869ad179dd30970b893432c1667.png)T2ã€‘](https://i.giphy.com/media/gZqDdFC62X6KY/giphy.gif)

ç°åœ¨æˆ‘ä»¬å·²ç»æœ‰äº†é€‚å½“çš„æ­¥éª¤ï¼Œè®©æˆ‘ä»¬ä»¥ç»å…¸çš„å‘½ä»¤å¼é£æ ¼å†™å‡ºä»£ç ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½æ›´å¥½åœ°ç†è§£è¿™ä¸ªè¿‡ç¨‹æ˜¯ä»€ä¹ˆæ ·å­çš„ã€‚

`const fetch = require('node-fetch'); const _wordCount = require('@iarna/word-count'); const getRedditJSONUrl = url => url.replace(/\/?$/, '.json'); const fetchData = url => fetch(url).then(response => response.json()); const extractPosts = redditPage => redditPage.data.children; const extractPostTextAndTitle = post => post.data.title + '\n' + post.data.selftext; const countWords = text => _wordCount(text); const numberValueSorter = (a, b) => a - b; const calculateMedian = list => { if (list.length == 0) return undefined; const sorted = Array.from(list).sort(numberValueSorter); if (sorted.length % 2 == 0) { const a = sorted.length / 2 - 1; const b = a + 1; return (list[a] + list[b]) / 2; } else { const i = Math.floor(sorted.length / 2); return list[i]; } }` `const URL = 'https://www.reddit.com/r/dataisbeautiful/'; // because some of the steps require resolving Promises, we'll // use an async function so we can await the result (async () => { // step 1 const jsonURL = getRedditJSONUrl(URL); // step 2 â€“ needs awaiting const pageData = await fetchData(jsonURL); // step 3 const posts = extractPosts(pageData); // step 4 â€“ we need to map over the elements of the array const texts = posts.map(extractPostTextAndTitle); // step 5 - same here const wordCounts = texts.map(countWords); // step 6 const median = calculateMedian(wordCounts); console.log('Median word count for ' + URL, median); })();`

å°±è®²æ•…äº‹è€Œè¨€ï¼Œå¿ƒæµä¼¼ä¹æ— å¤„ä¸åœ¨ã€‚æˆ‘ä»¬ä¸æ˜¯ç®€å•åœ°åˆ—å‡ºæ­¥éª¤ï¼Œè€Œæ˜¯ä¾æ¬¡è°ƒç”¨æ¯ä¸ªæ­¥éª¤ï¼Œä¿å­˜ä¸­é—´ç»“æœå¹¶å°†ç»“æœäº¤ç»™ä¸‹ä¸€æ­¥ã€‚

åœ¨è¿™ä¸ªæ•…äº‹ä¸­ä¹Ÿæœ‰å‡ ä¸ªé™·é˜±ï¼›æœ‰äº›è¦æ±‚`await` ing ç»“æœï¼Œæœ‰äº›è¦æ±‚ç”¨`map`åŒ…è£…è°ƒç”¨æ¥å¤„ç†æ¯ä¸€é¡¹ã€‚

å¦‚æœæˆ‘ä»¬èƒ½æŠŠè¿™äº›æ­¥éª¤è¿æ¥èµ·æ¥ï¼Œç„¶åæŠŠç»“æœä¼ é€’ä¸‹å»ï¼Œä¼šæ€ä¹ˆæ ·å‘¢ï¼Ÿä»–çœ¼ç›é—ªé—ªå‘å…‰åœ°é—®é“ã€‚

[![](../Images/dc2e6fc46d40a940be2efa9e6366a353.png)T2ã€‘](https://i.giphy.com/media/13vPE0A3DPqOcg/giphy.gif)

## [](#enter-the-pipeline)è¾“å…¥ç®¡é“

è¿™é‡Œæˆ‘ä»¬éœ€è¦å¼•å…¥ä¸€ä¸ªæ–°æ¦‚å¿µâ€”â€”`pipeline`å‡½æ•°ã€‚è®©æˆ‘ä»¬ä»åˆ†ææˆ‘ä»¬çš„åŸå§‹æµç¨‹å¼€å§‹ï¼Œè¯¥æµç¨‹è·å–ä¸€ä¸ª subreddit URL å¹¶ä¸ºé¡µé¢ç”Ÿæˆä¸€ä¸ªä¸­å€¼å­—æ•°:

```
const getMedianWordCountReport = async subredditUrl => {
  /* something something spaceship */
  return 'voilÃ¡!';
}; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

æˆ‘ä»¬è¯´è¿‡æˆ‘ä»¬çš„æµç¨‹æ˜¯ç”±ä¸Šè¿°å…­ä¸ªæ­¥éª¤å®šä¹‰çš„ã€‚è®©æˆ‘ä»¬å‡è®¾`pipeline`å­˜åœ¨ï¼Œå¹¶ç¼–å†™è®©æˆ‘ä»¬ä»ä¸€ç³»åˆ—æ­¥éª¤ä¸­åˆ›å»ºæµç¨‹å‡½æ•°çš„ä»£ç :

```
const getMedianWordCountReport = pipeline(
  getRedditJSONUrl,
  fetchData,
  extractPosts,
  map(extractPostTextAndTitle),
  map(countWords),
  calculateMedian
);

const URL = 'https://www.reddit.com/r/dataisbeautiful/';

// it's an async function, so we need to wait for it to resolve
getMedianWordCountReport(URL)
  .then(median =>
    console.log('Median word count for ' + URL, median)
  )
  .catch(error => console.error(error)); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

å•Šï¼Œä½†æ˜¯é‚£é‡Œçš„é‚£ä¸ª`map()`å‡½æ•°å‘¢ï¼Ÿåªæ˜¯æ”¹å˜äº†`Array::map`å‡½æ•°ï¼Œä»¥ä¾¿åœ¨æ¥å—æ•°ç»„ä¹‹å‰ä½¿ç”¨æ˜ å°„å‡½æ•°:

```
const map = mapper => array => array.map(mapper); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œä¸€åˆ‡é¡ºåˆ©ã€‚æˆ‘ä»¬ç°åœ¨çŸ¥é“äº†å‡½æ•°*åº”è¯¥*åšä»€ä¹ˆï¼Œæˆ‘ä»¬åªéœ€è¦å®šä¹‰å®ƒã€‚å…ˆæ¥å®šä¹‰ä¸€ä¸‹å®ƒçš„ç­¾å:

```
const pipeline = (...steps) => {  // take a list of steps,
  return async input => {         // return an async function that takes an input,
    return input;                 // and eventually returns a result
  };
}; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

æˆ‘ä»¬å·²ç»åˆ›å»ºäº†ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—ä»»æ„æ•°é‡çš„å‡½æ•°(`steps`)å¹¶è¿”å›ä¸€ä¸ª`async function`ï¼Œå³æµç¨‹å‡½æ•°ã€‚

å¯¹äºæ¯ä¸€æ­¥ï¼Œè¯¥å‡½æ•°åº”è¯¥è·å–æœ€åä¸€ä¸ªä¸­é—´ç»“æœï¼Œå°†å…¶æä¾›ç»™ä¸‹ä¸€æ­¥ï¼Œå¹¶ä¿å­˜è¯¥ä¸­é—´ç»“æœã€‚

å¦‚æœæ²¡æœ‰æ›´å¤šçš„æ­¥éª¤ï¼Œè¿”å›æœ€åä¸€ä¸ªä¸­é—´ç»“æœã€‚

å‡†å¤‡å¥½äº†å—ï¼Ÿèµ°å§ã€‚

```
const pipeline = (...steps) => {    // take a list of steps defining the process
  return async input => {           // and return an async function that takes input;
    let result = input;             // the first intermediate result is the input;
    for (const step of steps)       // iterate over each step;
      result = await step(result);  // run the step on the result and update it;
    return result;                  // return the last result!
  };
}; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

ä½ å¯èƒ½ä¼šæƒ³ï¼Œ*â€œä¸ï¼Œé‚£ä¸å¯èƒ½ã€‚çœŸçš„å°±è¿™äº›å—ï¼Ÿâ€*

æ²¡é”™ã€‚è‡ªå·±è¯•è¯•:

`const fetch = require('node-fetch'); const _wordCount = require('@iarna/word-count'); const getRedditJSONUrl = url => url.replace(/\/?$/, '.json'); const fetchData = url => fetch(url).then(response => response.json()); const extractPosts = redditPage => redditPage.data.children; const extractPostTextAndTitle = post => post.data.title + '\n' + post.data.selftext; const countWords = text => _wordCount(text); const numberValueSorter = (a, b) => a - b; const calculateMedian = list => { if (list.length == 0) return undefined; const sorted = Array.from(list).sort(numberValueSorter); if (sorted.length % 2 == 0) { const a = sorted.length / 2 - 1; const b = a + 1; return (list[a] + list[b]) / 2; } else { const i = Math.floor(sorted.length / 2); return list[i]; } }` `const map = mapper => array => array.map(mapper); const pipeline = (...steps) => { return async input => { let result = input; for (const step of steps) result = await step(result); return result; }; }; const getMedianWordCount = pipeline( getRedditJSONUrl, fetchData, extractPosts, map(extractPostTextAndTitle), map(countWords), calculateMedian ); const URL = 'https://www.reddit.com/r/dataisbeautiful/'; getMedianWordCount(URL) .then(median => console.log('Median word count', median));`

[![](../Images/814c8ad212026953149acc5873abe5fb.png)T2ã€‘](https://i.giphy.com/media/vA4EnqvJxDv2g/giphy.gif)

## [](#streamlining-the-pipeline)ç²¾ç®€æµæ°´çº¿

æˆ‘ä»¬åœ¨ç®¡é“ä¸Šæœ‰å‡ ä¸ªå¼¯ï¼Œæˆ‘ä»¬æƒ³æŠŠå®ƒä»¬å¼„ç›´ã€‚åœ¨æŸä¸€ç‚¹ä¸Šï¼Œç»“æœä»å•ä¸ªå€¼å˜ä¸ºä¸€ä¸ªå€¼åˆ—è¡¨(`extractPosts`)ï¼Œç„¶åå†å˜å›(`calculateMedian`)ã€‚å¦‚æœæˆ‘ä»¬èƒ½æŠŠå¿…é¡»å¤„ç†å•ä¸ªé¡¹ç›®çš„å‡½æ•°ç»„åˆåœ¨ä¸€èµ·ï¼Œé‚£å°±æ›´å¥½äº†ã€‚

ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå¤åˆå‡½æ•°ï¼Œè¯¥å‡½æ•°å°†é‡‡å–è®¸å¤šæ­¥éª¤æ¥å¤„ç†å•ä¸ªå€¼ï¼Œå¹¶å°†å®ƒä»¬ä¸²åœ¨ä¸€èµ·ä»¥å¯¹å€¼åˆ—è¡¨è¿›è¡Œæ“ä½œ:

```
const map = (...mappers) =>                 // take an array of mappers,
  array =>                                  // and return a function that takes an array;
    array.map(                              // map each item of the array
      item => mappers.reduce(               // through a function that passes each item
        (result, mapper) => mapper(result)  // and runs them through the chain of mappers
      )
    ); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

ç°åœ¨ï¼Œè¿™ä¸ªå‡½æ•°æœ‰ä¸€ä¸ªè­¦å‘Š:ä¼ é€’ç»™è¿™ä¸ª`map`å‡½æ•°çš„æ˜ å°„å‡½æ•°å¿…é¡»æ˜¯åŒæ­¥çš„ã€‚ä¸ºäº†å®Œæ•´èµ·è§ï¼Œè®©æˆ‘ä»¬å‡è®¾æ¯ä¸ªæ˜ å°„å™¨å¯èƒ½æ˜¯ä¸€ä¸ª`async`å‡½æ•°ï¼Œå¹¶ä¸”åº”è¯¥è¢«ç›¸åº”åœ°å¯¹å¾…ã€‚

```
const map = (...mappers) =>
  async array => {                      // we now have to return an async function
    const results = [];
    for (const value of array) {        // for each value of the array,
      let result = value;               // set the first intermediate result to the first value;
      for (const mapper of mappers)     // take each mapper;
        result = await mapper(result);  // and pass the intermediate result to the next;
      results.push(result);             // and push the result onto the results array;
    }
    return results;                     // return the final array
  }; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

æ—¢ç„¶æˆ‘ä»¬å·²ç»è§£å†³äº†è¾¹ç¼˜æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å°†ä¸¤ä¸ªå•é¡¹åŠŸèƒ½ç»„åˆæˆä¸€ä¸ªæ­¥éª¤æ¥é‡æ–°åˆ¶å®šæˆ‘ä»¬çš„æµç¨‹åŠŸèƒ½:

`const fetch = require('node-fetch'); const _wordCount = require('@iarna/word-count'); const getRedditJSONUrl = url => url.replace(/\/?$/, '.json'); const fetchData = url => fetch(url).then(response => response.json()); const extractPosts = redditPage => redditPage.data.children; const extractPostTextAndTitle = post => post.data.title + '\n' + post.data.selftext; const countWords = text => _wordCount(text); const numberValueSorter = (a, b) => a - b; const calculateMedian = list => { if (list.length == 0) return undefined; const sorted = Array.from(list).sort(numberValueSorter); if (sorted.length % 2 == 0) { const a = sorted.length / 2 - 1; const b = a + 1; return (list[a] + list[b]) / 2; } else { const i = Math.floor(sorted.length / 2); return list[i]; } } const pipeline = (...steps) => { return async input => { let result = input; for (const step of steps) result = await step(result); return result; }; };` `const map = (...mappers) => async array => { const results = []; for (const value of array) { let result = value; for (const mapper of mappers) result = await mapper(result); results.push(result); } return results; }; const getMedianWordCount = pipeline( getRedditJSONUrl, fetchData, extractPosts, map( extractPostTextAndTitle, countWords ), calculateMedian ); const URL = 'https://www.reddit.com/r/dataisbeautiful/'; getMedianWordCount(URL) .then(median => console.log('Median word count', median));`

è€Œä¸”è¿˜èƒ½ç”¨ï¼

[![](../Images/feda77c6a0fda1b37152427ce4709993.png)T2ã€‘](https://i.giphy.com/media/1xpTgPBebfe8lhj4yE/giphy.gif)

## [](#forking-pipelines)åˆ†å‰ç®¡é“

æ‰€ä»¥ç°åœ¨æˆ‘ä»¬æœ‰äº†ä¸€ä¸ª`pipeline`å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥å£°æ˜æ€§åœ°æ„é€ ä¸€ä¸ªæè¿°æˆ‘ä»¬æµç¨‹çš„å‡½æ•°ã€‚ä½†åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªå®Œæˆäº†è§’è‰²æ‰®æ¼”åœºæ™¯ä¸­ä¸‰ä¸ªæœ€åˆç›®æ ‡ä¸­çš„*ä¸€ä¸ª*ã€‚

å“¦ï¼Œä¸ï¼

è®©æˆ‘ä»¬å†™ä¸‹æ‰€æœ‰çš„è¿‡ç¨‹ï¼Œä»¥è¯„ä¼°æˆ‘ä»¬è¿˜éœ€è¦åšä»€ä¹ˆã€‚

```
const getMedianWordCount = pipeline(
  getRedditJSONUrl,
  fetchData,
  extractPosts,
  map(
    extractPostTextAndTitle,
    countWords
  ),
  calculateMedian
);

const getMedianCommentCount = pipeline(
  getRedditJSONUrl,
  fetchData,
  extractPosts,
  map(countComments),
  calculateMedian
);

const getImagePresentRatio = pipeline(
  getRedditJSONUrl,
  fetchData,
  extractPosts,
  map(hasImageAttached),
  calculateRatio
); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

å¥½äº†ï¼Œæˆ‘ä»¬éœ€è¦å†™ä¸‹å‡ ä¸ªæ­¥éª¤ï¼Œè¿™æ ·æˆ‘ä»¬å°±æœ‰äº†ç»„è£…æµç¨‹çš„æ‰€æœ‰å¯ç”¨å‡½æ•°ã€‚ç°åœ¨å°±æ¥è¡¥å……ä¸€ä¸‹:

```
const countComments = post => post.data.num_comments;

const hasImageAttached = post => post.data.post_hint == 'image';

const calculateRatio = array => {
  if (array.length == 0) return undefined;
  return array.filter(value => !!value).length / array.length;
}; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

å®Œæˆåï¼Œè®©æˆ‘ä»¬çœ‹çœ‹è¿™ä¸€åˆ‡æ˜¯å¦è¿è¡Œ:

`const fetch = require('node-fetch'); const _wordCount = require('@iarna/word-count'); const getRedditJSONUrl = url => url.replace(/\/?$/, '.json'); const fetchData = url => fetch(url).then(response => response.json()); const extractPosts = redditPage => redditPage.data.children; const extractPostTextAndTitle = post => post.data.title + '\n' + post.data.selftext; const countWords = text => _wordCount(text); const numberValueSorter = (a, b) => a - b; const calculateMedian = list => { if (list.length == 0) return undefined; const sorted = Array.from(list).sort(numberValueSorter); if (sorted.length % 2 == 0) { const a = sorted.length / 2 - 1; const b = a + 1; return (list[a] + list[b]) / 2; } else { const i = Math.floor(sorted.length / 2); return list[i]; } } const pipeline = (...steps) => { return async input => { let result = input; for (const step of steps) result = await step(result); return result; }; }; const map = (...mappers) => async array => { const results = []; for (const value of array) { let result = value; for (const mapper of mappers) result = await mapper(result); results.push(result); } return results; }; const countComments = post => post.data.num_comments; const hasImageAttached = post => post.data.post_hint == 'image'; const calculateRatio = array => { if (array.length == 0) return undefined; return array.filter(value => !!value).length / array.length; }; const getMedianWordCount = pipeline( getRedditJSONUrl, fetchData, extractPosts, map( extractPostTextAndTitle, countWords ), calculateMedian ); const getMedianCommentCount = pipeline( getRedditJSONUrl, fetchData, extractPosts, map(countComments), calculateMedian ); const getImagePresentRatio = pipeline( getRedditJSONUrl, fetchData, extractPosts, map(hasImageAttached), calculateRatio );` `const URL = 'https://www.reddit.com/r/dataisbeautiful/'; // now we need to call all three processes and report the final count Promise.all([ getMedianWordCount(URL), getMedianCommentCount(URL), getImagePresentRatio(URL) ]).then(([medianWordCount, medianCommentCount, imagePresentRatio]) => { console.log( 'Results for ' + URL, { medianWordCount, medianCommentCount, imagePresentRatio } ); });`

å¾ˆå¥½ï¼Œæˆ‘ä»¬ç°åœ¨çŸ¥é“æˆ‘ä»¬å¯ä»¥ç”¨è¿™äº›æ„ä»¶æ„å»ºæµç¨‹ã€‚ä¸è¿‡ï¼Œæœ‰ä¸€ä¸ªå°é—®é¢˜ã€‚æ¯ä¸ªè¿›ç¨‹éƒ½å¿…é¡»åšå¾ˆå¤šç›¸åŒçš„äº‹æƒ…ï¼Œè®©æ¯ä¸ªè¿›ç¨‹æ¯æ¬¡éƒ½è·å–ç›¸åŒçš„æ•°æ®å¹¶ç»å†ç›¸åŒçš„åŠ¨ä½œä¼¼ä¹æ˜¯ä¸€ç§æµªè´¹ã€‚

è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª`fork`å‡½æ•°æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ã€‚

ç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›å°†ç®¡é“åˆ†å‰²æˆæ¯ä¸ªæµç¨‹çš„ç‰¹å®šç®¡é“ï¼Œç„¶åå°†å®ƒä»¬è¿æ¥åœ¨ä¸€èµ·ä»¥è·å¾—æœ€ç»ˆç»“æœã€‚è®©æˆ‘ä»¬å†™ä¸€äº›å¹»æƒ³çš„ä»£ç ï¼Œè®©ç›®æ ‡æ›´æ¸…æ™°ä¸€ç‚¹:

```
const getMedianWordCount = pipeline(
  map(
    extractPostTextAndTitle,
    countWords
  ),
  calculateMedian
);

const getMedianCommentCount = pipeline(
  map(countComments),
  calculateMedian
);

const getImagePresentRatio = pipeline(
  map(hasImageAttached),
  calculateRatio
);

// this is a convenience function that associates names to the results returned
const joinResults = ([
  medianWordCount,
  medianCommentCount,
  imagePresentRatio
]) => ({
  medianWordCount,
  medianCommentCount,
  imagePresentRatio
});

// the process function, now with forking!
const getSubredditMetrics = pipeline(
  getRedditJSONUrl,
  fetchData,
  extractPosts,
  fork(
    getMedianWordCount,
    getMedianCommentCount,
    getImagePresentRatio
  ),
  joinResults
); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

æ ¹æ®ä»¥ä¸Šè¦æ±‚ï¼Œ`fork`å‡½æ•°å–ä¸€ç³»åˆ—æµæ°´çº¿ã€‚

åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä¼šå»ºè®®ä½ ç»§ç»­å°è¯•ç¼–å†™è‡ªå·±çš„`fork`å®ç°ï¼Œè€ƒè™‘åˆ°ä¸Šé¢çš„çº¦æŸã€‚æ‚¨çš„å®ç°å¯èƒ½éå¸¸ç±»ä¼¼äºæ‰©å±•çš„`map`ã€‚

ä¸‹é¢æ˜¯æˆ‘å¯¹`fork`å‡½æ•°çš„ç†è§£:

```
const fork = (...pipelines) =>       // a function that takes a list of pipelines,
  async value =>                     // returns an async function that takes a value;
    await Promise.all(               // it returns the results of promises...
      pipelines.map(                 // ...mapped over pipelines...
        pipeline => pipeline(value)  // ...that are passed the value.
      )
    ); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

å¦‚æœå®ƒçœ‹èµ·æ¥ä»¤äººå›°æƒ‘ï¼Œä¸è¦æ‹…å¿ƒã€‚è§£å¼€è¿™ä¸ªå‡½æ•°çš„ä½œç”¨éœ€è¦å¾ˆå¤šæ—¶é—´ã€‚

è¯€çªæ˜¯è®°ä½`Promise.all()`æ¥å—ä¸€ä¸ªæ‰¿è¯ºæ•°ç»„ï¼Œå¹¶è¿”å›ä¸€ä¸ªåœ¨æ‰€æœ‰å€¼éƒ½è§£æåè§£æçš„æ‰¿è¯ºã€‚ç»“æœæ˜¯ä»¥ç›¸åŒé¡ºåºæ’åˆ—çš„ promise ç»“æœçš„æ•°ç»„ã€‚å¦‚æœä»»ä½•ä¸€ä¸ªå€¼ä¸æ˜¯ä¸€ä¸ªæ‰¿è¯ºï¼Œå®ƒå°±æŠŠå®ƒå½“ä½œä¸€ä¸ªæœ‰ç»“æœçš„ç«‹å³è§£å†³çš„æ‰¿è¯ºã€‚

## [](#the-final-result)æœ€ç»ˆç»“æœ

é‚£ä¹ˆ,`fork`ä¼šèµ·ä½œç”¨å¹¶ä¸ºæˆ‘ä»¬èŠ‚çœé¢å¤–çš„å¼€é”€å—ï¼Ÿè®©æˆ‘ä»¬çœ‹çœ‹ã€‚

`const fetch = require('node-fetch'); const _wordCount = require('@iarna/word-count'); const getRedditJSONUrl = url => url.replace(/\/?$/, '.json'); const fetchData = url => fetch(url).then(response => response.json()); const extractPosts = redditPage => redditPage.data.children; const extractPostTextAndTitle = post => post.data.title + '\n' + post.data.selftext; const countWords = text => _wordCount(text); const numberValueSorter = (a, b) => a - b; const calculateMedian = list => { if (list.length == 0) return undefined; const sorted = Array.from(list).sort(numberValueSorter); if (sorted.length % 2 == 0) { const a = sorted.length / 2 - 1; const b = a + 1; return (list[a] + list[b]) / 2; } else { const i = Math.floor(sorted.length / 2); return list[i]; } } const pipeline = (...steps) => { return async input => { let result = input; for (const step of steps) result = await step(result); return result; }; }; const map = (...mappers) => async array => { const results = []; for (const value of array) { let result = value; for (const mapper of mappers) result = await mapper(result); results.push(result); } return results; }; const countComments = post => post.data.num_comments; const hasImageAttached = post => post.data.post_hint == 'image'; const calculateRatio = array => { if (array.length == 0) return undefined; return array.filter(value => !!value).length / array.length; }; const fork = (...pipelines) => async value => await Promise.all(pipelines.map(pipeline => pipeline(value)));` `const getMedianWordCount = pipeline( map( extractPostTextAndTitle, countWords ), calculateMedian ); const getMedianCommentCount = pipeline( map(countComments), calculateMedian ); const getImagePresentRatio = pipeline( map(hasImageAttached), calculateRatio ); // this is a convenience function that associates names to the results returned const joinResults = ([ medianWordCount, medianCommentCount, imagePresentRatio ]) => ({ medianWordCount, medianCommentCount, imagePresentRatio }); const getSubredditMetrics = pipeline( getRedditJSONUrl, fetchData, extractPosts, fork( getMedianWordCount, getMedianCommentCount, getImagePresentRatio ), joinResults ); const URL = 'https://www.reddit.com/r/dataisbeautiful/'; getSubredditMetrics(URL) .then(results => console.log('Report for ' + URL, results));`

[![](../Images/2cc83056ac5c063058e2fd1770a79fd5.png)T2ã€‘](https://i.giphy.com/media/ChzfTLSi47FYc/giphy.gif)

## [](#one-last-magic-trick)æœ€åä¸€ä¸ªé­”æœ¯

è¿˜å’Œæˆ‘åœ¨ä¸€èµ·å—ï¼Ÿå¥½çš„ï¼Œè¿˜è®°å¾—å½“æˆ‘ä»¬å¼€å§‹è§’è‰²æ‰®æ¼”æ—¶ï¼Œæˆ‘ä»¬æƒ³è¦ä¸ºä¸€ä¸ªåˆ—è¡¨æˆ– URL ç”Ÿæˆè¿™äº›æŠ¥å‘Šï¼Œè€Œä¸ä»…ä»…æ˜¯ä¸€ä¸ªï¼Ÿæˆ‘ä»¬æ˜¯å¦å¯ä»¥åˆ›å»ºä¸€ä¸ªç±»ä¼¼äº T2 çš„è¿›ç¨‹æµç¨‹(T3 ),æ¥å—ä¸€ä¸ªæ•°ç»„æˆ– URL å¹¶è¿”å›ä¸€ä¸ªæŠ¥å‘Šæ•°ç»„ï¼Ÿ

ä¹Ÿè®¸å§ã€‚

æˆ‘ä»¬æ¥åˆ†è§£ä¸€ä¸‹è¿™ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ª URL æ•°ç»„ã€‚æˆ‘ä»¬çŸ¥é“æˆ‘ä»¬å¯ä»¥é€šè¿‡ç®¡é“ä¼ é€’æ¯ä¸ª URLï¼Œå¹¶è¿”å›è§£æåˆ°æŠ¥å‘Šçš„æ‰¿è¯ºã€‚å¦‚æœæˆ‘ä»¬ç”¨ç®¡é“æ˜ å°„ URL æ•°ç»„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¾—åˆ°çš„æ˜¯æ‰¿è¯ºæ•°ç»„ã€‚

æˆ‘ä»¬å·²ç»çŸ¥é“å¦‚ä½•è§£å†³ä¸€ç³»åˆ—çš„æ‰¿è¯ºï¼

```
const distribute = pipeline =>  // distribute takes a pipeline,
  values =>                     // and returns a function that takes a list of values;
    Promise.all(                // it returns a promise of all the values...
      values.map(pipeline)      // ...passed through each pipeline
    ); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

æ˜¯çš„ï¼Œæˆ‘æƒ³è¿™å°±å¤Ÿäº†ï¼è®©æˆ‘ä»¬é€šè¿‡ä¼ é€’ä¸€ç»„ URL æ¥è¯•éªŒä¸€ä¸‹ï¼Œçœ‹çœ‹å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„:

`const fetch = require('node-fetch'); const _wordCount = require('@iarna/word-count'); const getRedditJSONUrl = url => url.replace(/\/?$/, '.json'); const fetchData = url => fetch(url).then(response => response.json()); const extractPosts = redditPage => redditPage.data.children; const extractPostTextAndTitle = post => post.data.title + '\n' + post.data.selftext; const countWords = text => _wordCount(text); const numberValueSorter = (a, b) => a - b; const calculateMedian = list => { if (list.length == 0) return undefined; const sorted = Array.from(list).sort(numberValueSorter); if (sorted.length % 2 == 0) { const a = sorted.length / 2 - 1; const b = a + 1; return (list[a] + list[b]) / 2; } else { const i = Math.floor(sorted.length / 2); return list[i]; } } const pipeline = (...steps) => { return async input => { let result = input; for (const step of steps) result = await step(result); return result; }; }; const map = (...mappers) => async array => { const results = []; for (const value of array) { let result = value; for (const mapper of mappers) result = await mapper(result); results.push(result); } return results; }; const countComments = post => post.data.num_comments; const hasImageAttached = post => post.data.post_hint == 'image'; const calculateRatio = array => { if (array.length == 0) return undefined; return array.filter(value => !!value).length / array.length; }; const fork = (...pipelines) => async value => await Promise.all(pipelines.map(pipeline => pipeline(value))); const getMedianWordCount = pipeline( map( extractPostTextAndTitle, countWords ), calculateMedian ); const getMedianCommentCount = pipeline( map(countComments), calculateMedian ); const getImagePresentRatio = pipeline( map(hasImageAttached), calculateRatio ); // this is a convenience function that associates names to the results returned const joinResults = ([ medianWordCount, medianCommentCount, imagePresentRatio ]) => ({ medianWordCount, medianCommentCount, imagePresentRatio }); const getSubredditMetrics = pipeline( getRedditJSONUrl, fetchData, extractPosts, fork( getMedianWordCount, getMedianCommentCount, getImagePresentRatio ), joinResults );` `const distribute = pipeline => values => Promise.all(values.map(pipeline)); const URLs = [ 'https://www.reddit.com/r/dataisbeautiful/', 'https://www.reddit.com/r/proceduralgeneration/' ]; const getAllReports = distribute(getSubredditMetrics); getAllReports (URLs) .then(results => { const reports = results.map((report, idx) => ({ url: URLs[idx], report })); console.log(reports); });`

[![](../Images/c5f629beedccdb844b1ac5ef64519e58.png)T2ã€‘](https://i.giphy.com/media/RWFpHUbc6s492/giphy.gif)

## [](#and-they-lived-happily-ever-after)...ä»æ­¤ä»–ä»¬å¹¸ç¦åœ°ç”Ÿæ´»åœ¨ä¸€èµ·ã€‚

æ­å–œä½ èµ°åˆ°è¿™ä¸€æ­¥ï¼æ‚¨å·²ç»æˆåŠŸåœ°ä»å¤´å¼€å§‹è®¾è®¡å’Œå¼€å‘äº†æ•´ä¸ªå¼‚æ­¥åè°ƒæœºåˆ¶ç³»ç»Ÿï¼Œè¿™ä¸æ˜¯ä¸€ä»¶å®¹æ˜“çš„äº‹æƒ…ã€‚

æ€»ç»“ä¸€ä¸‹ï¼Œè®©æˆ‘ä»¬æå–æˆ‘ä»¬ç”¨æ¥æ„å»ºæµç¨‹å‡½æ•°çš„é€šç”¨å®ç”¨å‡½æ•°ï¼Œå¹¶ä½¿å®ƒä»¬ä½œä¸ºæ¨¡å—å¯ç”¨:

```
export const pipeline = (...steps) =>
  async input => {
    let result = input;
    for (const step of steps)
      result = await step(result);
    return result;
  };

export const map = (...mappers) =>
  async array => {
    const results = [];
    for (const value of array) {
      let result = value;
      for (const mapper of mappers)
        result = await mapper(result);
      results.push(result);
    }
    return results;
  };

export const fork = (...pipelines) =>
  async value =>
    await Promise.all(
      pipelines.map(pipeline => pipeline(value))
    );

export const distribute = pipeline =>
  values =>
    Promise.all(
      values.map(pipeline)
    ); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

ä»…ä»…ä½¿ç”¨è¿™å››ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å°±æˆåŠŸåœ°æ„å»ºäº†ä¸€å¥—å®Œæ•´çš„é€šç”¨åŸè¯­ï¼Œå¯ä»¥åœ¨ä¸åˆ° 350 ä¸ªå­—ç¬¦çš„å°å‹ä»£ç ä¸­å¤„ç†æœ‰é™çš„å·¥ä½œé‡ã€‚ğŸ˜‰

ä½ ç°åœ¨å¯ä»¥è„±ä¸‹è§’è‰²æ‰®æ¼”æœè£…äº†ã€‚

[![](../Images/411595fc835a4b9874cbbc428927c3f6.png)T2ã€‘](https://i.giphy.com/media/X6SPa7Q4BIc7K/giphy.gif)