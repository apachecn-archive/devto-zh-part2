# 查看堆栈跟踪中的“ls”

> 原文：<https://dev.to/captainsafia/looking-at-the-stack-trace-for-ls-1701>

你知道星期一意味着什么。一篇新的博文！

这周我在尝试新的东西。我不再在上下班的路上每周写三次博客，而是在周末的一天里写完所有的博客。

今天，我将会看到一个我之前在代码库中看到过的命令,`ls`命令。说实话，感觉那是很久以前的事了，我都不记得了。无论如何，我跳转到 Google Cloud 上的 Debian VM 实例，在我的主目录中运行`ls`命令上的`strace`。

它首先在当前工作目录下运行`open`系统调用。它向调用传递了相当多的标志。有些我已经知道，有些我不知道。尽管如此，这里有一个所有这些标志在做什么的分类。

1.  `O_RDONLY`:打开文件只读。不允许修改文件！
2.  `O_NONBLOCK`:从`open`调用返回，没有任何延迟。
3.  `O_DIRECTORY`:打开一个目录，目的是检查其内容。
4.  `O_CLOEXEC`:当前被`exec`调用的进程返回时，自动关闭文件描述符。

```
[pid 13721] open(".", O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC) = 3
[pid 13721] fstat(3, {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0 
```

下一个被调用的系统调用是`getdents`系统调用，根据[文档](https://linux.die.net/man/2/getdents)，它返回一个目录的内容。

```
[pid 13721] getdents(3, /* 13 entries */, 32768) = 400 
```

接下来的几行是对目录的每个内容调用的`lstat`函数。这被`ls`用来决定文件的大小和所有者等等。这是您在运行带有`-l`标志的`ls`时会看到的信息。

```
[pid 13721] lstat("test-4.txt", {st_mode=S_IFREG|0644, st_size=13, ...}) = 0 
```

堆栈跟踪中的最后两个调用确实让我有点迷惑。该函数使*对`getdents`系统调用进行另一个*调用。它为什么要这样做？我试图找出两个系统调用之间的区别。在第一个示例中，第二个参数指向 13 个目录条目结构的列表，系统调用返回 400。在下面列出的第二个调用中，第二个参数指向 0 个目录条目结构的列表，并返回 0。我认为可能调用了两次，因为有一些 for 循环迭代，直到`getdents`函数返回 0。

```
[pid 13721] getdents(3, /* 0 entries */, 32768) = 0
[pid 13721] close(3) 
```

堆栈跟踪中的最后一行关闭了与我们正在读取的当前目录相关联的文件描述符。

就这样，我结束了这篇博文！我知道这篇博文很短，但那是因为我在为本周晚些时候将要发生的事情做准备。这将是一个令人惊叹的…