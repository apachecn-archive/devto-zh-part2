# 即插即用和叮当作响

> 原文:[https://dev.to/arcanis/plugnplay-and-tink-4684](https://dev.to/arcanis/plugnplay-and-tink-4684)

npm 的人最近在 Tink 上做了一个 [FAQ，解释了 Tink 背后的一些动机和他们看到的即插即用的区别。虽然有趣，但它显然没有详细说明这些差异背后的背景或推理，所以让我们来谈谈，澄清这一切！🔬](https://npm.community/t/tink-faq-what-is-this-thing-even/3191)

*   首先，注意即插即用是一个规范。因此，**并不意味着是 Yarn** 所独有的，最重要的是，它正式确定了应用程序和包管理器之间的契约。经常会发生一些不正确的假设，在最糟糕的时候导致意想不到的(和痛苦的)破裂。部署到生产环境中却突然什么都不用了，这可不是什么好体验。克隆一个旧项目，发现提升也没有改变。

*   即插即用被特别设计成易于与第三方集成——事实上，比当前依赖 node_modules 的节点解决方案要容易得多。无论您使用哪种工具，只需从专用的 PnP API 中取出一行代码就可以找到您正在寻找的包的位置。它是为了给以前[不得不自己重新实现模块解析逻辑的包提供更好的工具](https://yarnpkg.com/en/packages?q=require%20resolve&p=1)，当然也不会让他们的日子更难过。最重要的是，通过标准的节点 API，我们是完全透明的，这意味着`require.resolve`正如您所期望的那样工作。这使得即插即用与生态系统的绝大多数兼容，少数不兼容的软件包通常可以迁移到`require.resolve`并使用它。

*   无论好坏，Tink 覆盖了`fs`和`child_process`内置模块。虽然这肯定是一个有趣的方法，对快速迭代有很大的价值，但我们认为它会给我们的用户带来太大的风险，无法成为一个永久的特性。我们并不完美，一个漏洞爬进一个猴子修补的`fs`函数的风险可能是毁灭性的——无论是在可靠性还是安全性方面。相比之下，如果出现问题，模块解析 API 包含的失败响应更快，这只是一个临时措施，直到节点完成实现[适当的加载器](https://github.com/nodejs/modules/issues/82)。

*   在 NPM 的交流中，我认为有些误导: **Tink 并没有摆脱 node_modules。**或者至少不会比 [pnpm](https://pnpm.js.org/) 已经做的更多，因为从节点的角度来看，node_modules 仍然存在，即使它们被虚拟化了。看，`node_modules`的两个主要问题是它们模糊了包之间的界限(允许仅仅依靠提升来要求依赖性)，并且由于基于文件系统的解决方法的限制(主要是路径冲突)，它们将各种优化完全排除在外。Tink 可能能够确保更好的边界，这取决于它的实现，但是如果没有额外的节点解析挂钩，完美的优化和单实例化是不可能完成的。文件系统支持的`node_modules`并不是(唯一的)问题——解决方案依赖于`node_modules`嵌套层次结构的事实才是问题所在。

*   我有点担心 Tink 没有推广好的实践。我相信我们有责任确保生态系统处于正常状态，使其他工具有可能出现并最终取代我们。这就是为什么我们采用一种方法，允许我们在某个东西关闭时抛出语义错误(而不是静静地让它工作)的原因之一。不惜一切代价实现兼容性是一个有价值的目标，但是考虑到 JavaScript 的扩展速度，我认为我们需要在它们拖垮我们之前重新思考一些我们认为理所当然的事情。

*   Tink 的特性集似乎与 pnpm 已经承诺的紧密一致，只是如果没有在 Node 的原语之上添加一个厚重的猴子补丁层，它就无法工作。如果有的话，我不明白为什么它不能是构建在 pnpm 之上的一个包(不一定是在它的核心——只是会在内部使用它，就像 Lerna 使用工作区一样)。

总的来说:Tink 是一个有趣的想法，与我们的权衡非常不同！我一直是不同用途的不同工具的强烈支持者，因此我觉得看到这样的方法很棒。我只是认为它解决的问题与我们用即插即用解决的问题非常不同，尽管围绕它们的相似性进行了交流😉

## [](#final-notes)期末注释:

一般来说，Yarn 的理念与 npm 的长期计划非常不同。很明显，他们现在希望用各种本机集成将 Node 包装在自以为是的层之后，正如[“自动类型脚本和 JSX 支持”](https://twitter.com/maybekatz/status/1059645898190286850)功能所证明的那样，以及他们更喜欢在运行时懒洋洋地安装其依赖项的方式。

至于 Yarn，我们相信一种更可靠、更通用的方法，在这种方法中，尽可能提前完成工作，在 CI 和生产服务器上几乎不做任何工作，缩短反馈周期，并增加您对部署的信任度。我们的责任是构建一个坚实的基础，让您的应用在未来几年保持稳定和可预测。你可以肯定，我们不会让这成为用户体验的方式，我们很快就会有非常令人兴奋的功能来告诉你我们是多么认真😊