# 你应该关心 Vue.js 中的 XSS 吗？

> 原文:[https://dev . to/nando d1707/should-you-care-XSS-in-vue js-1ea 6](https://dev.to/nandod1707/should-you-care-about-xss-in-vuejs-1ea6)

[![](../Images/d8fc766e591f86ac805ba32a2f9cf966.png)T2】](https://hackmetrix.com/)

让我们先来看看这篇文章中最明显的部分:如果您不清理您的数据，无论您使用什么框架，您都将容易受到跨站点脚本(XSS)攻击。

这篇文章的目的是向你展示一些你在使用 Vue 时容易受到 XSS 攻击的方式，并希望能告诉你如何预防它们。

如果此时你在想“等等，什么是跨站点脚本？”那么我们需要往回走一点。如果你已经熟悉这个主题，那么你可以直接跳过下一部分。

## [](#what-is-crosssite-scripting)什么是跨站脚本？

跨站点脚本(XSS)是一种 web 应用程序漏洞，它将客户端脚本注入到其他用户查看的页面中。

当站点将用户输入直接呈现到页面中，而没有首先通过转义特殊字符对其进行处理(净化)时，就会产生 XSS。这使得攻击者能够通过常规用户输入或 URL 参数添加脚本，这些脚本将在页面加载后执行。

你可以在这里阅读更多关于两种类型的 XSS:反射的 XSS 和储存的 XSS

那么 Vue 是如何脆弱的呢？

任何时候服务器生成的 HTML 被注入到一个网站，该网站可能容易受到 XSS 攻击。在 Vue 中，这是通过 v-html 指令实现的。

## v-html 指令

Vue 中的 v-html 指令用于将原始 html 输出到应用程序的组件中。

老实说，如果您已经在使用 Vue，可能没有什么好的理由使用它，因为您应该能够动态地应用任何属性。

然而，Alligator.io 中提到的一个用例是，如果您正在使用一个在数据库中存储了原始 HTML 的遗留系统，并且您需要在您的应用程序中呈现它。

因此，与使用 mustache 表达式不同，尽管 v-html 可能有用(毕竟它的存在是有原因的)，但它可能会让您遭受 XSS 攻击，因为通过 v-html 呈现的 Javascript 将被执行。

在这里可以看到通过 mustache 表达式和 v-html 呈现的相同字符串的快速演示，并尝试单击那里的链接来查看实际的注入。

在您的网站上动态呈现任意 HTML 可能非常危险，因为它很容易导致 XSS 漏洞。仅对受信任的内容使用 HTML 插值，不要对用户提供的内容使用。

## [](#mixing-serverside-and-clientside-rendering)混合服务器端和客户端渲染

使用 Vue 的网站容易受到 XSS 攻击的另一个原因是它们混合了服务器端和客户端的渲染，即使你在转义字符。同样值得注意的是，即使你没有使用 v-html，这个漏洞也会存在。

dotboris 在这份回购协议中详细探讨了这一点，其中包括一个非常清晰的示例和说明，我们将在下面进行概述。

为了简单地运行这个案例，应用程序将用户输入作为查询参数并呈现它。输入字段和呈现的 HTML 都在一个 Vue 元素中，该元素用于动态增加或减少计数器中的数字。

如果我们在输入字段中写一个带有一点数学的表达式，你会看到它被 Vue 正确地处理了，例如，输入

`{{ 2 + 2 }}`

这将导致应用程序渲染

`You have injected: 4`

所以现在我们知道注射是可以做到的。

但是，对任何 Javascript 函数使用相同的方法都不会奏效。所以如果我们尝试

`{{ alert(‘xss’) }}`

我们将得到类似于:

`TypeError: alert is not a function
at Proxy.eval (eval at createFunction (vue.js:10518), <anonymous>:3:114)
at Vue$3.Vue._render (vue.js:4465)
at Vue$3.updateComponent (vue.js:2765)
at Watcher.get (vue.js:3113)
at new Watcher (vue.js:3102)
at mountComponent (vue.js:2772)
at Vue$3.$mount (vue.js:8416)
at Vue$3.$mount (vue.js:10777)
at Vue$3.Vue._init (vue.js:4557)
at new Vue$3 (vue.js:4646)`

这是因为任何 Vue 表达式都是在其实例的上下文中计算的。因此，当我们键入 alert('xss ')时，它试图在我们的 Vue 实例中查找 alert 方法，当然，它并不存在。

为了避免这个问题，回购协议中的例子使用了

`{{constructor.constructor("alert('xss')")() }}`

如果你试着在输入框中输入，你应该会看到它没有问题。

为什么会这样？直接引用 dotboris 的话:

“在 javascript 中，所有的构造函数都是函数，所有的函数都是对象。这意味着 Vue$3 有一个构造函数。这个构造函数是函数构造函数。编写 constructor.constructor 给了我们函数构造器。

函数构造器让我们在运行时动态定义函数。我们把函数的代码传给它，它返回一个我们可以运行的函数。在这种情况下，我们以 Function("alert('xss ')")结束。这就创建了一个调用 alert(全局范围内真正的 alert)的函数，然后调用它。"

这是因为虽然用户输入被应用程序转义，但当页面到达浏览器时，Vue 会获取 HTML 并将其呈现为模板，对 HTML 运行复杂的评估。

此时，Vue 无法区分哪个模板是安全的，以及用户发送的任何不安全的输入。

那么如何才能防止这种情况呢？每当服务器端的值被注入到模板中时，使用 v-pre 指令可以很好地工作，但是当它需要被手动添加到每个这样做的元素中时，它很容易被忽略。

本例作者提出的另一种方法是在保存所有服务器端变量的页面中定义一个全局变量，这样＄_ GET[' var ']将变成 SERVER_VARIABLES.var，这为开发人员提供了一种更安全的从服务器向客户端传递值的方式。

在我们这边，我们的建议也是将 Vue 限制在像这样的情况下需要它的地方。与其他框架相比，Vue 的一个好处是它不需要在整个页面上使用。

在这个特定的例子中，Vue 仅用于增加和减少计数器中的数字，但是计数器和显示用户输入的元素在同一个 div 中，因此受同一个 Vue 实例的影响。

如果我们不保持这种方式，而是将显示用户输入的元素放在 Vue 元素之外，那么应用程序不会失去任何功能，并且呈现的任何用户输入都会安全显示，不管它是否是一个函数(只要它是服务器端转义的)。

长话短说，永远记住避开用户输入，尽管现代框架可能很方便，但不要指望它们已经覆盖了每一个安全缺陷。

V-pre 和避免直接注入原始 HTML 是很好的做法，但对于 app 来说，最好花时间在早期了解应用程序中可能存在漏洞的地方，并学习如何防止它们。