# 数据库包

> 原文:[https://dev.to/horia141/packages-for-databases-4m2](https://dev.to/horia141/packages-for-databases-4m2)

互联网公司在处理关系数据库时的一个普遍经验是避免*存储过程*。有一堆原因*为什么*会这样，但这通常是感觉到的性能问题和简单的难以使用的组合。

前者在我看来有点程序员的民间传说。没有内在的原因来解释为什么会这样。事实上，将代码移动到数据是一个在许多其他系统中广泛使用的原则，比如 MapReduce、Hadoop 及其各种分支。的确，许多旧系统表现不佳，但是在软件质量和硬件性能方面，事情已经朝着正确的方向发展了很多。

然而，后一个问题有一点真实性。这可能是今年最保守的说法。使用存储过程或关系数据库的任何其他“可编程性”特性是一件痛苦的事情。这种语言本身并不好，围绕它的工具也很糟糕。根据我的经验，这种糟糕的根源在于，与数据库的交互主要是通过交互式查询来完成的，比如`CREATE PROCEDURE`或`ALTER PROCEDURE`。

一个直接的问题是回滚非常困难。你基本上需要发布另一个`CREATE PROCEDURE`，但是如果你能在某个地方找到完整的旧形式的代码。另一个问题与许多团队使用迁移工具并将迁移脚本存储在源代码控制中的事实有关。这对于模式级的更改可能没问题[1],但是对于通常是较大代码块的存储过程来说却是一件痛苦的事情。对存储过程的更改通常是一个完全替换当前版本的迁移脚本。因此，在这种情况下，新旧之间的差异和其他比较是很难做到的。

最后一个问题更深入一点。因为有代码和代码的部署，理想情况下它们应该是独立的。在当前的系统中，这两者之间有很强的耦合性——更新过程的命令实际上要求所有代码都被内联指定！

但这并不一定会造成这样的伤害，而且事情有好转的先例。我说的当然是互联网应用的计算部分。在过去的十年里，我们已经从 VPSs 发展到 PaaSes、Kubernetes 和 serverless，大多数人都认为这是一件好事。围绕构建和部署*代码*的整个基础设施也在发展。以至于即使我们正在处理的系统的规模可能比过去的几年要小，但作为一名开发人员，现在实际上与它们交互要容易得多。

让我们考虑一堆例子。一方面，人们仍然租用 VPS，然后手动 SSH 到其中并复制本地文件，以便进行部署，就像他们在“旧时代”所做的那样。有时可能会涉及到一个或三个脚本，但是这个过程是非常基本和直接的。另一方面，你有开发良好的自动化代码部署管道、包存储库、展示管理器等。管理其他系统的整个系统。如今，随着规模越来越大，或者随着需求的增加，从一个项目发展到另一个项目已经不再是一个真正的问题，因为你可以使用大量先进的工具启动任何规模的项目，并获得大量的好处。

我认为数据库交互在 SSH 和文件复制端。理想情况下，我们希望他们在相反的一端。

现在好的事情是，如果你足够仔细地观察，数据库和计算组件非常相似——都允许执行用户指定的代码。在后一种情况下与其他服务或数据库交互，而在前一种情况下与数据本身交互。既然对鹅有用的东西对公鹅也有用，我们可以试着模仿计算的发展来启动数据库的发展。

因此，一个有用的概念是*包*。存储过程，或者更一般地说，任何非 DDL 查询都可以分组到这些包中。然后，数据库可以加载一个包，并将其提供给数据库用户。一个*构建过程*将从一个存储库中获取代码，运行测试并生成一个包。自然地，包将被版本化，并且它们可以被存储在一个存储库中。在较小的安装中，该功能可以由数据库服务器本身来完成，在较大的安装中，该功能可以是一个独立的系统。部署只是将某个包版本推给一组机器，并告诉它们做需要做的事情，以便使用它们。对于计算节点，这通常是节点的重启，但对于存储层应用程序来说，这可能有些过头了。这组数据库实例的行为类似于 Kubernetes 集群或 PaaS 系统，如 AppEngine 或 Heroku。像分布式部署的回滚或智能策略这样的问题变得更容易管理和推理。

在源代码级别，我们可以为这类事情取消*迁移*，并像保存任何其他源文件一样保存代码。通过源代码控制，我们会得到很好的区别和真正的进步感。

到目前为止，我已经谈到了关系数据库。但是这个问题不仅限于他们。在某种程度上，NoSQL 或 NewSQL 数据库已经实现了可编程特性，它们复制了关系数据库所具有的特性，因此继承了它们的局限性和笨拙之处。

无论如何，这是个大主意。在本文的这一点上，我应该插入我的副业项目或产品，它为 Postgres/MySQL/SQL Server 提供了以上所有功能以及更多功能。但是在可预见的未来还没有这样的事情。这只是我的一厢情愿。但我确实认为这是一个很好的想法，如果你想带着它跑，实际上建立一些东西，你会有我的第一个用户。

* * *

[1]尽管这种方法对我来说一直像是一种妥协。为什么我们作为一个行业正在转向基础设施即代码，并乐于让`terraform`将基础设施的声明性描述转换为实际的云提供商命令，但我们不希望模式也是如此？也许是时候将*模式作为代码*了？