# 哈希函数综述:理论与安全性

> 原文:[https://dev . to/PEM tajo/an-overview-about-hash-functions-theory-and-security-139 e](https://dev.to/pemtajo/an-overview-about-hash-functions-theory-and-security-139e)

<figure>[![](../Images/4dcc4873b54c357bcf87e29a00cbd4b4.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--Wh6RhYof--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/640/1%2AHuCZw-nGPkTsaORer4g4jg.jpeg) 

<figcaption>[葡文版](https://pemtajo.github.io/hash_teoria_seguranca/)</figcaption>

</figure>

散列函数更常见的定义是“将任意长度的位串映射到固定长度的位串的函数”。

散列函数是单向的，它是一个不允许反转的满射函数，因此很容易从任意长度的输入中计算出散列值。

相比之下，从给定的哈希值返回到消息的前一个值更难。

### [](#hash-properties)哈希属性

对于加密应用，有三个期望的属性:

#### [](#collision-resistance)碰撞阻力

在计算上不可能找到任何一对(x，y)使得 H(x)=H(y)

#### [](#preimage-resistance)*前像电阻*

对于给定的任何 H 值，要找到 x 使得 H(x) = h 在计算上是不可行的。

#### [](#second-preimage-resistance)*第二前像电阻*

对于任何数据块 x，在计算上不可能找到不同于 x 的 y，使得 H(y) = H(x)。

理想的情况是，对于每个输入值，生成的每个哈希值都是唯一的，但这是不可能的。在散列函数中，要生成的可能散列值是有限的，因为它们具有固定的输出大小，并且因为输入大小理论上是无限的，根据鸽子洞原理，将会有两个不同条目的冲突，导致相同的散列。

然而，这些函数被构造成最小化有效冲突，即，在上下文中有意义的两个消息不太可能产生相同的散列。

### [](#hash-usage-examples)Hash 用法举例

哈希函数有多种安全用途，例如:

#### [](#message-authentication)消息认证

用于验证消息完整性的机制或服务；确保收到的信息与发送的信息相同(未经修改、插入、删除或重放)；

#### [](#digital-signatures)数字签名

消息的摘要值用发送方的私钥加密，任何拥有公钥的用户都可以验证与数字签名相关的消息的完整性；

#### [](#password-file)密码文件

密码的摘要存储在操作系统的文件中，而不是存储密码，在密码文件被违反的情况下，攻击者将只能获得密码的散列；

#### [](#detection-of-intruders-and-viruses)检测入侵者和病毒

对于系统的每个 F 文件，hash H(F)也被存储，如果 F 有任何变化，都会被感知；

#### [](#pseudorandom-function-family-prf-or-pseudorandom-number-generator-prng)伪随机函数族(PRF)或伪随机数发生器(PRNG)

用于生成对称密钥。

#### [](#blockchain)区块链

区块链中的数据是每个块中的“散列”。如果区块发生变化，例如，有人试图改变他们有多少比特币或他们应该发送多少比特币，哈希值就会不同，每个人都可以察觉到事情发生了变化。

前一个块的哈希值用于计算当前块的哈希值，从而在块之间创建链接。

链接到哈希实现的算法示例如下:

*   [SHA-1](https://rosettacode.org/wiki/SHA-1)；不稳定的
*   [SHA-256](https://rosettacode.org/wiki/SHA-256)；
*   [MD5](https://rosettacode.org/wiki/MD5)；不稳定的

使用哈希将您的密码保存在数据库中是一个很好的做法(目前我们可以说这是强制性的)，以防当您的数据库被黑客暴露时，他无法直接访问您的客户的密码。

所以只要为我的密码创建一个哈希，问题就解决了？不完全是。

### [](#how-hashes-are-broken)哈希是如何被破解的

[![Alt Text](../Images/0dbd5bd994d61a074d6916b746226ef9.png)T2】](https://i.giphy.com/media/1230rTAtEjLyLu/giphy.gif)

通过 hash 的性质，我们已经看到，给定一个 hash H(x)要发现输入 x 在计算上应该是不可行的，所以不可能“解密”hash，毕竟这是一个不允许返回的操作。

但是我们知道，给定一个输入，总是生成相同的散列，破解者也知道这一点。还有一些已知的针对密码的哈希攻击:

#### [](#dictionary-attacks-and-brute-force)字典攻击和蛮力

寻找散列的最简单方法。

字典攻击使用包含单词、短语、常用密码等的文件来计算每个单词、短语、常用密码的散列值，并检查它是否符合任何列表或数据库。

强力攻击使用定义数量的字符测试所有单词的可能性，并验证哈希计算是否等于列表中的某些内容。

#### [](#lookup-tables)*查找表*

查找表是一个非常有效的方法来打破多个散列迅速。一般的想法是预先计算一个字典的密码散列，并将这个值与它对应的密码一起保存。一个好的查找表实现可以每秒处理数百个散列，并包含数十亿个散列。

#### [](#reverse-lookup-tables)*反向查找表格*

这种攻击允许攻击者同时对多个哈希应用字典或暴力攻击。

首先，攻击者创建一个查找表，将数据库契约的每个密码哈希映射到拥有该哈希的用户列表。

[![](../Images/c5d1afe12a39dee4e8e6580e93f3062b.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--IM1vdy3h--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/721/1%2AlS8fY6ly3mvrHLUMHMcGlw.png)

然后，攻击者进行字典攻击或暴力攻击，一旦发现密码，他就已经有了拥有该密码的用户列表。这种攻击非常有效，因为许多用户拥有相同的密码是很常见的。

#### [](#rainbow-tables)彩虹表

一个 ***彩虹表*** 是预先计算好的哈希查找表。是 [*时间/内存/数据权衡攻击*](https://en.wikipedia.org/wiki/Time/memory/data_tradeoff_attack) 的一个实际例子。

它看起来像查找表，只是它牺牲了打破散列的速度，使表变得更小。因为它们更小，所以更多散列的解决方案可以存储在相同的空间中，在存储方面更有效。

然后，以

为例，我们有一个使用 SHA-1 算法存储的密码为 123456 的客户端，因此在银行中会有散列 7 C4 A8 d 09 ca 3762 af 61e 59520943 DC 26494 f 8941 b

当黑客拥有这个散列时，他可以只使用一个网站或一些特定的程序，该程序将测试数据库中是否有这个散列，并返回生成它的值。比如说[http://md5decrypt.net/en/Sha1/#answer](http://md5decrypt.net/en/Sha1/#answer)

[![](../Images/d1c9bf9675271edb7c05399e10cb5e60.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--knPclWs7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2AERrzhfm0bYdNmA7nNIzgUQ.png)

最常用的 100 个密码的列表可能已经存在于所有可能的散列库中，因此存在使用越来越难的密码来使这些散列库变得困难的活动。但是即使有这些问题，用户也不希望有使用更复杂密码的问题，所以作为一个开发者，了解这些攻击，解决这个问题的最佳方案是什么？在你的杂烩里多放些“盐”。

[![Alt Text](../Images/a72f5556fa318b95d5a41aab8d2402fd.png)T2】](https://i.giphy.com/media/12Oy8aAs0CbTgY/giphy.gif)

### [](#salt-and-security-deployments)盐与安全部署

salt 的概念是在密码中加入一些附加信息，以增加计算散列时的复杂性，例如:

[![](../Images/054aaa7d95811af2a08729752db1e432.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--RnTFeeew--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/934/1%2AbKVK5-5jmYo7N9QdQyFSHA.png)

在密码中加入附加信息会使创建查找表变得更加困难。

### [](#what-to-avoid-when-using-salt)用盐时要避免什么

#### [](#reuse-the-salt)重用盐

甚至是程序中的硬编码 salt，或者曾经是随机生成的。这是无效的，因为如果两个用户有相同的密码，他们将有相同的哈希。使用反向查找表攻击，可以通过简单地测试 salt 的可能性来实施暴力攻击，一旦发现 salt，您的所有密码都是易受攻击的。

#### [](#using-short-salt)使用短盐

如果 salt 太短，攻击者可以为所有可能的 salt 建立一个查找表。例如，如果您使用三个 ASCII 字符，那么您只有 857，375 种可能的盐。对于计算而言，这并不算多，如果每个查找表只包含 1MB 最常见的密码，则生成它们将需要 837GB，并且现在已经有 50 美元的 1TB 硬盘，与系统的损坏相比，这是非常便宜的投资。

#### [](#use-username-as-salt)用用户名当盐

虽然它们在系统中应该是唯一的，但通常会被其他服务中的其他帐户使用。攻击者可以建立用户-密码关系，创建查找表，并破坏以用户名为盐的哈希。

为了在计算上不可能为每个可能的 salt 创建查找表，salt 应该很长。一个好的规则是使用与哈希函数输出大小相同的 salt，SHA-256 输出是 256 位(32 字节)，因此 salt 应该至少有 32 个随机数。

认识到盐不必是一个秘密，它应该只是帮助避免我列出的攻击。我特别喜欢使用密码更改时间的时间戳散列，所以我保留所有的属性，并使用我定义的格式的日期，这使得生成查找表的任务更加困难。