# 一些哈斯克尔，英语

> 原文:[https://dev.to/deciduously/some-haskell-englishd-cd9](https://dev.to/deciduously/some-haskell-englishd-cd9)

# 有些 Haskell，英文的

一场没有荣誉和人性的比赛

## 介绍

哈斯克尔没那么坏。可怕的是，与你习惯的工作环境相比，它是多么的不同，所以一开始你会碰到更多的障碍。这篇文章是对一个程序的深入探究，这个程序写起来很琐碎，但却是必要的，目的是揭开你如何在一个不熟悉的范例中构建问题的神秘面纱。

与我们一步一步构建程序的传统教程相反，这是一个自上而下的过程，让我们看看这里有什么交易。我将从`main`开始，它是你执行程序时运行的第一件事，我将在调用代码时遍历每一行代码，并解释发生了什么。因此，这与其说是编写 Haskell，不如说是阅读 Haskell 的一个练习，但是这两种技能并不是不相关的，希望这能有助于揭开如何做一些自己的简单任务的神秘面纱，并且感觉更有能力处理更大的 Haskell 示例。

### 你

哈斯克尔-好奇。这是在假定对命令式语言编程有基本理解的情况下编写的，但是没有 Haskell 或函数式编程知识。如果你认为你可以用你选择的语言实现这个程序，你就可以开始了。我将尽可能彻底地解释为什么事情会是现在这个样子。如果你是编程新手，而下面的程序*看起来不像是你知道如何制作的东西，你仍然应该能够跟着我做，尽管需要更多的努力！你可能需要做一些额外的研究。如果你不是函数式编程的新手，但对 Haskell 很熟悉，可能有几个标题你可以跳过。*

如果还不清楚的话，就 Haskell 而言，这是相当入门的东西。如果您已经精通基础知识，那么阅读它可能会很有趣，只是想看看您会有什么不同，但是这个实现可能不会让您大吃一惊，事实上，我想看看您的实现！

### 我

不是 Haskell 程序员。我写了一部分让自己重新振作起来，这个特别的程序是我在一年半前学习它的一点点时间里做的最大的事情...你知道，为了完全公开。总的来说，我不是专家——再读一遍这个旧代码，并充分解释它是一个教育练习。第一次写这篇文章和现在写这篇文章都教会了我很多关于 Haskell 的东西，所以希望它也能教会其他初学者一些关于 Haskell 的东西！我认为 Haskell 真的很酷，我希望更多的初学者使用它，不管你的大部分工作集中在什么其他语言上。这是一个不古板但(过度？)彻底的方式来看一个你以前可能在更熟悉的地方写过的小程序。

虽然我不认为我对这里的任何内容都不满意，但如果任何 Haskell(或其他)程序员注意到一些异常的事情，请在[ben@deciduously.com](mailto:ben@deciduously.com)告诉我。

如果我已经完全让你不再继续阅读那篇令人印象深刻的简历，这是一种乐趣。祝你愉快！

至于勇敢的剩余者，我认为这将是一个好时机。你至少会学到一件事，也许两件事。你知道，很干净的乐趣。瓦蒙诺斯！

### 程序

这是一个非常简单的井字游戏，在命令行上玩，对手是随机玩的电脑。好玩吧。几个小时，如果不是几天的娱乐等待幸运的用户。像这样的项目通常是我在一门新语言中的“hello world ”,因为最终它证明了你至少可以利用这门语言的各种功能，比如控制流和 IO。对哈斯克尔来说，这更像是一个“TTFN，世界”，但这一点仍然有效。

完整的源代码可以在这里找到[，完整的源代码将在下面的代码片段中出现。](https://github.com/deciduously/tictactoe-hs/blob/master/src/Main.hs)

如果你想在本地构建代码，你需要安装`stack`。参见 [stack docs](https://docs.haskellstack.org/en/stable/README/) 获取安装说明——如果你打算继续探索 Haskell，你会需要这个工具。它将自动管理您的 GHC 安装和软件包依赖性。

一旦你准备好了，你就可以在项目目录中打开一个终端(克隆[这个 repo](https://github.com/deciduously/tictactoe-hs) )并运行`stack setup`来安装编译器和依赖项，然后用`stack exec ttt`来编译并运行可执行文件，或者用`stack ghci`来打开一个 REPL，在这里你可以直接与定义的函数交互(包括`main`)。我推荐 REPL，因为这样你也可以在你喜欢的任何输入上尝试每个单独的功能。如果你调整`src/Main.hs`，你可以在提示符下键入`:r`来重新编译并加载新版本(或者被吼一会儿，取决于你怎么做)。使用`:q`退出。

这里有一个示例游戏，是从 REPL 执行的:

```
*Main> main
 1  2  3
 4  5  6
 7  8  9

Your move: 2
Computer plays 9
 1  X  3
 4  5  6
 7  8  O

Your move: 1
Computer plays 8
 X  X  3
 4  5  6
 7  O  O

Your move: 6
Computer plays 3
 X  X  O
 4  5  X
 7  O  O

Your move: 37
Only one digit allowed!
 X  X  O
 4  5  X
 7  O  O

Your move: 4
Computer plays 5
 X  X  O
 X  O  X
 7  O  O

Your move: 7
 X  X  O
 X  O  X
 X  O  O

Human won!
*** Exception: ExitSuccess
*Main> 
```

Enter fullscreen mode Exit fullscreen mode

去死吧，随机数发生器。

## 好东西

### 第一步

Haskell 程序被组织成模块。如果你来自一个面向对象的世界，它不太类似于一个类——它更像是一种描述名称空间的方式。通过这种方式，你确实封装了功能，但是不像一个类作为一个对象的“蓝图”那样严格。每个模块都由像函数和类型这样的“实体”组成，它们可以被导入到其他模块中使用。

打开 Main.hs 我们看到以下声明:

```
module Main where

import           Control.Monad (forever, when)
import           Data.Bool     (bool)
import           Data.Char     (digitToInt)
import           Data.List     (isSubsequenceOf)
import           Data.Maybe    (isJust, isNothing)
import           System.Exit   (exitSuccess)
import           System.IO     (hFlush, stdout)
import           System.Random (randomRIO) 
```

Enter fullscreen mode Exit fullscreen mode

模块是第一个术语，后面是我们要导入的函数。这个程序只有一个模块，但如果有更多的主要将是一个明智的地方开始寻找我们的程序入口。这里列出的所有其他模块都可以在 Haskell 的标准库中找到，当我们在演练中使用它们时，我将依次讨论每个模块。模块名是第一部分，我们使用的模块的具体导入在 parens 中单独列出。

我在 import 语句下看到了一些类型声明，但是我并不真正理解什么需要建模，所以我将浏览一下，看看当你执行这个时，哪个实际的函数被首先调用(我在简介中承诺过我会这样做)。在命令式语言中，任务是编写一个子程序，一步一步地告诉计算机如何执行井字游戏。在 Haskell 中，一切都是纯粹的数学变换。我们的任务是定义一个值，以便在它解决的时候，对它进行评估。我们不是如何一步一步地得到最终结果，而是定义最终结果是什么，如果函数式编程对您来说是新的，这涉及到一点心理扭曲——特别是因为基于 turn、面向 IO 的程序本质上有一些必要的部分！在`Main.hs`中，这个值也被称为`main`，位于文件的底部。

不过，在我们深入研究代码之前，行`main :: IO ()`本身有一些解包工作要做。

在 Haskell 中，每个值都有一个类型。函数之所以重要，是因为它们的计算结果是值。编译器不需要担心意外的突变和副作用，所以每个函数都可以被简单地视为与其返回值等价，这比在命令式语言中要多得多。Haskell 对类型的要求也很严格，如果像 Java、C#或 C++这样的语言是你曾经使用过的最重的类型系统，你可能从来没有遇到过这种情况。编译器实际上很神奇(不，真的，*神奇*)并且不需要注释——对于模块中的顶级函数来说，这被认为是很好的风格，但是对于内部值来说，它们可以省略。然而，如果你开始陷入编译错误，它们会给你很大的帮助！类型注释首先是值的名称，接着是双冒号`::`，再接着是类型，你会在 Haskell 代码中看到它们。

我们的主值有类型`IO ()`。我们立刻尝到了一些时髦的新鲜 Haskell 的怪异之处。我们有像`Int`这样的普通类型，但这个`IO ()`是我们第一次暗示这些类型被设置为“最酷”。在我们谈论这个`IO ()` *事件*的逻辑之前，我们必须弄清楚它到底是什么。

#### 场景设置:`IO ()`

我要先说，如果你已经听到了关于远离单子的好建议，我不会写一篇关于单子的博文。我确实需要至少谈一点它们(我们可以保持在 30，000 英尺，但有一两个就在那里)，它们真的一点也不可怕。这是超级简单的试唱，它只是一个试唱，因为我觉得在“超级简单”之后听起来不错。

木卫一是单子。在 Haskell 中，Monad 是一种设计模式，它允许我们将一些严格遵守一组规则的高阶功能注入到更简单的类型中，以便以比纯函数模型更大的灵活性来组合它们。我会在下面解开这个。这种模式不是 Haskell 特有的，但是 Haskell 编译器能够在编译时为我们验证这些“单子定律”,因为它有强大的 typeclass 系统，并且附带了许多用于各种有用类型的内置实例——尽管您完全可以在任何语言中使用泛型编程工具来近似这种模式。我稍后会更多地讨论什么是类型类和实例——要知道，Haskell 有一个“类型类别”的概念，它可以强制执行，其中一个类别是“单子”。我们这里的整个程序是类型`IO ()`，这是一个单子。

正如我们所说的，Haskell 是一种函数式编程语言，它实际上是一种相当宽泛的语言类别，强调一种以函数为基本计算单位的编程风格。在 Haskell 中，由于要求每个函数都是纯函数，这一点受到了进一步的限制。如果你不熟悉术语“纯”是指函数不依赖或作用于自身以外的值。换句话说，对于给定的输入，函数将总是返回相同的输出，因为输出不依赖于其他任何东西，并且可以保证在运行过程中，除了它本身之外，没有任何东西会改变。整个计算结果 100%由参数本身决定。

这里有一个 JavaScript 的小例子:

```
var impureIncrementAll = function(nums) {
  const len = nums.length
  for (var i = 0; i < len; i++) {
    nums[i] += 1;
  }
  return nums
}

var pureIncrementAll = function(nums) {
  const len = nums.length
  var ret = []
  for (var i = 0; i < len; i++) {
    ret[i] = nums[i] + 1
  }
  return ret
}

var a = [1, 2, 3]

impureIncrementAll(a)

console.log(a) /* [2, 3, 4] */

a = [1, 2, 3]

var b = pureIncrementAll(a)

console.log(a) /* [1, 2, 3] */
console.log(b) /* [2, 3, 4] */ 
```

Enter fullscreen mode Exit fullscreen mode

如果你只是调用`pureIncrement(a)`而没有引入`b`值来获取结果，什么都不会发生——函数仍然会执行，这不是一个空操作，但是结果会被丢弃而`a`保持不变。

Haskell 没有类似`impureIncrementAll`的东西。你不能这么做。这个“函数”的定义更接近于数学上的“T2”概念。在大多数命令式语言中，我们所说的“函数”更准确地说是“子程序”，它可能有效，也可能无效。哈斯克尔没有这些。你们中的聪明人可能已经在问“但是等等！一个函数可能想在自身之外做各种各样的事情。把一封信打印到屏幕上或者回复任何外部输入怎么样？”对此哈斯克尔说“哦，该死。我们没有想到这一点。收拾一下！”大家好帖子。

...哈！Monads 方便地允许 Haskell 通过包装丑陋但必要的效果(比如使用`stdout`)并以一种纯功能的方式划分它们，来绕过实际上必须有用的这个小技术问题。我把这种特殊类型理解为“IO 单元”。第一部分意味着它是 IO 类型的，所以它用 IO(输入/输出)做一些事情。但是我们需要知道这个单子返回什么类型，以便我们可以在我们的类型化函数程序中使用它(剧透一下:特别是在其他单子中。)像 main 这样的 IO 单子会在它的主体中用 IO 做一些事情，但也会在你的纯函数式程序的上下文中计算出(`return` s)一些东西。单子是封装这种想法的一种方式——无论它做什么 IO 都会发生在它里面，然后你得到第二种类型，仍然包装成一个`IO something`。单子可以被认为是“动作”或“计算”这不是行动本身，这只是执行该行动的概念。这是一个彻头彻尾的名词，只是一个我们可以在程序中传递的“东西”(不是函数，虽然函数可以返回单子)，但一开始肯定有点奇怪。单子被证明是一个伟大的方式来组成功能，而不牺牲甜蜜，俏皮的纯度。我们所有的`console.log()`等价代码都将整齐地放在一个标记为 so 的类型中，并使用它来包含它的有效性，而不是覆盖所有内容，这将打破真正很好的保证，即像`a`这样无辜的值永远不会在你最不期望的时候被对`impureIncrementAll`的流氓调用随意改变。

那可能不适合你。一个可能的原因是，这是一个赤裸裸的谎言，或者至少是一个严重的过度简化。我能听到你说，你不能就这样挥挥手，不管怎样，在 IO 单子里让我们写看似不纯的代码。请拿好你的烂番茄。单子结构允许我们以一种非常方便的方式将程序之外的世界联系起来，并传递出去。在 Haskell 中建立这种工作方式是一个很酷的练习，也完全超出了本教程的范围。最好是留给那些更了解他们在谈论什么的人，而不是在需要知道的基础上利用一元 IO。在这里，我们用它来标记程序中执行 IO 的每一个部分——它帮助我把那个`IO`部分想象成你的函数的一种幻影参数，你不能用它来表示我们的 Haskell 程序之外的整个世界。外部世界被传递到你的函数中，这样你就可以安全地执行它，然后当你完成管道的下一步时，它会以新的形式整齐地传递出去。这不完全是怎么回事，但也不是完全不一样！这种模式允许我们保持我们的“该函数的结果 100%由参数本身决定”的约束，并且仍然与用户交互，同时仍然编写干净、易于遵循的代码。

单子的用途远远不止包含 IO 效果，但是对于我们在这个程序中的使用来说，IO 单子是“做输入和/或输出”的类型(有点令人困惑),当它完成时，它将产生一个东西。它产生的类型是第二项。对于 main，我们什么都没有，所以我们返回一些`()`类型的东西，空元组(类型`()`只有一个可能的值，就是`()`——空元组本身)。把它们放在一起，我们就有了我们的类型`IO ()`。这类似于 C/C++中的`void`，或者，嗯，一堆不同语言中的`unit`或`()`。一无所获。

顺便提一下，`IO ()`本身不做任何事情，除非它在`main`内部被执行！这是让它做点什么的唯一方法。

对于一个优越的，但仍然闪电般的速度单子(等。)使用流程图[这篇博文](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)将让你以惊人的速度了解《T2》“搜索算法”的作者。Haskell wiki 也有许多优秀的文章深入探讨了 IO，特别是更一般的 Haskell 类型理论的优点。

这是完全正常的，没有什么意义——现在还不需要。单子真的一点也不复杂，并且在各种语言中随处可见，但是学习如何用单子编程的方法是坐下来用单子写一些代码——无论读多少书也不能给你你所需要的本能理解。众所周知，它们很难描述，我向你保证，你不只是一个远离理解它的类比。写点代码！记住这一点，让我们回到棕熊队。

### 回到 Grizz

还不算太糟，对吧？或者可能是，在我写这篇文章的时候，我还没有任何一类观众的回应机制。让我知道。我已经后悔说了“棕熊”，没必要再提了。这不是一个真正的词，我知道我真的很喜欢它。对不起

不管怎样，让我们回头看看`main :: IO ()` :

```
-- line 93
main :: IO ()
main = do
  let board = freshBoard
  runGame board 
```

Enter fullscreen mode Exit fullscreen mode

根据类型，我们知道它将执行 IO，不会给我们任何反馈。该死的主，偶尔拉一点重量，是吧？

`main`的定义直接在类型声明的下面。为了再次证明这一点，我不称它为函数。它不像在 C:
中那样是一个

```
int main() { return 0; } 
```

Enter fullscreen mode Exit fullscreen mode

这个 C 代码片段定义了一个返回 int 的函数。在我们的 Haskell 程序中，没有函数调用——它只是一个`IO ()`——一个 IO 动作。一个名词，而不是一个动词——一个执行一些 IO 来解析它的最终值的东西。类似于如果你定义一个绑定`let a = 2`，在 REPL 输入`a`将会返回值 2，输入`main`将会返回值“玩井字游戏的动作”，这需要用户交互来解决。这是一个奇怪但重要的区别。

我们可以看出这是一个简单的值，因为该类型中没有箭头`->`。所有的函数都是从一种类型到另一种(或更多)类型的映射，就像`Int -> Int`对应于`int double(int x) { return x * x; }`或`Int -> ()`，就像 C 语言的直接翻译会产生- `()`很像`void`。Main 只是执行我们的 IO，并有()来显示它。

在这一点上，我注意到 Haskell 与 Python 相似，它的作用域是由语义空格分隔的。我没有触及这个选择的利弊，事情就是这样。任何缩进都在父范围内。我们主要打算`do`做几件事情。

#### 继续你的序列`do`

实际上是一些单音节爵士乐的语法糖，所以就像我的第一个题外话一样，这不是一个完整的解释，而是一种味道——仅仅足够继续前进。我们可以在任何 monad 中使用这种结构，它让我们“假装”一种命令式的编程风格。你可能已经注意到 main 看起来并不像你认为的函数式程序应该做的那样，做一些事情，然后做一些命令式的事情。我们应该在这个超级纯数学的函数计算世界里工作，而不是别的！这不是函数式程序的工作方式，它应该只是组合其他函数的结果。

事实上，我们仍然是。`do`是一个语法糖，它允许你用`(>>)`/‘then’操作符将单子链接在一起，这是单子特有的(就像在中一样，它是在`Monad`类型类中定义的，所以所有单子都保证可以使用它)。纯类型和强类型，就像 GHC(我们神奇的编译器)要求的那样。当我们在计算过程中通过几个连续的 IO 操作传递“外部世界的幻影”参数时，do 符号只是帮助它看起来更干净，更容易理解。

要点是，如果你在像`main :: IO ()`这样的单子中，你通常可以使用`do`顺序地做一些单子的事情(比如 IO ),这对于 Haskell 来说是没问题的。举例来说，这就是允许单子根据内容对输入做出响应的原因。在 do 块中，我调用的两个对象也是 IO 单子。main 的总价值，即运行可执行文件的结果，依赖于一些外部输入来计算，它需要根据接收到的任何输入做出响应。

咻。另一个象征，另一段论述。那么，我们在谈什么？第一个陈述是我最后没有一整段讲述的。通过行`let board = freshBoard`，我们创建了一个名板的绑定，并给它赋值`freshBoard`。你问`freshBoard`是什么？为什么，当然是 Main.hs 的 27 和 28 行！

### 离开`main`

```
-- line 27
freshBoard :: Board
freshBoard = Board $ replicate 9 Nothing 
```

Enter fullscreen mode Exit fullscreen mode

好的，`freshBoard`有类型`Board`。在不知道`Board`一般长什么样的情况下，我甚至不想知道这些坏男孩中的一个是什么样的，所以现在让我们回到顶部，看看我定义了什么类型。

```
-- line 12
newtype Board = Board [Maybe Player]
data Player = Human | Computer deriving (Eq, Show) 
```

Enter fullscreen mode Exit fullscreen mode

现在你知道了。一个`Board`是一个`[Maybe Player]`的容器。`Maybe Player`周围的括号表示这是一个`Maybe Player.`列表。很明显，对吧？开玩笑的，我来说说。

首先熟悉一下`Player`是有意义的，因为我们在`Board`的定义中使用了它。这是一个联合类型，类似于枚举。如果你从未处理过这些数据，那么它只是一点数据，要么是一个`Human`，要么是一个`Computer`，仅此而已。我们已经为它自动派生了*类型类* `Eq`和`Show`，让我们比较`Players`是否相等，即判断`Human == Human`是否相等，并将它们原样显示到控制台。过一会儿我会回来上打字课，它们很整洁。所以我们知道，在任何需要类型为 `Player`的*值的地方，类型为*的值*要么是`Human`要么是`Computer`——不可能有其他值。*

A `Maybe`是有用的类型(剧透预警，又一个单子！)允许您将 nullablillity 的概念编码到类型系统中，而不是作为一个可以随意使用的`null`值。类似的概念也出现在其他语言中，如 Rust 和 Swift(OCaml、Scala、F#和 SML、Elm 等——这不是一个新的或 Haskell 特有的概念，这是这里的重点),如果您选择的语言没有附带它，您可能可以自己手工创建一个，尽管可能没有我们在这里得到的一些编译时属性检查。一个`Maybe`既可以是一个`Nothing`的值，也可以是一个`Just <something>`，在我们的例子中是一个来自类型的`Player`。`Maybe Player`实际上也是一个类型- `Maybe`是一个*更高级的类型*，这意味着它必须用一个类型参数化，然后才能在你的程序上下文中使用。将所有这些放在一起，这些`Maybe Player`的列表可能看起来像下面这样:

```
[Nothing, Just Human, Nothing, Just Computer, Nothing, Just Human, ...] 
```

Enter fullscreen mode Exit fullscreen mode

尽管每个单元格有三个不同的可能值，但类型`Maybe Player`简明地表达了这三个值，并且只表达了这三个值。这个约束现在已经在编译时检查过了，不需要样板文件。

更高级类型中的单词`kind`是指该类型需要多少层*参数化。没有类型参数，`Maybe`根本不是一个完整的、可用的类型——每个`Maybe`都将携带一个特定的类型。`Maybe`有*种* `* -> *`，意为从某物到某物的映射。当`Player`是这样的东西时，它就变成了完全解析的类型`Maybe Player`和*种类* `*`，可以在其他函数中完全求值。*

还记得之前我称编译器为魔术吗？它走得更远...`Either`是*类* `* -> * -> *`采用两个类型级参数，通过只提供一个参数来创建可定制的(部分应用的)类型！例如，`Either Player`是一个部分解析的类型，仍然有种类`* -> *`，只有通过指定另一个类型，例如`Either Player Int`，你才有一个完全解析的`Either`，这类似于 a Maybe 意味着你要么有一个`Nothing`要么有一个`Just <sometype>`，你要么有一个值`Left Player`或`Right Int`。这个`Either`类型是管理编码到类型中的错误处理的一种简洁方式。

超级有趣的是，这些更高级的类型像*类型级函数*一样工作。用 Java 试试。我们还用过什么类型像这样的？为什么，我们的新朋友当然是木卫一了！它可以是一个`IO ()`或一个`IO Int`或你喜欢的任何东西，但它仍然是一个 IO 单子，带有种类`* -> *`，直到它被进一步指定。原来`Maybe`是*也是*一个单子，但是我们没有将可怕的易变外部世界上下文化，而是将可空性上下文化。单子性将允许我们对被包含的类型进行操作，同时仍然确保无论如何我们都将它保持在一个`Maybe`中。然而，也有更高级的类型不是单子叶植物。这是很酷的东西，但对这个程序来说一点也不重要。

好了，至少有了这些知识，我们可以看看`Board $ replicate 9 nothing`。这很好也很简洁，尽管它看起来有点像咒语，但它听起来很简单，读起来几乎像英语。这几乎就像是在读一个句子，或者至少是伪代码。在继续之前，你会想了解一下`$`——这只是具有不同优先级/结合性规则的函数应用。它的`Board(replicate 9 nothing)`。乍一看，这似乎是多余的，但是低优先级和右结合性允许您省略 paren:`f $ g $ h x = f (g (h x))`。它看起来很时髦，但如果我回忆起来，它很快就变得很自然。系好安全带，因为下面还有一点象征性的汤。Haskell 对于深奥的操作符并不避讳。

分开并不难。函数应用在 Haskell 中只是通过空格(毕竟是面向函数的语言)，所以我们用参数`9`和`Nothing`调用`replicate`，而不是`replicate(9, Nothing)`。而`Board`想要一个`Maybe Player`的列表。`replicate` makes 使用第一个参数来决定要制作多少个第二个的“副本”，并将它们作为一个列表返回。也就是我们所说的一个`Board`举行。好的，酷，所以一个`freshBoard`是一个`Board`有九个单元格，而*可以*保存一个`Player`但目前不能:

```
freshBoard = [Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing] 
```

Enter fullscreen mode Exit fullscreen mode

我们可以简单地编写上面的代码，但是使用`replicate`我们只需要更少的击键就可以实现。这就是应用程序的整个数据结构。

太好了！概括一下，我们现在已经存储了 9 个单元格的`Board`，它们可能包含一个`Human`或一个`Computer`，但目前是空的。我们接着去`main`的*三线*怎么样？

### 第三行`main`

现在我们用煤气做饭了！我们的`freshBoard`已经准备好了一些杀手锏。下一行是一个简单的函数调用，读起来很简单。我们将把我们的新板传递给`runGame`函数。那看起来像什么？

```
-- line 75
runGame :: Board -> IO ()
runGame board = forever $ do
  gameOver board
  print board
  putStr "Your move: "
  hFlush stdout
  n <- getLine
  case n of
    [c] ->
      if [c] `elem` map show [(1::Integer)..9]
      then do
          let n' = digitToInt c
          if openCell board n'
          then handleInput board n' >>= compTurn >>= runGame
          else putStrLn "That's taken!"
      else putStrLn "1-9 only please"
    _   -> putStrLn "Only one digit allowed!" 
```

Enter fullscreen mode Exit fullscreen mode

那是一个笨重的。让我们一步一步来。首先，类型本身现在应该看起来足够熟悉了。`runGame`是一个`Board -> IO ()`也就是说一个函数接受一个`Board`并返回一个 IO 单子携带单元，或者什么也不返回，就像`main`一样。我们知道这是一个函数，因为有了`->`——它是一个事物到另一个事物的映射。

深入到定义中，我们看到我们将定义另一个`do`块，但是它将被包装在`forever`中。我们已经知道`$`操作符只是常规的旧函数应用程序，所以在我们的定义中它之后的所有东西都在`forever`内部。回到文件的顶部，你可以看到我们从`Control.Monad`模块中引入了它，所以，你猜对了，它是一个单子。幸运的是这个很简单——它只是意味着我们想永远执行这个单子。我打赌你已经明白了。

那么这个函数里面有什么呢？下一行立即调用另一个名为`gameOver`的函数，并传递给它 board，它现在是新的。我们来看看`gameOver` :

```
-- line 68
gameOver :: Board -> IO ()
gameOver board@(Board b) =
  when ( all isJust b) $ do
    print board
    putStrLn "Draw!"
    exitSuccess 
```

Enter fullscreen mode Exit fullscreen mode

嗯，这种类型的签名应该越来越重复。这是另一个需要一个`Board`，做一些 IO，并且不传递任何东西给调用者的函数。第二行中的 token soup 只是在解构语法。我们的`Board`是唯一的参数，而`board@(Board b)`所做的就是允许我们将整个结构称为`board`(类型为`Board`)以及将内部单元格列表称为`b`(类型为`[Maybe Player]`)。

这个函数的主体很容易理解。我们要去做一些事情。`when`是我们从`Control.Monad`中引入的另一个东西，但是它也不可怕，并且做了你所期望的事情——检查谓词，如果为真就进入块。请记住，九个单元格中的每一个都是一种类型的`Maybe Player`，一个`Maybe a`可以是`Just a`或`Nothing`，使用`a`作为任何类型的替身。`isJust`是来自`Data.Maybe`的助手谓词(导入的，像一瓶好酒)，如果传入的是`Maybe`的`Just`变种，则返回 true。我们把它和我们的单元格列表`b`一起传递给`all`，这就像一个大 ol' `AND` / `&&` -它第一次命中 false 时返回 false，或者整个表达式为 true。

总而言之，当每个单元格中都有一个玩家时，`gameOver`会注意到是时候打包并结束游戏了。具体来说，它会显示带有`print`的棋盘(详情如下)，并告诉你该游戏与`putStrLn`打平。这些只在 IO 单子中起作用，两者都是类型`String -> IO ()`,现在我终于可以在我们开始看代码之前证明所有这些单子的合理性了！那是一些不错的老式输出。记住`do`正在秘密地用一个`then/(>>)`链接它的孩子，这最终看起来很像你的花园品种命令，不纯的东西，但从来没有违反任何 Haskell 规则这样做。这完全是一个巨大的 IO 单子，由调用这些函数的内部结果构建而成，这些函数本身返回 IO 单子，使其全部工作。这就是为什么`main`也必须是 IO monad，即使它没有显式地执行任何 IO——它是从调用执行 IO 的函数的函数构建的。当打印结束时，我们只需`exitSuccess`，用状态码 0 终止程序。

在潜入并试图进行回合之前，确保棋盘上仍有游戏可玩。如果我们完成了，整个过程就结束了，如果没有，这个函数什么也不做也不返回，所以`runGame`可以继续。我们刚刚开始我们的旅程，所以当我们经过`Board`时，它的`all`绝对不是`isJust`。事实上，当我们到达第一个单元格时，这个谓词返回了一个`false`。继续，游戏循环的运行看起来像什么？

首先，看起来我们已经解决了。太棒了。但是等等！慢点。编译器如何知道一个`Board`应该是什么样子？我们自己创造了那种类型(这是你以前承诺的细节！)在 Haskell 中,“可打印性”被表示为一个名为`Show`的*类型类*。我们一直在使用 typeclasses 它们(对我来说)是学习 Haskell 的首要目的。

#### 题外话- Typeclasses:类型，同类

我知道我说过我不会做太多，但这很有趣也很快。我们已经知道`Maybe`是更高级的类型，特别是*类* `* -> *`，这意味着它是那些花哨的类型级函数之一——那些星号代表任何类型。该语法用于描述类型的种类。我们没有提到的是`Maybe`是几个有用的类型类的成员，比如`Eq`、`Show`和`Monad`。这些适用于特定的类型，如`Int`或`Maybe`，并定义了它们在某些情况下会发生什么，正如我们在上面定义`Player`类型时看到的，在某些情况下可以自动派生。你可以认为它们和面向对象环境中的接口没有什么不同，但是它们不仅仅是接口。编译器附带了许多已经为内置类型实现的方法，并且知道如何为我们为简单类型派生简单的方法。例如，当你想在屏幕上打印一个`7`时，你总是想简单地把这个数字写到 stdout。如果您想让它打印单词`seven`，您可以用这个逻辑实现一个自定义版本的`Show`。如果你问那个`7`是不是另一个`7`的`==`，有理由假设编译器可以告诉你，事实上，是。因此，类型`Int`准备好与`Eq`一起使用。在 REPL 中，你可以使用内置的`ghci`命令`:info <type>`来获取 type 实现的所有 typeclasses 的列表，以及它的定义位置:

```
Prelude> :info Int
data Int = GHC.Types.I# GHC.Prim.Int#   -- Defined in GHC.Types
instance Bounded Int -- Defined in GHC.Enum
instance Enum Int -- Defined in GHC.Enum
instance Eq Int -- Defined in GHC.Base
instance Integral Int -- Defined in GHC.Real
instance Num Int -- Defined in GHC.N… 
```

Enter fullscreen mode Exit fullscreen mode

正如所料，上面的第四行输出告诉我们，我们确实已经在`Int`类型上获得了一个`Eq`实例。

### `Show`我的钱

对于像`Player`这样的联合类型，我们可以告诉编译器假设我们只想打印出像`Human`或`Computer`这样的变量的名称。但是如果我们想做一些疯狂的事情，我们可以很容易地定义我们自己的`Show`实例，它有代码来操纵它。对于更复杂的类型，如`Board`，我们希望有这种控制。这里是我们对`Board`的`Show`的定义，`print :: IO ()`目前正在请求以进行评估。它与我们的其他定义一起定义:

```
-- line 15
instance Show Board where
  show (Board cs) = foldr spaceEachThird [].withIndicesFrom 1.fmap showCell $ withIndicesFrom 1 cs
    where spaceEachThird a = (++) (bool (snd a) (snd a ++ "\n") (fst a `rem` 3 == 0)) 
```

Enter fullscreen mode Exit fullscreen mode

哦不。这应该不错。或者可能很糟糕。让我们把这个分开。第一个列表只是说我们正在定义`Show`应该为`Board`做什么。所以每次调用者需要`Show`一个板(例如，用`show`这个函数，或者通过调用`putStr`间接调用)，它就会到这里来评估里面的内容。

要定义一个 typeclass 实例，您需要定义 typeclass 需要的函数。`Show`很容易定义——只有一个，`show a`,这里的`a`是`Board`。正如你所期望的，我们可以看到定义的左半部分是一致的:这个函数将`show (Board cs)`，所以如果我们传入我们的`Board` newtype `cs`将引用里面的单元格列表。

幸运的是，过去的 Ben 似乎已经打高尔夫球了，这个混蛋，这意味着采取一些格式良好，可读的代码，并把可读性拉出来，以节省字符。这里没有评论或任何东西。平心而论，我不认为过去的本期待现在的本(未来的本？)来写这篇文章，Haskell 给高尔夫带来了很多乐趣。没关系。第一个函数，`foldr`，让我知道我已经得到了什么。先说折叠。

我一直在谈论 Haskell 是如何*函数式*而不是*命令式*的——计算的单位是函数，你通过组合函数来构造计算。然而，我马上把那个`do`扔给你，它确实有点让你强制性地编码，但那仍然只是一个描述纯函数计算集的特殊语法。如果我们想对一系列事情执行相同的操作，我们将会遇到一个问题。这正是需要发生的，单子现在不会帮助我们。

在 C 风格的语言中，要解决将每个单元格打印到屏幕上的问题，你需要使用类似于`for`循环的东西来迭代单元格。在哈斯克尔没有这种东西。一个循环不是一个函数或者一个值，它们组成了我们的整个工具箱。但是我们还是要解决这个问题。幸运的是，Haskell 提供了一套丰富的工具，通过使用*递归*和`fold`操作来处理这类问题，这比手工编写要容易得多。

顺便说一下，这完全不是 Haskell 特有的。递归和折叠会出现在各种各样的地方，Haskell 恰好是熟悉如何构建它们的绝佳环境。

#### 题外话`foldr`

在主流语言中，折叠并不是一个不常见的概念——如果你已经对它们很熟悉了，可以跳过这一部分。如果不是，那么了解它们是如何工作的会有所帮助。

我们获取集合值并确保对集合的每个成员都做一些事情的方法是递归地使用集合。也就是说，我们将把整个集合传递给某种函数，它将进行某种处理。在函数的末尾，它会再次调用自己，用列表中的一小部分作为参数，这部分我们还没有通过函数处理。它会一次又一次地这样做，用集合中越来越小的部分来调用自己，直到整个事情都被处理完。很简单。`fold`是一种特定类型的递归函数，它接受一个数据结构、某种类型的集合和用于每个成员的函数——特别是每次迭代中集合的第一个元素。在列表被完全清空后，它最终只产生一个值。如果你在 JavaScript 或 Python 等语言中遇到过，`reduce`操作是`fold`的一个特例。

我发现在 Haskell 中谈论类型比用英语更容易。下面是`foldr` :
的类型签名

```
foldr :: (a -> r -> r) -> r -> [a] -> r 
```

Enter fullscreen mode Exit fullscreen mode

如果你茫然地看着这个没关系，这通常是解开类型签名的第一步。不过，它们的工作方式都是一样的，所以我们可以自己走过去。我们知道这是一个带三个参数的函数，因为最终所有的值都是一个值——所以编译器在处理这个函数以到达最后的`r`时会期望三位信息。类型签名中的括号如您所料——第一部分被分组，表示它是一个类型为`a -> r -> r`的参数，而不是三个独立的参数。第二个未知类型通常用`b`表示——我用`r`表示它是我们的返回类型。如果你去网上查这个，你可能会看到一个`b`。什么类型不重要，什么都有可能。第二种类型的占位符甚至可以是另一个`a`，而且经常是这样，但是它没有*来保证函数的正确性，所以我们使用不同的字母。*

首先是我们的处理功能。这本身就是一个带有两个参数的函数。它接受我们的`[a]`的单个元素，或者一个`a`类型的列表，以及我们要返回的类型的一些值，并返回一个具有我们期望的返回类型的新值。当您传入我们的`Board`(类型为`Maybe Player`)的一个单元格时，该函数将返回下一个累积结果。下一个参数是返回类型单个实例——可以说是“目的地”。我们知道我们将从这个文件夹中得到一个单一的值，我们有一个函数，它获取一个单元格和我们当前的运行结果，并返回给我们新的结果，所以我们可以在下一次运行递归时删除这个单元格。不过，在第一次运行时，我们需要存放计算结果的地方，所以`foldr`要求一个容器作为类型`r`的第二个参数来应用结果。我们传入的这个初始值将在每次运行函数时被转换，并最终成为返回的值。

如果这些都太抽象了，这里有一个看起来更熟悉的简单例子——让我们将一些基本的添加内容合并到一个集合中:

```
nums :: [Int]
nums = [1, 2, 3, 4, 5]

addEmUp ns :: [a] -> r
addEmUp ns = foldr (+) 0 ns 
```

Enter fullscreen mode Exit fullscreen mode

那就少了很多噪音。在这个例子中，调用`addEmUp nums`将产生`15 :: Int`。首先，我定义了一个`[Int]`——一列`Int`——称为`nums`。然后我创建了一个函数`addEmUp`，它实际上是一个特定函数`fold`的别名——注意，它除了指定 fold 使用哪些参数之外，什么也不做。这就是为什么`addEmUp`的类型签名要简单得多——它只接受`[a]`集合，在本例中是`nums`。所以我们的`a`就是`Int`。第一个参数，处理器，是`(+)`——加法运算符。运算符是函数，这个函数接受两个值并产生第三个值。来对比一下我们预期的类型:`a -> r -> r`。在这种情况下,`a`是`Int`,我们希望在末尾有一个`Int`,所以我们也可以用那个类型替换`r`。如果你在一个`Int`上加一个`Int`，你瞧，一个`Int`就会弹出来。所以我们的处理器，加法，有类型`Int -> Int -> Int`，这符合！如果`a`和`r`或者任何两个未指明的类型相同，完全没问题，我们只是注意到它们没有*有*存在。

我们的第二个争论只是一个`0`——一个`Int`。我们刚刚决定这是一个完美的`r`类型，所以第二个参数作为我们返回类型的初始化器是有意义的。那就只剩下`[a]`了。谢天谢地，我们原封不动地保留了这部分类型，并把它作为参数传递给`addEmUp`！对于这个简单的例子，这个`foldr`的完全限定类型是:`(Int -> Int -> Int) -> Int -> [Int] -> Int`。就是一堆`Int`的。

当 Haskell 进行评估时，它将从完整的集合开始。当我们第一次运行时，处理器将获取第一个单元格，然后寻找我们的累计结果。我们还没有做任何事情，所以它只是`0`——我们在第二个论点中告诉它了。第一个值是`1`。我们的累加器加到我们的基值上就是`1`。然后，我们复发！只是这一次我们已经处理了一个，所以我们再次调用这个相同的函数，但只是在集合的其余部分，并使用我们新创建的`1`作为累加器，而不是基值`0` :

```
foldr (+) 0 [1, 2, 3, 4, 5]
foldr (+) 1 [2, 3, 4, 5] 
```

Enter fullscreen mode Exit fullscreen mode

看到那里发生了什么吗？我们处理了一个并丢弃了它，所以我们的收集变得更短，我们有一个运行总数。展开:

```
 foldr (+) 3 [3, 4, 5]
= foldr (+) 6 [4, 5]
= foldr (+) 10 [5]
= foldr (+) 15 []
= 15 
```

Enter fullscreen mode Exit fullscreen mode

当一个递归函数试图在一个空列表上递归时，它知道自己完成了，并返回最终值——在本例中是`15`。我们成功地实现了无循环迭代！相反，我们在`[1 + 2 + 3 + 4 + 5]`中加入了一个操作。这几乎就像我们用运算符从右到左一步一步地替换逗号一样。通过这种方式，我们能够一次又一次地重用同一个函数，同时只根据上一次运行的输出改变我们传入的内容。递归，哟。

如果这听起来非常低效，那么一直用非常相似的值调用一个又一个函数，是的。为了减少这种开销，Haskell 执行了一种叫做“[尾调用](https://en.wikipedia.org/wiki/Tail_call)优化”的东西，我在这里就不详细介绍了，但本质上是说，如果函数在“尾位置”递归，这意味着它是要执行的函数的最后一部分，而不是为每个后续调用分配一个新的堆栈帧，它能够重用同一个堆栈帧并替换新的 val，然后就像`GOTO`风格那样向上跳转执行。如果你不熟悉堆栈框架，我们已经超出了这篇文章的范围——这不是我们所需要的知识，但是总体来说很有趣，如果你想在 anger 中使用函数式语言，理解这一点很重要。在玩具程序中，优雅的函数式解决方案通常是好的，但是当你的应用程序扩展时，它会开始引起问题，允许更混合风格的语言通常会建议你在这一点上退回到更命令式的模式。根据经验，一个好的老式`for`循环在处理大量数据时会比使用`forEach`或类似工具的一行程序表现得更好——有时好几个数量级。在 Haskell 中，处理这些性能问题还涉及其他类型的模式，因为没有什么`for`循环可言。我建议你四处转转！

顺便说一句，这个例子可以重写:`addEmUp = foldr (+) 0` -如果参数是定义和参数列表中的最后一个术语，那么它可以被删除。这个过程在 lambda 微积分行话中被称为 [eta 缩减](https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B7-conversion)。相反，编译器将该定义视为一个期待多一个值的定制函数。如果用那个值调用它，它将完全评估表达式。

### `Show`必须走下去

这个题外话有点疯狂，但是现在我们已经准备好深入这个更大、更混乱的领域了。我们知道它会做与`addEmUp`相同的基本类型的事情。首先要寻找的是我们知道需要的三个元素:处理函数、用作累加器的初始值和要处理的集合。

最后一部分——收集——很简单。记住`$`是函数应用程序，我们知道我们要将这个文件夹应用到`withIndicesFrom 1 cs`。我们从自变量列表中知道`cs`是我们的单元格列表:`Board cs`。然后我们就调用一个助手函数:

```
-- line 19
withIndicesFrom :: Int -> [a] -> [(Int, a)]
withIndicesFrom n = zip [n..] 
```

Enter fullscreen mode Exit fullscreen mode

这只是给通用函数`zip`附加一个更特定领域的语义名称的别名。给定两个集合，`[a]`和`[b]`，`zip`返回一个集合`[(a, b)]` :

```
let listA = [1, 2, 3]
let listB = ["a", "b", "c"]
zip listA listB == [(1, "a"), (2, "b"), (3, "c")]
-- True 
```

Enter fullscreen mode Exit fullscreen mode

这个别名只是定义了要传递给`zip`的第一个术语。您可能注意到参数列表与我们的类型声明不匹配——我们期望两个参数，一个`Int`和一些列表，但是下面只有一个。这是我前面提到的“eta-reduction”的一个例子——第二个参数，也就是要压缩的列表，出现在参数列表和函数体的最后，所以我们把它从两者中去掉。详细说明的版本为:

```
withIndicesFrom :: Int -> [a] -> [(Int, a)]
withIndicesFrom n cs = zip [n..] cs 
```

Enter fullscreen mode Exit fullscreen mode

类型没有任何不同，所以如果您感到困惑，请始终查找类型。他们会告诉你发生了什么。

我们使用参数来定义一个范围`[n..]`的开始，即`[n, n + 1, n + 2, n + 3, ...]`。来压缩，这将产生为列表中的每个元素附加一个索引的效果。仅此而已。

#### 关于懒惰的简短题外话

这个函数是 Haskell 的另一个超级酷的属性，我在这个程序中没有怎么使用过，但是它太简洁了，不能就这样被忽略掉。

你可能会注意到看似无害的表达式`[n..]`并没有指定一个上限值。我们所做的是，定义一个*无限列表*，从`n`开始，一直持续下去。

在大多数编程语言中，这显然是不行的。这个过程会丢弃所有其他的东西，构建这个无限列表，直到它溢出堆栈并崩溃，导致一个非常糟糕的游戏。嗯，至少更多的狗屎。另一方面，Haskell 使用了*懒惰的*评估语义。当编译器通过时，它完全满足于不去管那个`[n..]`(从技术上来说，它会把一切都预处理成[弱头范式](https://wiki.haskell.org/Weak_head_normal_form))，直到它需要开始扩展——即使这样，它也只在需要时扩展*。在`withIndicesFrom`的情况下，我们传递的参数将是有限的，如果你需要复习的话，比无限小。当我们到达集合的最后一个值并传递到`zip`时，我们就可以开始了——不需要继续钻取`[n..]`来寻找我们不会使用的索引。不管我们在哪里，哈斯克尔都置之不理，继续前进。*

 *这是一个非常不可思议的特性，它允许所有类型的模式，而这在严格求值语言中是不可能的，但是它确实有副作用，使得一些性能特征难以推理，就像递归一样。写 Haskell 的时候要牢记这是一件好事。

#### 恢复工作

回到代码上来！提醒一下，这里是我们的`show`定义的第一行:

```
-- line 16
show (Board cs) = foldr spaceEachThird [].withIndicesFrom 1.fmap showCell $ withIndicesFrom 1 cs 
```

Enter fullscreen mode Exit fullscreen mode

我们确实有一个折叠，但它是更大的*组合*功能的*最终*部分。Haskell 中的复合运算符是`.`。这个特殊的标本由三个不同的部分组成。写`a.b.c x`就像写`a(b(c(x)))`。噪音小多了。

我们的第一部分，`fmap showCell`，将对我们的单元格索引列表`[(0, Nothing), (1, Just Human), (2, Nothing)...]`中的每个单元格调用`showCell`，并返回结果。让我们看看`showCell` :

```
-- line 22
showCell :: (Int, Maybe Player) -> String
showCell (n, Nothing)         = " " ++ show n ++ " "
showCell (_, (Just Human))    = " X "
showCell (_, (Just Computer)) = " O " 
```

Enter fullscreen mode Exit fullscreen mode

编写这个函数是为了获取一个方便的预先索引的单元格，并将其简化为一个字符串。我们实际上定义了这个函数三次——第一次定义的参数模式与它被调用的方式相匹配。再说一次，很酷的东西！我尝试过的其他一些编程语言也可以实现这种语法，而且很容易被破坏。在这种情况下，任何给定的单元格只有三个可能的值，被定义为`Maybe Player`。我们对每一个都有单独的选择——如果还没有人玩过，我们就`show`索引，如果有玩家，我们就返回正确的角色。

这只是战斗的一部分！这给出了类似于`[" 1 ", " X ", " 3 ", " O ", ...]`的东西。我们的复合函数的第二部分再次调用我们的新朋友`withIndicesFrom`来保留我们的索引，所以我们回到了`[(1, " 1 "), (2, " X "), (3, " 3 "), (4, " O "), ...]`。

最后，我们到达最后一个外部函数:`foldr spaceEachThird []`。这整个部分是最后的外部功能。在类似 C 的语言中，我们可能会这样写:

```
foldr(spaceEachThird, [], withIndicesFrom(1, showCell(withIndicesFrom(1, cs)))) 
```

Enter fullscreen mode Exit fullscreen mode

这意味着，现在我们有我们的收集折叠-这是一切的结果，直到这里。我们的基本累加器就是`[]`——空单。缺失的那块是我们折进去的函数:

```
-- line 17
where spaceEachThird a = (++) (bool (snd a) (snd a ++ "\n") (fst a `rem` 3 == 0)) 
```

Enter fullscreen mode Exit fullscreen mode

`where`只是意味着我们只为这个函数局部定义了`spaceEachThird`——在这个上下文之外不需要它。我们本可以使用 Haskell 的匿名函数语法(`\x -> x + 1`)来内联定义它，但即使是我也肯定认为这太难阅读了，并把它分离出来。

`spaceEachThird`已被定义为采用单个参数`a`。在这种情况下,`a`将成为我们当前的单元格——很方便，它与我们一直使用的替代类型相匹配。我们知道处理器作用于两个输入值，因为它有类型`(a -> r -> r)`，另一个是我们的累加器，所以在我们的定义中，它看起来像是我们缺少了一个参数。那个“缺失”的参数就是累加器，它只是开头的`[]`。

定义的第一部分是`(++)`，或连接。对于我们的另一种类型有一个线索——我们将在一侧使用活动单元格`a`进行任何操作，它将被连接到累加器。这是有道理的——这有点像给累加器加上一个`Int`。累加器现在将保存来自两个操作数的信息。然而，我们到底要添加什么呢？

我从`Data.Bool`中抓取了`bool`函数，它实际上只是一些控制流。来自[胡戈](https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Bool.html) : `bool :: a -> a -> Bool -> a`。这只是用两个分支来表达一个`if`语句的一种简洁的方式，与其他一些语言中的三进制`?`的参数相反。你先给它两个可能的结果，第一个参数是`False`格，第二个是 if it`True`，后面是谓词。所以`spaceEachThird`只是测试最后一个参数，并使用`(++)`将中间的一个连接到累加器，如果检查通过，则连接第一个。放入伪 something-JS-like，`(is the index evenly divisible by 3?) ? "shove a newline on me\n" : "just keep me as is"`。这两个参数非常简单——`True`的例子只是在单元格的字符串中插入一个换行符`\n`,这是列表项中的第二个/ `snd`值。谓词也不难理解——反勾号将`rem`余数函数变成了中缀函数，我们使用`fst`来获取单元格的索引——每三个单元格都是如此，所以我们将开始一个新行。现在我们得到 9 个单元格的平面一维列表，并打印成 3 行 3 列。

### 采集输入

咻！那条线结果有点紧张。幸运的是，编程的美妙之处在于我们只需要告诉它一次如何做，对吗？下一步是询问玩家他们想去哪里玩。接下来的两行足够熟悉:

```
-- line 79
putStr "Your move: "
hFlush stdout 
```

Enter fullscreen mode Exit fullscreen mode

`putStr`将简单地将其输入发送到 stdout，并且`hFlush`在前进到下一条指令之前刷新 stdout 缓冲区(确保打印出完整的字符串)。

紧随其后的是`n <- getLine`。`getLine`等待 stdin，并在我们得到一个`\n`时返回内容，我们将它存储到一个本地绑定`n`。我们可以在我们的`do`块中这样做，这样传入的值就可供函数的其余部分使用。一旦用户输入一行文本并按下回车键，我们就继续。

现在我们到了`runGame`的大`case`语句。这是我们根据用户输入的内容适当选择动作的地方。这种控制流结构与其他语言中的`switch`没有任何不同——实际上，在表达能力方面更类似于`match`。我们将把刚刚从用户那里收到的值与一些模式进行匹配，看看如何处理它。

我们先从外层开始:

```
-- line 82
case n of
    [c] ->
      -- do some really awesome stuff with our single char
      -- ...
    _   -> putStrLn "Only one digit allowed!" 
```

Enter fullscreen mode Exit fullscreen mode

这个语法只是检查我们的输入`n`是否由单个字符组成。如果是的话，我们将保留它并做一些事情，如果不是的话，我们将用一个`putStrLn`调用来警告键盘上的白痴——这是一个包含尾随换行符的`putStr`。

模式匹配之所以有效，是因为 Haskell 考虑列表的方式。它们不是一个数组，而是被表示为一系列相互连接的元素(如果你已经 LISP 了，这是一个 cons 单元格)，在链的末尾有一个空列表——一些东西连接到一些东西的列表:

```
[1, 2, 3, 4, 5] == 1 : 2 : 3 : 4 : 5 : [] 
```

Enter fullscreen mode Exit fullscreen mode

这就是递归函数工作得如此好的原因——很容易拆开列表并检测基本情况，因为它们已经像引擎盖下那样被拆开了。在模式析构语法中，你可以用类似于`(x:xs)`的语法得到“头”(第一个元素)和“尾”(其他所有东西)。这里`x`是你的头(`1`)`xs`是其他一切(`[2, 3, 4, 5]`)。你可以用类似于`x:y:xs`的东西得到前两个，用`x:y:[]`匹配一个两元素列表等等。Haskell 中的所有列表都是这样工作的。

在这个例子中，我们使用的是`[c]`——没有`:cs`匹配尾巴。这意味着这个模式只匹配一个元素列表。

这是我们函数的最后一行——但是它都被包装在一个`forever`中，所以如果我们得到垃圾并对用户大喊大叫，我们将从`runGame`的顶部重新开始，直到用户给我们一些我们可以处理的东西。

如果用户遵从并只传入一个字符，我们还有一点工作要做:

```
-- line 84
if [c] `elem` map show [(1::Integer)..9]
then do
  -- We've got us a digit!  Do some awesome stuff with it
  -- ...
else putStrLn "1-9 only please" 
```

Enter fullscreen mode Exit fullscreen mode

Haskell 中的`if`的工作方式或多或少与你所期望的一样，它是一个*表达式*，而不是一个*语句*——也就是说，整个`if`块必须缩减为一个值。记住，`IO ()`类型的值也算——它只是一个“做一些 IO”类型的值，没有什么被传递回函数。这个构造的表达式性质的一个后果是，你不能有一个没有`else`的`if`来执行谓词 not pass。尽管如此，除此之外，这是意料之中的——你传入一个谓词，如果它的结果是`true`，我们将执行`then`块，如果不是，我们将使用`else`。如果你有两个以上的案例，我推荐`case`而不是`if`。

首先要检查的是，我们现在知道的这个角色是否是一个有效的剧本。它必须是一个从 1 到 9 的数字，而不是一个字母或一点标点符号或其他任何东西。第一行使用`elem`函数定义了这个谓词，该函数检查第一个操作数是否是第二个操作数的元素。Haskell 中的大多数函数都是以*为前缀*,即函数名在前，参数在后。要在两个操作数之间使用一个更像*中缀*操作符的双参数函数，可以像代码片段中那样用反斜线将它括起来。

这个谓词询问我们的 char 输入是否是一个从 1 到 9 的数字，并使用一个方便的小技巧来做到这一点。我们不能简单地问`"1" == 1`是不是因为一个是`String`一个是`Int`。首先我们需要得到一个有效字符的列表(`["1", "2", "3", "4", "5", "6", "7", "8", "9"]`)来进行比较。快速建立这个阵列的方法是我们的好朋友`show`。我们在课堂上看到了这个。这就是我们如何将一种字体转换成可以在屏幕上打印出来的东西。在整数的情况下，这意味着首先将它转换成字符串表示形式，然后发送到 stdout。我们可以对列表`[1..9]`执行`map`和`show`功能，它将为我们执行每个元素的转换。

### 函子？我几乎不认识她！

我还没用过`map`。你可能会在其他 Haskell 代码中看到`fmap`或`<$>`，它们的意思都是一样的——返回对集合中每个元素调用传入函数的结果——实际上，任何有 typeclass `Functor`实例的元素——如果你读过“Monads with Pictures”链接，你会很熟悉！函子是在将函数应用于其内容时保持其结构的东西——有一组“函子法则”,如“单子法则”,对于我们可以在这些类型上调用什么类型的函数以及它们将如何表现，有一组不同的保证。这是一个与“单子”相关的概念，你可以看出这只是范畴理论的冰山一角。

列表是函子，就像我们在这里`map` ping 的那个，我们的伙伴`Maybe`也是一个函子。考虑在`Maybe`上映射一个函数可能有点奇怪，但是你可以写:

```
couldBeAnInt1 :: Maybe Int
couldBeAnInt = Just 7

couldBeAnInt2 :: Maybe Int
couldBeAnInt = Nothing

couldBeALargerInt = fmap (+1) couldBeALargerInt1
-- Just 8

couldBeALargerInt = fmap (+1) couldBeALargerInt2
-- Nothing 
```

Enter fullscreen mode Exit fullscreen mode

因为`Maybe`是一个`Functor`，无论内容是什么，它都知道如何处理对它调用的函数，并且在将函数应用到任何元素后，它将在另一端保留其结构。真的，这和对一个列表做的没什么不同——它只会对 0 或 1 个对象应用函数。

了解这些类别的类型如何工作以及它们之间的关系是值得努力的——这是一个全新的抽象层次。如果您已经熟悉泛型编程的概念，您可能会看到它是如何扩展的，为它提供了更高层次的组织和分类。Haskell 是一个探索这一理论以及它如何与更健壮的现实世界应用程序代码相关联的优秀环境，没有什么可以阻止您将这一概念应用到日常工作中——尝试将 Maybe 函子编写为一个类，并使用它来代替`null`。不同之处在于，确保你的类遵守函子法则取决于你，而 Haskell 可以开箱即用地为你做到这一点。

总之，不像 folding，我们使用函数从集合中生成一个新值，这个函数在新的返回值中保持旧集合的形状不变。这也是很多语言中常见的功能工具。

我们使用范围操作符`..`来构建我们的列表，通过用具体类型`1::Integer`标记第一个元素，我们确保我们映射的每个元素`show`都是一个整数。

谓词不存在了，我们现在已经确定了存储在`n`中的输入是否是一个数字。我们的 else 语句看起来像前面一样——打印出一个快速错误，告诉用户他们到底有多蠢，就这样——回到`runGame`的顶部，希望这个笨蛋吸取了教训。但是，如果它是一个数字，我们就可以进入最后一个嵌套的`if` :

```
-- line 85
 then do
          let n' = digitToInt c
          if openCell board n'
          then handleInput board n' >>= compTurn >>= runGame
          else putStrLn "That's taken!" 
```

Enter fullscreen mode Exit fullscreen mode

我包含了顶部的`then`行，以表明我们打开了一个新的`do`块- `then do`不是一个特殊的语法，它只是一个`then`中的一个`do`。

首先，我们将输入`c`的整数版本保存为名为`n'`的新本地绑定。然后我们还有最后一个断言，在我们把游戏的移动推进棋盘之前，井字游戏的规则表明，你只能在一个空的方块上移动。不要在对方身上玩耍！我们用`openCell` :
来验证这一点

```
-- line 30
openCell :: Board -> Int -> Bool
openCell (Board b) n = isNothing $ b !! (n - 1) 
```

Enter fullscreen mode Exit fullscreen mode

这是一个函数，它接受两个参数，一个`Board`和一个整数，并像谓词一样返回一个布尔值。我们将传入完整的棋盘和一个特定的方块，`openCell`将告诉我们该空间是否已被占用。

由于 Haskell 的运营商恋情，这看起来比乍一看要复杂一些。我们之前见过`$`——是函数应用。另一个有趣的操作符是`!!`——这只是一个列表下标。在一种更像 C 语言的语言中，我们可能将这种精确的逻辑写成类似于`isNothing(b[n - 1])`的东西。也就是说，我们请求我们的内部板列表`b`的第`n - 1`个元素(在定义中通过析构来命名:`(Board b)`)，并将其传递给`isNothing`。`isNothing`我们在顶部从`Data.Maybe`引入，它本身只是一个谓词，如果传入的`Maybe a`是一个`Nothing`而不是一个`Just a`，那么它就是真的。

我们将我们的电路板初始化为一个`Nothing`列表。第一次通过这个循环，我们传入的任何数字都将被清除。如果有一个`Just Human`或`Just Computer`，我们会碰到`else`模块，对用户大喊一声(我的意思是说实话，我们只是把板子打印出来，跟上程序)，然后从头开始。

然而！如果`openCell`返回`true`，我们终于做到了——我们已经确保从 stdin 传递给`n`的值是一个我们可以有意义地用作玩家下一步行动的值——它不仅是一个有效的输入，而且是一个有效的游戏。热辣迪吉狗！

完整的`then`块显示为:

```
handleInput board n' >>= compTurn >>= runGame 
```

Enter fullscreen mode Exit fullscreen mode

这是三个独立的函数调用，用`>>=`包装在一起，读为`bind`。这是需要与`return`一起定义为`Monad` typeclass 实例的一部分的函数之一，所以所有单子都有这种行为。我们将首先谈论`bind`，然后回到下面的`return`——但它们实际上是同一个想法的两个部分。`>>=`将允许我们将一个单子的结果作为输入传递给链中的下一个单子，同时仍然将它包装在适当的上下文中，在本例中是`IO a`或者更确切地说是`IO Board`。我们希望在不丢失`IO`包装的情况下对`Board`进行处理。我认为这通过例子是最清楚的，幸运的是我们现在正在做一个例子！第一个函数调用是`handleInput board n'`,所以让我们先解开它。

### 拍戏

我打赌我们可以从电话中找出`handleInput`的类型。`board`很简单——它是一个`Board`——`n'`是我们从 stdin 新转换的整数。所以我们知道这将是一场`Board -> Int -> something`。但是什么？

嗯，我们知道我们在一个`IO`单子里面，并且在一系列调用中与单子`>>=`链接在一起。因此，这是一个安全的赌注，这将是另一个`IO a`，也就是说，一个`IO`单子与某种类型的结果。如果我们往下看这个连锁调用，我们以调用`runGame`结束事情。我们已经看过`runGame`(我们现在就在里面)，所以我们知道它是一个`Board -> IO ()`。我们在这里没有参数地调用它，但是从类型上知道它将需要一个`Board`，并且我们通过一个函数链传递一元结果——因此可以得出结论，每个步骤的类型*必须是*的`IO Board`。瞧吧:

```
-- line 46
handleInput :: Board -> Int -> IO Board
handleInput board n = do
  let b = playCell board n Human
  checkWin b Human
  gameOver b
  return b 
```

Enter fullscreen mode Exit fullscreen mode

不出所料！在函数体中，我们打开了另一个`do`块，第一步是创建一个新的绑定`b`。是时候对`playCell`进行最后的检查了，并让这个游戏开始运作了:

```
-- line 33
playCell :: Board -> Int -> Player -> Board
playCell (Board b) n m = Board $ take (n - 1) b ++ [Just m] ++ drop n b 
```

Enter fullscreen mode Exit fullscreen mode

从函数调用中，我们期望一个类似的类型- 3 个参数。我们现在还看到它会返回一个`Board`来存储在`b`中。唯一一种我们还没怎么见过的类型是`Player`——但是我们已经从讨论`Board`中知道了所有这些！该值可以是一个`Human`或一个`Computer`，除此之外别无其他，在这种情况下，我们正在处理人类的输入——所以我们只传入`Human`。

在参数列表中，我们再次构造了`Board`来访问里面的单元格列表，并给另外两个单元格分配了字母。

现在，在 C 风格的语言中，你可能首先通过索引列表和改变里面的值来完成向棋盘添加游戏的任务。在哈斯克尔，这是一个很大的不。还记得我们讨论纯洁的时候吗？这将涉及到*改变函数*之外的世界状态——即`Board`。如果我们这样做，这个函数会产生完全基于调用时的状态的完全不同且不可预测的结果，这很可怕。我们不能明确地看着那个函数并告诉你*它到底会做什么。但是，当然，如果什么都不允许改变，这将是一个愚蠢的游戏。*

我们在函数范式中绕过这一限制的方法是根本不试图改变任何东西。相反，我们将基于前一个构建一个全新的*`Board`——就像 Javascript 代码片段在一开始在`pureIncrementAll`中所做的一样。Haskell 是垃圾收集的，所以运行时会自动丢弃旧的迭代，而不需要调用任何析构函数或自己释放内存。这样游戏作为一个整体可以继续在一个新的状态，我们没有打破我们的纯度限制。*

 *我使用超级方便的`take`和`drop`函数来完成这个任务，它们返回新的子列表，而不改变输入列表。`take`从前面返回指定数量的元素，`drop`从指定的索引开始返回列表的结尾。所以在`playCell`中，我只`take`指定的单元格，但不包括指定的单元格，最后我们将通过`drop` ping 开头来附加其余的单元格。那就只剩下一个细胞有问题了。因为`Board`要求每个单元格都是`Maybe Player`，所以我们可以将`Human :: Player`值包装在`Just`中。然后，我们把它放在括号中，形成一个单个元素列表，我们可以把它连接到 bookend 子列表，并把新列表包装在一个新的`Board`中。最终结果是一个`Board`值，除了我们作为参数传入的单元格现在有一个`Just Human`而不是`Nothing`之外，它的形状与上一个值一样。其他的都是直接复制。

这样，对于相同的输入，我们可以始终保证相同的输出。`Board`的当前状态被直接传递到函数中，该函数允许我们适当地生成下一个状态，并且我们确切地知道在给定所有本地可用输入的情况下它会是什么样子。这使得 Haskell 代码中逻辑流的推理变得非常简单，否则共享可变状态会变得非常复杂。

### 只请获奖者

现在，我们已经存储了更新了一个单元的闪亮新板，我们要看看我们做得有多好。`handleInput`的下一行调用`checkWin` :

```
-- line 57
checkWin :: Board -> Player -> IO ()
checkWin board@(Board b) m =
  let
    bi = withIndicesFrom 0 b
    plays = map fst.filter ((Just m==) . snd) $ bi
  in
   when (foldr ((||) . flip isSubsequenceOf plays) False winStates) $ do
     -- End the game! 
```

Enter fullscreen mode Exit fullscreen mode

好吧，这个有点大。这是一个由两个参数返回一个 IO 单子的函数，(我真的希望)到目前为止是有意义的。这个单子没有返回任何东西(注意，我们没有将结果存储到与`<-`的绑定中，我们只是在我们的`do`块中调用它——也就是我们的`then` / `>>`单子链)，所以`IO ()`是合适的。这将只是做一些 IO，并负责终止进程，如果我们找到一个胜利。

与`where`不同，`let...in`语法是创建函数本地绑定的一种方式。事实上，它们经常可以互换使用，区别很微妙:`let...in`是一个表达式，可以用在任何需要表达式的地方(有点像`if...then...else`)，而`where`是一个语法结构，只跟在函数体后面。我在这里不打算深入细节，参见 [Haskell Wiki](https://wiki.haskell.org/Let_vs._Where) 进行更深入的讨论。

无论如何，在进入最终检查之前，我们将设置一些计算过的本地绑定，以使我们的生活变得简单一些:

```
-- line 59
 let
    bi = withIndicesFrom 0 b
    plays = map fst.filter ((Just m==) . snd) $ bi
  in
  -- uber cool codez 
```

Enter fullscreen mode Exit fullscreen mode

我们保存了一个版本的`Board`作为`bi`，使用我们的老朋友`withIndicesFrom`压缩了索引——而不是，例如，我们有`[(0, Nothing), (1, Just Human), (2, Nothing)...]`的`[Nothing, Just Human, Nothing...]`。我们将在下一个`let`绑定`plays`中使用它。这条线有点象征性，但我们非常勇敢。这是对`map`的调用，我们映射的集合(functor)是新定义的`bi`，所以中间所有的垃圾都必须是我们的映射函数。让我们看看能否解开它。

这个函数通过我们在`Show Board`实例中看到的`.`复合操作符选择了简洁，以牺牲可读性为代价。这个实际上在一个更大的复合函数中有一个复合函数，这是额外的好处。这些最容易从里到外阅读(口齿不清的人知道发生了什么)。

第一个动作发生在`bi`，我们的索引`Board`，是`filter ((Just m==) . snd)`。过滤函数首先对每个元素调用`snd`，只返回元组的第二个元素:

```
snd (1, Just Human) == Just Human 
```

Enter fullscreen mode Exit fullscreen mode

然后，`(Just m==)`将它与作为`m`传入的值进行比较——还记得我们调用该函数时，它看起来像`checkWin b Human`。我们特别检查人类玩家是否用他们最近的玩法赢得了游戏。这就是为什么我们在`Player`声明中向上派生了`Eq`type class——否则这个检查不会编译。因此，如果第二个值是`Just Human`，则`((Just m==) . snd)`将在`(Int, Maybe Player)`上返回真，否则返回假。

现在我们已经将`bi`缩减到只包含已经播放的单元格，我们将整个结果传递给`fst`——也就是说，获取每个元组的第一个值。这些是我们的指数。

存储在`plays`中的最终结果是一个从 0 开始的人玩过的所有地方的索引列表。例如，在单元格列表`[(0, Nothing), (1, Just Human), (2, Just Computer), (3, Nothing), (4, Just Human)]`上运行它将返回`[1, 4]`。很可爱。

既然我们已经打包好了人类游戏，我们可以检查一下这是否构成了一场胜利。在`in`之后，函数的主体是另一个`when ... do`狂欢，就像我们在`gameOver`中看到的一样。这个单子将在这种情况下执行它的身体，否则它就不能操作。

那这个条件怎么样？我们来看看:

```
`foldr ((||) . flip isSubsequenceOf plays) False winStates 
```

Enter fullscreen mode Exit fullscreen mode

啊哈，是我们的老朋友`foldr`。我毫不掩饰地喜欢折叠。和往常一样，我们有三个参数:一个转换函数、一个初始化器和一个集合。我们之前已经看了两次——这个简单的例子使用了一个`Int`作为我们添加数字的初始化器，游戏中的代码使用了一个集合(我们预先构建的)。这一次很简单一个`Bool` - `False`。只要你的转换函数返回一个`Bool`，这也是可以的！它可以是任何类型。这意味着整个 fold 将返回一个`Bool`——根据定义，fold 总是返回与初始化器相同的类型:`(a -> r -> r) -> r -> [a] -> r`。这就是我们想要的，因为`when`需要一个谓词。

在拆开变形金刚之前，让我们看看`winStates`——我们正在折叠的系列。

```
-- line 53
winStates :: [[Int]]
winStates = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]] 
```

Enter fullscreen mode Exit fullscreen mode

这非常简单——它只是一个列表的列表。诚然，这不是处理这个问题的好方法，但是 TicTacToe 非常简单，可以简单地硬编码所有可能的成功配置。这是一个由`Int`(`[[Int]]`)组成的列表，只包含一行中的所有索引。

最后是变压器:`(||) . flip isSubsequenceOf plays`。我们知道这一整段代码是一个类型为`(a -> r -> r)`的函数——填入具体的类型就变成了`([Int] -> Bool -> Bool)`——我们的初始集合是一个`[[Int]]`，一个`Int`列表的列表，所以每次我们只检查这些子列表中的一个并返回真或假。

我选择的主要功能是名副其实的`isSubsequenceOf`，它是从`Data.List`导入的(带着爱)。如果第一个列表中的元素在第二个列表中按顺序(但不一定是连续的)出现，则返回 true。文档指出这个函数相当于调用`elem x (subsequences y)`——标准库通过组合更小的抽象来构建有用的抽象！实际上，我是在研究一个问题的过程中遇到这个库函数的，我曾试图自己实现它。我不记得我遇到的问题的具体性质了，因为解决它所需要的只是看一看标准库。在掉进错误的兔子洞之前，不要忘记查看一下你需要的功能。

#### Typclass 约束-题外话

根据 [Hackage](https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-List.html#v:isSubsequenceOf) ，该函数的类型为`Eq a => [a] -> [a] -> Bool`。这个符号有一个语法元素我还没有提到——第一部分，`Eq a =>`，是对`a`的*类型类约束*。在本文中，我一直使用`a`作为“任何类型”的替代。这个语法可以让你更精确地定义什么类型是可以的——不像 fold，`isSubSequenceOf`只在元素可以相互比较的列表上调用才有意义。这是显而易见的——它必须检查一个列表中的每个元素。这是针对*特定多态性*的 Haskells 系统。如果涉及的类型没有指定的 typeclasses 实例，无论是派生的还是手工实现的，都不会编译。

### `flip` ing 出

这个函数构成最后一个不熟悉的地方是“翻转”这个词。这是一个简单但有用的函数，它只是改变了参数的顺序。我们在 transformer 函数中调用它的方式是，`isSubsequenceOf`首先接收我们的`plays`列表，然后是当前正在处理的`winStates`的元素。然而，我们希望反过来。为了判断我们是否赢了，我们要检查 winState 是否是这个玩家所有玩法的子序列。你可以在棋盘上用其他没有排队的打法取胜，它们只是无关紧要。`flip`只要交换参数的位置，我们就能得到我们想要的逻辑！

最后，我们用简单操作符`(||)`组合(`.`)结果。这通常被用作中缀，例如`true || false`，但是我们也可以把它作为一个普通的前缀函数使用。它接收的一个值将是我们的`flip isSubsequenceOf`调用的结果，另一个呢？为什么，那是我们初始化的`Bool`！通过用 big 'ol `OR` / `||`将所有这些调用链接在一起，如果这些迭代中的任何一个返回`True`(意味着`plays`包含我们的`winStates`之一)或保持我们初始化它时的`False`，这个转换器将为整个集合返回`True`。

如果是`False`，我们没有赢`checkWin`也没有别的事可做。块内的代码不执行，我们要返回`()`，控制权返回给调用者。如果我们*赢了:* 

```
-- line 63
print board
putStrLn $ show m ++ " won!"
exitSuccess 
```

Enter fullscreen mode Exit fullscreen mode

现在我们终于可以跳回去完成`handleInput` :

```
gameOver b
return b 
```

Enter fullscreen mode Exit fullscreen mode

如果我们已经到了这里，这意味着`checkWin`没有找到一个获胜的棋盘配置，所以在我们继续之前，我们再次调用`gameOver`来查看这一局是否导致了和局，如果没有，我们就调用`return b`。`return`与你习惯的略有不同——它特别意味着在我们的`IO`上下文中重新包装我们的`Board`类型。这是`>>=`的另一部分——这就是我们如何通过连续的 IO 动作将结果传递给 gamestate。这就是我们如何将结果传递回主`runGame`循环，确定这场比赛没有以赢或平结束游戏。

### RNG 漫游者

我们已经接近了这条路的尽头——如果你还和我在一起，我真的很感动！我们只差最后一个零件就能搞定了。毕竟，如果没有一个目光坚定、善于算计的对手随时准备压制你的每一个计划，这算什么游戏呢？

嗯，我们不会在这里找到答案，因为我的电脑玩家是真正的哑巴，玩骰子滚动。尝试做一个更聪明的可能会很有趣——我把它作为一个练习留给读者(阅读:懒得自己做)。

稍微倒退一下，我们在这个更大的子句
中输入`handleInput`

```
-- line 87
handleInput board n' >>= compTurn >>= runGame 
```

Enter fullscreen mode Exit fullscreen mode

到目前为止，我们已经根据人类的输入更新了世界状态，确保游戏仍在进行，并接收了新的`Board`进行工作。现在，我们将通过`>>=`将这个全新的世界状态传递到`compTurn`中，正如我们所讨论的，这将允许`Board`被传递，而不会丢失它开始时的`IO a`上下文。这意味着我们应该期望`compTurn`接受一个`Board`作为输入，因为我们在`>>=` / `bind`链的中间，返回一个`IO Board` :

```
-- line 36
compTurn :: Board -> IO Board
compTurn board@(Board b) = do
  let options = filter (isNothing.snd).withIndicesFrom 1 $ b
  r <- randomRIO (0, length options - 1)
  let play = (fst $ options !! r)
  let b2 = playCell board play Computer
  putStrLn $ "Computer plays " ++ show play
  checkWin b2 Computer
  return b2 
```

Enter fullscreen mode Exit fullscreen mode

太好了。到现在为止，这个函数已经很熟悉了。我们看到了我们的`IO Board`返回类型，我们正在析构参数以得到单元格列表作为`b`，我们有了我们的老朋友`do`块——没什么太令人惊讶的。

第一行创建本地绑定`options`，这将是对我们的单元格列表进行`filter`操作的结果。Filter 将返回一个集合，该集合只包含谓词为真的输入集合的那些元素。同样，恰如其名。让我们来看看谓语:

```
(isNothing.snd).withIndicesFrom 1 
```

Enter fullscreen mode Exit fullscreen mode

这个函数由我们以前见过的部分组成。首先，我们要用从 1 开始的索引来压缩单元格(剧透一下，因为那是`playCell`想要的输入)。然后我们将把它传递给`snd`和`isNothing`的组合`.`。希望现在开始感觉可读性更好一点——在英语中，这个`filter`将具有将包含`Nothing`的 1 索引单元格列表存储到`options`的效果——任何为`Just Human`或`Just Computer`的单元格都将被省略。这些组成了计算机可以为其下一次游戏选择的可能的单元。

在下一行我们引入了随机性。这最终看起来类似于你用自己选择的语言来做这件事。`randomRIO` from `System.Random`取一个范围，会给你一个该范围内的伪随机数。我们使用了`options`列表的长度，并将结果存储到`r`。

现在我们必须真正做出改变。这又是用`playCell`完成的——不同之处在于，我们用`!!`代替用户输入，用我们刚刚抓取的随机数索引到`options`,我们传入的是`Computer`,而不是`Human`。现在`b2`持有我们的新`Board`，随机播放。之后，我们可以通知用户计算机去了哪里。考虑到所有这些，我们可以看看计算机是否成功地用`checkWin`赢得了比赛。如果是的话`checkWin`将为我们处理游戏的结束，如果不是的话，我们`return`重新开始新的游戏。这里不需要再次调用`gameOver`,因为`runGame`先调用了——我们的管道`handleInput >>= compTurn >>= runGame`正把我们送回那里开始下一轮。

### 惊心动魄的结论

我们做到了！我已经没有代码可以解包了。拥有它所需要的一切来交替进行人类和计算机的游戏，直到有人赢了或者我们用完了空间。哈斯克尔什么都不是:)***