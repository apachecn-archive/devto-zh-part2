# UI 测试之旅——经验教训

> 原文：<https://dev.to/ankitvijay/journey-towards-ui-tests-greatness--lessons-learnt-1amd>

## **有点背景**

我在我们的组织中从事一个长期运行的项目。我们的项目有一个 CI/CD 管道，遵循 GitHub 流程，并由数千个单元测试和数百个集成测试支持。然而，直到最近，我们还缺少这个难题的一个关键部分。UI 测试！

这并不是说我们没有 UI 测试，我们有很多(只是太多了)，但我们无法在我们的构建服务器上满怀信心地运行它们，原因我将在后面介绍。由于 UI 测试不是在每个构建上运行，我们仍然需要验证每个构建的回归。简而言之，我们并不是真的在做**连续交付**。我们的 QA 和他一样聪明，然后构建了他自己的一套 UI 测试套件，他会在每次构建时运行这套套件来验证构建的质量。

## 为什么我们不能满怀信心地运行 UI 测试

*   我们的 UI 测试很不稳定。测试经常会因为外部因素**而失败，尤其是在构建服务器**上。最重要的是，与单元测试或集成测试相比，UI 测试的本质是非常慢的。每次由于一些外部因素*导致测试失败的时候运行整个测试套件*会浪费很多时间。****
***   我们的 UI 测试很脆弱。他们试图做的不仅仅是 UI 测试。他们非常依赖 HTML 页面结构。因此，即使进行最小的更改，他们也会失败。*   UI 测试的脆弱本质意味着开发人员对 UI 测试框架失去了信任。结果就是**没有维护好**。*   UI 测试充斥着大量的**线程。睡眠**。和线程。睡眠导致了两个更大的问题:
    *   我们无法知道什么是合适的延迟。每增加一秒钟的延迟都会对已经很慢的测试产生连锁反应
    *   尽管增加了延迟，但不能保证测试会通过。*   UI 测试并没有真正代表 T2 的商业场景。它们更多地是出于测试 UI 元素的想法而编写的。因此，有时我们最终测试的不是实际的业务用例。*   测试**没有**遵循**实**和**干**的原则。他们从来没有得到和应用代码一样的爱和待遇。这使得它们很难维护。**

 **## **修复被破坏的测试**

我们是一个非常小的开发和单一 QA 团队。然而，我们以非常高的速度交付新的业务特性和错误修复。随着解决方案的复杂性开始增加，越来越明显的是，如果没有 UI 测试，我们就无法交付高可信度的解决方案。我们的 QA 被迫更加关注普通的测试，而不是提前计划下一个用户故事。

就在那时，我们后退了一步，决定为此做点什么。我们列出了现有 UI 框架的痛点，并针对每一点开发了 **UI 框架 2.0** 。这项工作的最终目的是解决上述问题，并开始运行测试，作为我们的 CI/CD 管道的一部分。

## 解

*   **将业务放在第一位**–为了确保我们不会重蹈覆辙，我们以消费者将如何使用我们的应用程序这个问题开始了我们的用户界面测试。我们与我们的 QA 合作，以获得重要业务场景的列表。我们计划了我们的测试用例 BDD 风格，并选择了 [SpecFlow](https://wordpress.com/post/ankitvijay.net/3763) 来编写我们的测试。SpecFlow 允许我们编写测试，这样我们的 BA 和 QA 都可以很容易地理解测试用例，甚至为测试做出贡献。在计划测试用例时，我们不断提醒自己[测试金字塔](https://martinfowler.com/bliki/TestPyramid.html)。
*   **遵循良好的开发实践—**UI 测试框架不再是被拒绝的孩子。我们开发框架的方式与编写应用程序代码的方式相同。测试遵循固体和干燥的原则。SpecFlow、业务逻辑、Selenium 等所有组件都是松散耦合的。该框架允许开发人员不用担心底层的 UI 元素，而只需要考虑场景中需要执行的步骤。
*   **没有线头。睡眠-**线程。UI 测试中的睡眠是邪恶的。一开始，它似乎是所有问题的解决方案。但是很快它开始制造问题。框架 2.0 没有使用线程。睡在任何地方(或者可能只是一个地方:)。**线。睡眠**换成了硒[隐性和显性](https://www.seleniumhq.org/docs/04_webdriver_advanced.jsp)等待。这有助于我们保持测试快速可靠。
*   **兼容特性标志—**我在我的一篇[旧帖子中提到过](https://ankitvijay.net/2017/10/08/launch-darkly/)我们使用 Launch Darkly 进行特性标志管理。新的 UI 框架允许我们用不同的特性标志变量来测试场景(例如:特性关闭/打开)。特征标志是我们测试的重要部分，因为它们会随着环境、流程等而变化。因此，能够容易地测试所有的变化对我们来说很重要。
*   **重试策略**–尽管上面提到了所有的优点，UI 测试套件仍然可能由于我们无法控制的因素而失败。这就是我们决定添加重试策略的地方。重试策略在两个级别上定义:
    *   重试 _ **操作，如果第一次尝试失败，则重试** _ 操作。
    *   如果第一次测试失败，重试 _ **测试用例**。

开发 UI framework 2.0 是一个旅程，我们花费了相当多的时间和精力，才到达可以再次将 UI 测试作为 CI/CD 管道的一部分来运行的地步。当我们在框架上工作以获得持续的反馈时，我们在独立于 CI/CD 管道的构建服务器上运行 UI 测试。在一个单独的构建中运行 UI 测试允许我们对框架进行改进，而不影响正常的业务。一旦我们对 UI 测试有了足够的信心，我们就摆脱了单独的构建，将 UI 测试作为主线构建的一部分。

## **下一步是什么**

没有完美的解决方案或框架。我们打算进一步改进该框架。我们希望在未来改进的几件事情是:

*   并行运行测试以减少服务器上的构建时间
*   添加更复杂的业务场景，将测试工作量降至最低
*   使用 [BrowserStack](https://www.browserstack.com/) 集成测试，以跨越平台和设备。查看我的[帖子](https://dev.to/vijayankit/test-your-app-across-the-browsers-through-browserstack-19f7-temp-slug-1704615)以了解更多关于 BrowserStack 的信息。

帖子[迈向 UI 测试的伟大之旅——经验教训](https://ankitvijay.net/2018/10/31/journey-towards-ui-test-cases-greatness-lessons-learnt/)最先出现在[嗨，我是 Ankit](https://ankitvijay.net) 。**