# 所有未经测试的东西都会坏掉

> 原文：<https://dev.to/stealthmusic/everything-thats-not-tested-will-break-1adg>

*完全公开:我是测试的忠实粉丝，尤其是 TDD。而且，大多数情况下，我说的是专业的软件开发(你实际上是为你写的代码得到报酬的)*这篇文章是写给那些不测试或者不允许测试的人的。我仍然很惊讶有多少公司、部门或团队没有正确地测试代码。

但是我为什么要考呢？因为，*一切不测试的都会破*。只是时间问题。

非常明确地说，我不是说，100%的测试覆盖率是目标，因为总有一些代码不能被破坏——比如一个简单的实体类。但是，其他所有的内容都应该在某个时候涉及到。我也不是说所有未测试的代码都会有 bug，但是一旦你有了 bug，它很可能位于你代码库中未测试的部分。因为您不知道 bug 会在哪里发生，所以编写测试会降低这种情况发生的概率。

要做到这一点，目前为止我已经看到了很多经过实战检验的技术:

# 高级测试技术

## 编译器驱动设计(CDD)

我在我的 [WTF 文章](https://return.co.de/blog/articles/wtf/)中提到过。当你练习 CDD 的时候，你一定会遇到一些非常乐观的人。你在栈溢出上查找东西，复制粘贴，修改和注释掉代码，直到它编译。

任务完成。提交。让我们看一些猫的视频。

## 基于信念的设计(BBD)

这是 CDD 的一个变种，通过查看你的代码，你可以非常非常确定你的代码中没有错误，因为你已经在你的电脑上运行过一次了。它肯定会投入生产。

让我们看一些猫的图片，并依靠...

## 让客户测试

好主意！如果你运气好，并且客户确实存在，让他测试软件，发现并报告错误。保修不就是这样吗？只要确保客户感觉不好，因为你拒绝不使用你的问题模板的错误。

## 手动测试

现在我们开始变得*专业*。您实际上自己执行了一些测试！有多刺激？

在看猫图片的时候，你点击你刚刚实现的按钮，它就工作了！干得好。让我们实现下一个特性。

在客户打电话给你，你因为他愚蠢而对他大喊大叫，因为你确实测试了它，你挂断了电话。

你现在不知道的是，在实现了第二个特性之后，你实际上破坏了新的按钮代码。

通过艰苦的学习，您计划在实现新特性时测试所有的旧特性。你写下所有要测试的东西，作为下次的提醒。我们称之为测试规范。

但是随着产品的增长，测试会花费太多的时间，这是你无法承受的。你的经理对你大喊大叫，因为你不再写特写了。

然后，你的产品即将发布，客户在等待，但你不能完成所有的功能，包括测试。所以你跳过测试，但你会有不好的感觉，觉得有什么不对劲。

而且你说的没错，客户一用你的产品，它就坏的很厉害。找到原因需要几天时间，但修复需要两周时间。

# 那么是什么交易？

我们刚刚看到了软件开发的一些陷阱。我们能做什么？愚见:*测试*。

但是测试什么？

## 测试范围

您可以测试不同的范围:

| 测试范围 | 抽象层次 | 费用 | 描述 |
| --- | --- | --- | --- |
| *单元测试* | 低的 | $ | 它们覆盖了代码的“单元”，通常但不一定是一个类。单元测试覆盖了系统的大部分，尤其是所有的边缘情况和错误条件，因为它们更容易建模。这就像拿着放大镜检查汽车的焊点。 |
| *集成测试* | 中等 | $$ | 它们将系统的较大部分(即多个单元)作为一个整体。它们通常测试多个类和外部接口(包括 HTTP、数据库、消息队列等)之间的交互。这些接口要么被内存和进程内的替换所模仿，允许在没有任何外部系统的情况下在你的计算机上运行测试。集成测试可以加速在单元测试套件中运行。他们就像是在确认，门是否真的适合机箱。 |
| *系统测试* | 高的 | $$$ | 他们通过与 UI、HTTP、MQ 等外部接口进行交互，将整个系统作为一个黑盒进行测试。这些测试编写起来最昂贵，而且运行时间也更长，这就是为什么他们通常只从头到尾测试主要的业务用例。拥有一个与您的生产系统相同或至少非常接近的环境非常重要，包括服务器规格、操作系统、数据库等。系统测试检查，你的车实际上能够驾驶，刹车实际上是停止汽车，当你踩下踏板，没有任何其他损坏。 |
| *验收测试* | 特征 | $$$$ | 它们尤其涵盖了与客户或产品所有者相关的主要用例。这个想法是，这些测试可以由客户编写，一旦它们是绿色的，这个特性就被接受了。你可以这样看待它:我的车可以在 30 分钟内把我从家送到工作地点，里程为 8 l/100km (50 mpg)。 |

还有一些其他的测试，比如性能测试、耐力测试和冒烟测试，这里我就不一一列举了。

自上而下，编写测试的工作量和成本通常会增加，而详细程度会降低。Martin Fowlers 的文章[测试金字塔](https://martinfowler.com/bliki/TestPyramid.html)中提到了这一点。

测试范围是一个重要但很难掌握的东西。在所有范围内覆盖 100%的代码是没有意义的，这太费力了。所以你总是需要决定在什么范围内覆盖什么。这总是一个权衡和经验的问题，但是你不可能只在一个范围内构建软件。因为单元测试更容易编写，更便宜，更快，你会希望用单元测试覆盖尽可能多的代码(强调*可能的*，因为你需要更高抽象的测试，比如集成测试，这是有原因的)。

参见[“两个单元测试，没有集成测试。”](https://www.reddit.com/r/ProgrammerHumor/comments/61qnnk/2_unit_tests_0_integration_tests/)

从理论的角度来看，我非常喜欢允许客户或产品所有者用文本可读的领域特定语言编写验收测试的想法。然而，允许这样做的努力是相当高的，老实说，我们实际上从未使用过自动化验收测试。我们确实在系统测试中涵盖了验收相关案例。

## 自动化&速度

关于测试最重要的事情是，它需要**自动化**并且需要**快速**。

自动化有助于消除人类犯的错误。它需要快速地允许在每一次代码变更时运行测试，以获得即时的反馈。单元测试应该以毫秒为单位运行，整个套件只需几秒钟。集成测试也应该在几秒到 30 秒内运行。系统测试可能会运行几分钟，但只有在真正必要时。

自动化的优势在于，您还可以运行测试覆盖分析，这将向您显示代码中未覆盖的行或分支。如上所述，不要试图达到 100%的代码覆盖率。使用一个覆盖工具来帮助你发现你可能遗漏了一些东西，比如一些`else`分支，并且应用一些常识。

作为一个提示，在我的团队中，我们通常有 60%到 80%的覆盖率。

## 回归测试

自动化尤其对回归错误有帮助。在实现新特性、修改或重构之后，你可以让你的测试套件运行，看看你是否破坏了以前工作过的东西。与手工测试相比，这是一个很大的区别。在开发之后或者开发过程中手工测试一个特性可能就足够了。但是时不时的，一个新的特性会打破一些旧的特性。

你可能已经非常彻底地测试了一些东西，然后，在一切看起来都没问题之后，你*只是*改变一小段无害的代码行或者一些不会影响任何东西的配置值。但这也时不时的引入 bug，尤其是在你没有预料到的时候。

## 记录代码和 API

我不太喜欢代码注释。每当我发现它们时，我通常会删除它们，并用适当命名的变量、方法或类来代替它们。这叫做[干净代码](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)。
然而，绝对有必要以一种不冗余、不自嘲的方式记录你的代码。
在我看来，这里的解决方案是*测试*。编写不言自明的测试，正确命名并使用 [Given-When-Then](https://martinfowler.com/bliki/GivenWhenThen.html) 形式。记录一个类或一个 api 的最好方法是使用该 API 的实际代码。那么，为什么不花些精力编写可读和可执行的测试，作为代码的规范呢？您甚至可以从您的测试中生成 [REST API 文档，包括真实的请求、响应和参数。](https://projects.spring.io/spring-restdocs/)

## 减轻压力

对我来说，这是自动化测试套件最重要的，也是我认为最被低估的好处。当你感到压力时，当发布即将结束时，当经理对你大喊大叫时，它会掩护你。很多次我都遇到过这样的情况。在我职业生涯的早期，我没有一个全面的测试套件，我需要快速修复一些可能影响时间和可能导致并发问题的东西。我记得我很快地测试了它，然后将它运送给客户，我的额头上有汗珠。我非常努力地去思考它可能会对我的代码库造成的所有后果。显然，它在生产中失败了。

几年后，我遇到了类似的情况。然而，我用 TDD 开发了整个软件，产生了一个庞大的测试套件。从我把软件投入生产的那天起，就没有任何错误。在添加了一个紧急的新功能后，所有测试都是绿色的，我在发货时非常放松。什么都没坏。

## 客户满意度&维修费用

大多数不熟悉软件和软件项目的客户和——不幸的是——大多数经理，如果你问他们，他们可能不愿意花钱进行测试。然而，如果你问他们“这个软件应该是高质量的吗”，大多数人可能会说“是”。如果你问他们，他们是否愿意为维护、项目保修阶段的错误修复或产品中减少的生产功能付费，他们会说“不”。
所以，过一会儿，你会学到一些东西:

1.  经理和客户*期望*高质量和无缺陷的软件，不管他们之前告诉你什么。
2.  为了实现这一点，您需要编写测试。
3.  你不应该要求写测试。去做吧。对经理和客户来说只是一些背景噪音。
4.  如果有人问你，为什么一个特性还没有准备好，千万不要告诉他们“我正在写测试，花的时间比我想象的要长”。告诉他们这个特性花费的时间比你想象的要长，因为测试和生产代码属于同一个部分。

非常明确地说:我不是让你去欺骗别人。我坚信，在生产和维护周期中，测试将会节省资金。这将减少生产中的缺陷数量，让客户满意，可能会再次订购，并作为参考。我会让经理满意，因为维护成本低。

## 软件设计

对我来说，一个很大的优势是由此产生的软件设计。我说的是类、方法和接口的样子。这个好处主要来自于测试驱动的设计，因为它迫使你实现你的代码来符合你以前写的测试。如果你不做 TDD，你经常会发现实际上不可能测试某个类、方法或代码分支的情况。

## 缺点或例外

老实说，我没见过多少。事实上，有一点是，在重构代码之后，很多测试用例可能无法编译。这很烦人，可能很费时间，但解决起来很简单。我绝不会用测试的好处来换取重构后不需要修复测试。

规则的例外呢？我要测试副业吗？大部分是，是的，但没有我工作时那么彻底。试播集或概念证明呢？其实我是不相信这种事的。我从未见过任何客户真正理解“这是一次概念验证”的后果。没有测试，一旦得到真正的订单，我们会扔掉所有的代码。”他们仍然期望无缺陷的软件，最多只有较少的功能。所以，无论你构建什么样的软件，如果是为了专业用途(客户或者内部生产)，那么你就需要测试。

请记住，[客户对](#customer-satisfaction-maintenance-costs)的期望。

# 结论

编写测试必须是强制性的，未经测试的产品代码会失败，根据墨菲定律，它会在你没有时间彻底思考的非常紧张的情况下失败。

测试将有益于你的软件设计，减少压力，提高质量和客户满意度。

开始做吧。没有借口。

*原载于[我的博客 return.co.de](https://return.co.de/blog/articles/everything-not-tested-will-break/)T3】*

*封面图片来自这条永恒的推文:*

> ![unknown tweet media content](../Images/7371c31a18818e8405a18845bc3c5243.png)![The Practical Dev profile image](../Images/1a10e330d1a8423f8b4b861b114cf62c.png)实用 Dev[@ thepracticaldev](https://dev.to/thepracticaldev)![twitter logo](../Images/4c8a2313941dda016bf4d78d103264aa.png)事情大多是细的2016 年 5 月 21 日上午 06:32[![Twitter reply action](../Images/44d8b042100e231770330321e5b63d65.png)](https://twitter.com/intent/tweet?in_reply_to=733908215021199360)[![Twitter retweet action](../Images/93d9c70ccc54851d2e8e881b53c21dae.png)](https://twitter.com/intent/retweet?tweet_id=733908215021199360)[![Twitter like action](../Images/2e93f7775eadefab8bcd34a4542cc5a7.png)](https://twitter.com/intent/like?tweet_id=733908215021199360)

*感谢 [@kylegalbraith](https://dev.to/kylegalbraith) 给我指出马丁·福勒的文章！*