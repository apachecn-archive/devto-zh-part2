# 建筑是一种负担

> 原文:[https://dev . to/schreiber _ Chris/architecture-as-a-burden-18ca](https://dev.to/schreiber_chris/architecture-as-a-burden-18ca)

更新:法国人可以在这里找到我在巴黎 Java 用户群做的一次演讲

# [](#introduction)简介

在我被派往的各种任务中，我参与了各种遗留软件项目，这些项目都有各种各样的缺陷。

当然，糟糕的软件质量(没有单元测试，没有使用干净的代码原则...)通常是一个主要问题，但是在项目的早期，甚至在企业系统的初期，也有来自架构决策的问题。在我看来，这种问题是许多项目痛苦的最大原因。

事实上，改进代码非常容易，尤其是现在软件工艺运动正在团队间传播良好的实践。但是改变系统的核心，即在其生命周期的最开始强加的约束，是非常具有挑战性的。

我将谈论我遇到的几种类型的架构决策，这些决策对于维护这些系统的团队来说是真正的负担。

# [](#sharing-your-database-with-the-whole-company)与整个公司共享您的数据库

这可能是我见过的最常见的问题之一。当几个应用程序需要使用公共数据时，为什么不能简单地共享数据库呢？毕竟，重复是软件开发中的一件坏事，对吗？不是每次都这样，尤其是涉及到数据库的时候。文卡特·苏布拉马年说过一句让人无法忘记的话:“数据库就像牙刷，你永远都不应该分享它”。共享一个数据库有什么错？事实上很多事情...

我首先想到的显然是数据模型中的耦合。假设 2 个应用程序 A 和 B 正在处理汽车。应用程序 A 用于负责维修的团队，因此他们需要存储大量关于机械、故障、汽车干预历史的技术数据...应用程序 B 用于处理技术团队的预约，因此它只需要关于汽车的基本信息就能够识别它。在这种情况下，为两个应用程序使用相同的数据结构是没有意义的:它们使用非常不同的数据，所以它们应该使用自己的数据结构。这甚至更容易，因为汽车可以很容易地识别，所以没有必要分享一个共同的参考。

第二个问题也来自数据模型的耦合。想象一下，B 想要重命名汽车的标识符，因为从领域的角度来看这样更有意义。在这种情况下，还应该更新以处理新的列名...因此，为了避免打扰 A 的团队，B 的开发人员将开始在不同的列中复制信息，因为他们不能更改现有的名称...当然，A 会说他们将在未来计划这种变化，以避免两列包含相同的数据，但我们都知道这很可能永远不会实现...

当应用程序不仅从相同的源读取数据，而且还修改它们时，事情会变得更加糟糕！在这种情况下，谁是数据的所有者？应该相信谁？如何保证数据的完整性？当相同应用程序的几个部分正在修改相同的信息时，这已经很困难了，当涉及几个应用程序时，这变得更糟...

我见过的最后一个案例是，两个应用程序共享相同的数据结构来存储关于两个相对接近的业务对象的信息，但是它们之间的差异足以让人很难理解哪个数据属于哪个应用程序。在这种情况下，两个应用程序都使用这个表来模拟金融市场执行情况，但是使用了不同的聚合级别。没有任何迹象表明这个表中有两种类型的数据，所以我们必须在另一个表(由第二个应用程序拥有)中查找，以确定每个应用程序生成的行...每个新开发人员都不得不在这张表上工作，不可避免地会和他们的前任一样陷入相同的困境，使用不正确的(合理的)数据，给公司带来所有的风险。

# [](#building-your-system-around-a-business-software)围绕商业软件构建你的系统

不是每个公司都能开发出处理所有业务用例的系统。事实上，在许多情况下，这只是重新发明轮子，因为这些用例对许多公司来说是常见的，所以你可以很容易地在市场上找到支持它们的软件。

因此，购买产品通常比制造产品更便宜。但是当然，你刚买的软件不能与你也使用的另一个软件集成，所以你需要在两个(专有的，大部分时间)应用程序之间开发一个连接器。你可能会构建自己的工具来处理业务的特定部分，由于你购买的这个昂贵的软件已经有了一个方便的模型，你可能会尝试使用它的数据库并将你的信息添加到它自己的表中...

几年过去了，几十个开发人员或团队做着同样的事情，然后你就陷入了困境:如果另一个软件的编辑器关闭了，或者如果该产品不再受支持，或者如果另一个新产品更适合你的需要，你就不能使用它了。在某些情况下，你甚至可以在技术上依赖外部软件。如果解决方案的编辑希望你使用语言/框架/服务器/无论什么的每个版本，那么你就不拥有自己系统的架构。如果他们想卖给你一个新版本来提供你绝对需要的特性，但是如果这个版本意味着技术需求的改变，你将被迫更新你所有的技术栈来符合他们的建议。我去过那里，这不是你想经常面对的被迫迁移...

我曾经做过一个项目，我们使用的软件的编辑不想为他们所有的客户开发新功能，因为对于他们来说，处理并发修改和几个当前版本(每个客户都有一个特定的版本，其中包含只有他们想要的功能)变得太复杂了。所以，他们决定卖给我们一个软件开发工具包(SDK ),这样我们就可以实现我们自己的功能。当然，他们没有提供很多关于如何做的文档，而且我们必须使用他们的业务实体，我们需要对其进行反编译以理解其结构，因为我们既没有源代码也没有文档...最简单的特性需要几天才能实现，而且几乎不可测试，因为一切都非常复杂，并且将团队中没有人知道的脚本语言引入到已经很复杂的堆栈中...

# [](#tight-coupling-between-dozens-of-applications)几十个应用程序之间的紧密耦合

还记得 21 世纪初，使用企业 Java Beans (EJB)来处理信息系统中应用程序之间的远程调用的快乐吗？在这个时候，这可能看起来是一个好主意。与其他团队共享您的代码库以避免重复似乎也没问题。是的，每个团队都被迫同时交付他们的应用程序，以确保没有损坏的二进制依赖关系，但这些都是有趣的夜晚，在等待 2 小时交付过程完成的同时与同事一起吃披萨，不是吗？

嗯，事实上并不那么有趣。因为公司里有人喜欢你的代码并决定在他们未经测试的应用程序中使用它，而不能在你自己的代码库中重构一个单独的类，这也不是一件愉快的事情。

一旦你意识到这些早期的决策所造成的混乱，将你的应用程序从世界的其他地方分离出来所需要的努力是势不可挡的。将你的项目分割成不同的组件，使得其他应用程序不能再使用你的核心域、你的客户端或者你的缓存机制，删除与其他项目紧密耦合的外部类，用 REST APIs 替换所有的 EJB 调用，这显然需要花费数年的时间...但是对于参与项目的每个人来说，回报是巨大的:更容易的开发和测试，更快的交付过程，因为不再需要与其他人同步，更好地分离您自己代码中的关注点，更容易的依赖性管理，不再有传递依赖性的问题，因为您在类路径中导入了大量其他应用程序的依赖性...这些昂贵的改变对团队来说真是救命稻草，而且在项目开始时实现它们会便宜得多！

# [](#building-your-project-over-someone-elses-project)在别人的项目上构建你的项目

这个问题可能是你最不可能面对的问题，但它仍然可能发生，这是最糟糕的情况，因为它累积了前面的几个问题。事实上，在我职业生涯中参与的第一个项目中，我就遇到过这个问题。

当我开始这个项目时，我被告知这是对公司系统的全面重写，而且这个项目在 2 个月前刚刚开始。因此，当我看到一个复杂的 web 应用程序，它有一个完整的管理模块，一个已经实现的复杂的业务功能，以及一个帮助开发其他模块的成熟框架时，我感到很惊讶。我很快了解到，所有这些东西大部分都不是团队开发的:团队决定重用团队内部另一家公司开发的框架，以避免从头开始。问题是这个框架没有从它被开发的项目中分离出来。因此，我们的团队刚刚获得了一个包含其他公司项目所有源代码的档案，包括他们的业务代码，这些代码与我们自己的业务毫无共同之处。更糟糕的是，我们还继承了他们的数据库模式和数据...

作为团队中的新人，很难知道哪些代码与框架、我们的项目以及其他公司的业务相关。团队想要清理这种混乱，但是由于代码部分之间的依赖性，许多尝试都以严重的倒退告终(我不能谈论模块，因为只有一个模块！)，当然根本没有自动化测试。此外，我们不得不放弃使用不同的应用服务器的想法，因为系统中到处都有特定于另一家公司使用的应用服务器的代码，这使得这种迁移对于我们的小团队来说过于昂贵。

在某个时候，我们想给框架添加一些好的特性，但是我们被告知其他公司已经这样做了。因此，我们被要求将我们的当前版本与另一家公司的当前版本合并...该团队设法通过精选新特性的一部分来避免这个噩梦，但它仍然比我们需要的更复杂和丰富...

我们设法完成了这个项目，但是我们项目的质量实在令人头疼。至少 40%的代码和数据库内容是无用的，清理这些无用的代码从来就不是首要任务。我希望团队终于有机会隔离自己的代码，因为我离开了团队！

# [](#all-your-business-logic-is-in-a-rule-management-engine)你所有的业务逻辑都在一个规则管理引擎中

将您的业务逻辑放在规则管理系统中是一种常见的做法。例如，当您的一些业务规则需要频繁更新，但是您的整体应用程序的交付过程在能够验证一个发布候选之前需要很长的测试阶段，使得您不可能调整一些“易变的”规则时，这是非常有用的。尽管我更喜欢所有的领域规则都放在代码中，但我能理解有时规则管理系统会有所帮助。

但是我曾经遇到过这样的情况，几乎所有的业务逻辑都位于规则管理系统中，有时规则是从 Excel 文件中生成的！此外，规则不应该经常改变，因为项目基本上是一个 ETL 批处理。所有这一切背后的 Java 项目只是由关于批处理框架和来自源和目标系统的原始读/写的技术细节组成，完全没有涉及领域。

因此，所有的规则都是用团队中没有人真正掌握的特定语言编写的，很难编写(我们的 ide 没有处理它)，并且几乎不可能调试或测试。当请求一个新的规则或对现有规则的更改时，团队中的大多数开发人员只是复制/粘贴一个现有的规则，导致除了一个特定的更改(通常是规则应用的字段)之外的整个相同的文件。

如果这看起来已经很麻烦了，那么在每条规则中都没有关于其目的的线索。规则被命名为 Rule1，Rule2，它们有 100 多条！每个规则基本上都是对硬编码值的检查和赋值，没有任何业务术语。甚至项目的名字也没有解释整个 ETL 的目的。

# [](#conclusion)结论

正如 Bob 叔叔在他的书《干净的架构》中解释的那样，当考虑一个项目的架构时，一些决定必须推迟到我们真正需要做出选择的时候，除非我们不能继续为我们的产品增加价值(比如选择一个数据库)。其他的决定必须尽早做出，不要等到事情变得糟糕的时候。幸运的是，这种关键决策很容易被发现，因为它们可以被称为**架构气味**:当你考虑它时，它们只能是坏主意，会在某个时候回来困扰你。不幸的是，当在遗留软件上工作时，这种负担经常深埋在代码中，使得消除它们非常昂贵。

我们不应该害怕。是的，清理几年甚至几十年的混乱不是一件容易的事情，但是作为软件专业人员，我们不能让它继续腐烂，扼杀开发人员的动力和用户对我们产品的信任，以及我们为他们提供商业价值的能力。

当然，我描述的每一个架构负担都可以用许多方法来解决，所以没有解决每个问题的灵丹妙药。但我相信每个团队都可以提出最终摆脱负担的建议。所以，让我们一起面对我们的问题，并开始清理这个烂摊子！