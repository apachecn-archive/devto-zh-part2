# 返回角度(角度 2+后)

> 原文:[https://dev . to/3zsforinsomnia/return-to-angular js-after-angular-2-FFP](https://dev.to/3zsforinsomnia/returning-to-angularjs-after-angular-2-ffp)

有很多关于从 AngularJS (Ng1)到 Angular 2+ (NgX)的讨论，但是关于从 NgX 到 Ng1 会发生什么的讨论要少得多。在过去几年里，我在一些工作和项目之间做了两次技术上的改变。在这个过程中，我意识到我把这两者之间的许多差异想当然了。

由于越来越多的球队离开安古拉杰，我决定写一些特别让我措手不及的差异。虽然这听起来违反直觉，但我想象许多工程师像我一样，在职业生涯的某个时候离开 Ng1，然后像我一样加入新的团队或项目后又回到 Ng1。这些项目中的许多仍然需要具有 Ng1 经验的开发人员来维护遗留代码或编写新的 Ng1 产品。有时这发生在他们最后一次 Ng1 体验后几个月，但也可能是他们最后一次接触后很久。

我不会关注 Ng1 及其 NgX 继任者的技术细节，而是关注不同的开发者体验。显然会有一些技术细节。

我开始使用 Ng1 进行前端开发，虽然我从未爱上 Ng1，但我确实喜欢上了这个框架。它提供了我所需要的，以及一个足够简单的学习曲线来编写干净的和可重用的代码。我用它工作了一段时间，了解了对于我自己和我的团队的编码风格，哪些部分应该避免，哪些部分工作得更好。我避免了为每个指令使用单独的控制器，而是在大多数情况下将东西直接链接到指令。我非常依赖框架的其他方面，比如依赖注入和自动变更检测。

然后我换了项目，开始使用 NgX，除了 observables 之外，这是一个比 Ng1 更简单的学习曲线。很明显，这部分是因为我以前使用 Ng1 的经历，Ng1 确实有一些基本的相似之处。但是特别是可观察性起初提出了一些挑战，主要是因为我对可观察的执行序列和该序列的观察者之间的区别有一个误解。但是除了那短暂的打嗝，NgX 是美丽的。组件感觉不仅仅是自我包含，而是真正的主权和控制自己的存在。类型更好的依赖注入系统意味着我可以更容易地避免“道具训练”。当一个值通过许多组件传递时，这是我在 Ng1 的指令层次结构中遇到的一个常见问题。NgX 里的东西只是感觉...自然。

将值作为普通的 Javascript/TypeScript 使用是很自然的，不需要为我的对象添加任何框架属性，比如$$hashKey，并且使用 observables 对事件列表进行操作。使用这种新型的动态依赖注入系统也很有趣。所有这些都是由 RxJs observables、TypeScript 和一个更专注、更有主见的框架支持的，为开发人员带来了美妙的体验。

然后我搬回 Ng1。

老实说，在我熟悉 NgX 的一年多时间里，我已经忘记了我使用异步行为的频率。我忘记了 Ng1 在它的摘要周期中使用$$hashKey 来跟踪变化检测的值。我已经忘记了为什么不变性在我的 NgX 编码模式中变得如此突出。

这些问题以这样的方式出现，虽然是一次重要的(重新)学习经历，但却是痛苦的，我觉得没有必要在回到 Ng1 后仍然处理这些问题。Ng1 对$$hashKey 属性的使用意味着无论何时在 Ng1 的上下文中创建一个对象，我都必须注意并记住它在做什么。我不能再使用 Object.assign()或 spread 操作符来创建基于现有对象的新对象，并将它们称为不可变对象，因为$$hashKey 属性将被包含在内，除非被显式处理或删除。Ng1 仍然会在摘要周期中跟踪对象并更新它。这对我在 Ng1 中使用 Redux 造成了很大的麻烦，因为它会导致意想不到的不必要的同步变化。

更尴尬的是，当我想当然地认为 NgX 中的 safety zone.js 提供了安全区域时，实现异步行为的问题出现了。也就是说，zone.js 保证异步代码只有在进行异步调用的函数完成时才会运行，从而确保了预期的执行路径。虽然这是 NgX 中的一个很棒的特性，但是当我返回 Ng1 并编写由于在中间调用异步函数而无法完成的函数时，我并没有考虑到这一点，因为它会劫持我预期的执行序列。在我的 React 开发经验中，我记得正确处理异步行为，但是忘记了 Ng1 和 NgX 之间如何处理异步活动的这一重要区别。

随着我过度使用范围事件，我的问题继续存在。这是我在作为 Ng1 开发者的第一阶段特意避免做的事情。在 NgX 中，我发现每当我需要对事件做出反应时，简单地订阅一个可观察对象是如此容易，但是在 Ng1 中，我发现用范围事件扩展这种方法要困难得多。结果很复杂，很难调试，因为作用域事件跨越了组件层次结构中过于广泛的区域。使问题更加严重的是，范围事件没有提供给使用它们的指令或组件，但是可以从几乎任何地方发出或执行。在 NgX 中，可观测量主要作为输入(例如 EventEmitters)或通过注入的依赖项(如服务)提供给客户端组件。

总而言之，这对我绝对是一个有价值的教训。耐心，记住旧的实践和模式，在继续之前需要花更多的时间重新熟悉我的旧工具集。希望这篇文章强调了其他人可能遇到的一些问题，以便他们能够比我的第一个月更顺利地重新融入 Ng1。

在评论中分享你自己重新学习技术的经历吧！