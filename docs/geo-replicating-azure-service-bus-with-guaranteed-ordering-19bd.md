# 具有保证排序的地理复制 Azure 服务总线

> 原文：<https://dev.to/jpda/geo-replicating-azure-service-bus-with-guaranteed-ordering-19bd>

[![Photo by [Slava Bowman](https://unsplash.com/@slavab)](../Images/4b96f0c1de74ef02ca393bff15322788.png) ](https://res.cloudinary.com/practicaldev/image/fetch/s--cnubo8eP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://jpda.dev/img/0_eAcdrF5a1HTPad7v.jpg) *摄影作者[斯拉瓦·鲍曼](https://unsplash.com/@slavab?utm_source=medium&utm_medium=referral)*

最近，一位客户向我提出了一个有趣的问题:

> 我们如何确保服务总线消息排序**和**获得主动/主动地理可用性？

这些年来，我们已经用许多方法解决了部分问题——服务总线支持[成对的名称空间](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-async-messaging#paired-namespaces)——但是有一个包括无序消息的警告列表。这也是*发送*可用性与*接收*可用性的问题。我们希望我们的生产者总是能够发送信息——这意味着我们的接收者/消费者需要更聪明，但我们稍后会谈到这一点。

在我们的特定场景中，全局消息排序不如事务性或作用域消息排序重要——考虑 10 个事务，0、1、4 和 5 是相关的，2、3 和 6 是相关的，7、8 和 9 是相关的。这三个批次可以按任意顺序处理，但是特定批次或范围内的消息*需要按顺序处理。当客户与遗留系统或大型机集成时，我们经常会看到这个问题。*

举个更具体的例子，假设我正在跟踪很多货物。我有许多货物，每个货物都有一个状态集合。这些状态是连续的——从西雅图发往夏洛特的包裹在离开西雅图之前可能不会到达得梅因。

这里有一些数据:

然而，如果我有多个包，我真的不在乎包 A 或包 B 的状态是否先在我的后端系统中更新，只要每个特定包的状态消息的顺序保持一致。

另一个例子是从数据库系统中捕获变更数据。如果我在删除后运行插入，即使删除先发生，我的数据也不会是正确的。

回到我们的货件跟踪场景。首先，我们需要一种方法来确保我们的服务总线队列或主题中的消息排序。为此，我们将使用[消息会话](https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions)。然而，消息会话有一些其他的折衷——会话 ID 实际上是一个分区键。这意味着带有该键的数据被粘贴到特定的数据存储中。想想也有道理；分布在多个数据存储中的消息需要更多的服务器端处理来收集和排序。

按序处理还意味着其他一些权衡——根据定义，消息是按顺序、连续地处理的，一次由一个消费者处理——这里没有处理并行性(嗯，至少不是在我们的单个会话中——我们很快就会实现)。

会话中的消息是 FIFO，但不一定是我们的会话本身。我们可能有许多会话要处理，我们希望同时处理这些会话。请记住，我们只关心我们的会话/装运范围内的订单保证*。这样，我们仍然可以确保及时处理消息，而不会影响我们的订购要求。*

在一个蔚蓝的区域，这没什么大不了的。我们的服务总线名称空间在美国东部，我们的生产者和消费者住在同一个地区。Azure 中的全区域故障当然非常罕见，但也不是完全没有听说过。服务降级或特定服务中断以及相关服务(例如，当存储中断导致区域内其他服务的级联故障时)仍然是一个问题。对于我们的客户来说，他们部署在美国的两个地区，应用服务、SQL DB、存储等都可以以某种方式在地理上复制(或无状态)。服务总线是我们没有令人信服的答案的一件事，所以我们决定为他们建立一种实现它的方法。

让我们从代码开始，它在这里:[https://github.com/jpda/azure-service-bus-active-rep](https://github.com/jpda/azure-service-bus-active-rep)—我们将使用:

*   不同区域中的两个服务总线名称空间。
*   一个[强一致性的 Cosmos DB](https://docs.microsoft.com/en-us/azure/cosmos-db/consistency-levels#consistency-levels) 集合，作为一个消息日志
*   服务总线队列中的消息会话

### 发送可用性

为了维护发送可用性，我们将设置两个独立的服务总线名称空间，并在每个名称空间中创建一个启用会话的队列。如果您的情况需要，您也可以对主题这样做。

每个发送者将使用某种确定性 ID 或域唯一密钥来标记会话。在我们的运输场景中，跟踪号将是一个非常好的会话密钥。它也可以是代表所发送消息范围的其他一些唯一的 ID——客户 ID、交易 ID 等。您的发送者应该使用相同的会话和消息 id 将消息发送到两个队列中的**。**

实际上，会话 ID 代表您想要“锁定”的实体的 ID——因为消费者将尝试使用实体 ID(会话或消息)作为文档 ID 来记录他们在 Cosmos DB 集合中的工作项，如果存在文档 ID 冲突，消费者将收到一个异常，并在开始处理之前重新提取实体以获得最新状态。我们将在下面深入探讨这个问题。

您还会在发送者中注意到，我们在其中一个队列上将 ScheduledEnqueueTimeUtc 设置为 now + 15 秒。我们稍后会解决这个问题，但这主要是为了减少客户流失，并优先选择一个“主要”区域。

[https://github . com/JPDA/azure-service-bus-active-rep/tree/master/azure-service-bus-active-sender](https://github.com/jpda/azure-service-bus-active-rep/tree/master/azure-service-bus-active-sender)

### 接收可用性

当您拥有同一消息的多个副本时，接收可用性就变得棘手了，尤其是在您无法完全控制数据最终目的地的集成情况下。在我们的例子中，我们正在与一台大型机(以及其他系统)进行交互，并且不希望通过查询大型机来删除重复的消息，从而增加不必要的压力。

相反，我们的消费者遵循一个相当简单(尽管很健谈)的模式:

*   打开消息会话
*   使用 SessionId 或 SessionId_MessageId 作为文档 Id 创建新文档
*   如果我们成功创建了文档，那么我们将更新文档中的状态(例如，状态:正在工作)
*   如果我们得到一个 409(冲突)，我们从 Cosmos 获取最新版本的文档并检查状态
*   如果状态是挂起，我们将状态更新为工作中，尝试再次写入，等待 200
*   如果我们成功了，我们就开始处理信息
*   完成后，我们再次更新文档并完成服务总线消息。

这太多了，所以我们将把它分解一下。

*   首先我们开始接收一个`MessageSession`。这将锁定/隐藏特定队列中带有那个`SessionID`的所有其他消息，因此我们可以确保这个消费者将按照收到的顺序处理它们。
*   在开始处理消息之前，我们在日志(我们的 Cosmos DB 集合)中记录会话 ID 或会话/消息 ID 组合。因为我们使用它作为我们的文档 ID，如果有冲突(例如，另一个消费者已经创建了文档)，Cosmos 将返回一个`409 Conflict`——此时我们知道另一个消费者已经开始读取我们的一个队列中的会话。
*   如果日志写入成功，我们将尝试更新文档——将名为 Status 的字段更新为 Pending 或 Working。
*   此更新遵循相同的规则；如果我们更新的文档比数据库中的旧，Cosmos 会返回一个错误代码——此时我们会获取最新的版本，检查状态并从那里做出决定。
*   如果状态更新成功(例如，我们已经将状态更新为工作中)，我们就可以开始工作了。
*   这两个操作是离散的(而不是单个操作),这意味着我们保持了较小的更改窗口。
*   当我们处理完消息后，我们可以完成该消息，将其从队列中移除，并开始处理下一个消息。
*   次要区域中的另一个消费者将提取文档，看到状态为“正在工作”并放弃消息；在此放弃将导致消息解锁，下一个消费者将尝试获取它。当使用者阅读消息、检查状态并看到完成状态时，辅助队列中的消息将被完成(注意，在今天的代码示例中，使用者没有放弃消息，而是通过休眠/等待来重新检查消息状态)。

在一个失败的案例中，其中一个消费者失败了，我们有两个阶段的失败:

消费者中的处理逻辑已经死亡，但流程没有死亡(例如，托管处理逻辑的流程仍然活着)—在这种情况下，我们的处理器可以尝试重新处理，或者在不可撤销的失败的情况下，将该消息或会话的日志状态更新为失败或出错，并将该消息移动到死信队列进行手动修复。

如果消费者已经完全死亡(比如，流程已经完全死亡)，我们可以在用于配置`SessionHandler`的`SessionHandlerOptions`上使用`MessageWaitTimeout`来设置一个合理的超时。一旦超时时间过去，会话被解锁，我们的下一个消费者将获取会话，在 Cosmos 中检查状态并继续处理。

[https://github . com/JPDA/azure-service-bus-active-rep/blob/master/azure-service-bus-active-receiver-lib/data receiver . cs](https://github.com/jpda/azure-service-bus-active-rep/blob/master/azure-service-bus-active-receiver-lib/DataReceiver.cs)

### 实体锁

您对实体锁的选择有一些含义。如果您选择在会话级别锁定，您的二级接收者将放弃*会话*，此时您的主要消费者将处理整个会话。这里的风险是，万一失败，您可能需要管理会话中处理了哪些消息—例如，会话 ID 1 有消息 A B C 和 d。A 和 B 处理正确，但 C 导致消费者死亡；二级消费者需要重新处理会话副本中的所有消息(因为它不知道哪些消息已经被处理过)，支持至少一次传递，或者它需要一个消息处理日志来确保它不会第二次处理一个消息。

如果采用会话+消息复合 ID 的方法，即记录会话中的每条消息，那么就能够在会话级和消息级保持两个队列的同步。当消息在主队列中改变状态时，当辅助处理器获得该改变时，它们将处理该消息以进行镜像(例如，会话 1 消息 A，主队列已完成，日志已更新，当会话 1 消息 A 辅助队列使用该 ID 检查 Cosmos 并看到它已完成时，它将完成辅助消息)。这里的风险是潜在的无序情况，即由于日志出现未知故障，辅助节点领先于主节点。我还没有想出会发生这种情况的情况，因为消息在两个队列中的顺序应该相同，但是理论上:

*   **主要**消息 1 →写入宇宙记录→开始处理
*   **二级**信息 2 →未写入宇宙记录→开始处理

### 负载均衡

在我们的场景中，我们有一组遗留系统，一些是单实例的，一些是本地的。我们希望我们的大部分流量通过一个“主要”Azure 区域，最接近我们的内部系统，但在区域故障的情况下故障转移到不同的区域。

此外，这种模式类似于我们已经在使用的产品(如 SQL DB geo-failover)，因此我们在任何情况下都已经在遵循这种主/辅类型的模式。

也就是说，这种相同的模式可以用于处理任何地区、任何消费者的消息，以获得潜在的更大规模和吞吐量。

### 附加注释+想法

如前所述，这里的*发送者*决定锁定哪个实体——例如，如果我们希望锁定单个消息(而不是整个会话),发送者可以使用一个完全唯一或更细粒度的会话 id(可能是一个复合 ID，如`PackageId_ShipmentStatusId`),这将反映在日志中。在这种情况下，我们的主要和次要消费者可以在每个队列中独立使用会话。只要实体锁定(通过扩展，实体 ID 生成方案)是一致的，接收者就不关心哪个实体被锁定。

我们以 15 秒的延迟将带有`ScheduledEnqueueTimeUtc`的消息写入辅助队列，主要是为了让我们的主区域优先于辅助区域。如果一切都正常运行，那么在消息出现在辅助队列中之前，应该为主要的消费者提供足够的时间来接收、检查和记录工作项目。

这是一项正在进行的工作，所以欢迎反馈。