# 重构遗留整体——第 1 部分:第一步

> 原文:[https://dev.to/jamesmh/refactoring-legacy-monoliths-第一部分-第一步-58a9](https://dev.to/jamesmh/refactoring-legacy-monoliths---part-1-first-steps-58a9)

*最初发表于[我的博客](https://www.blog.jamesmichaelhickey.com/refactoring-legacy-monoliths-first-steps/)。*

当考虑“修复”或重构遗留系统时，你从哪里开始呢？

# 什么是遗产独石？

在《有效使用遗留代码》一书中，“遗留”软件仅仅被定义为“没有测试的代码”我们做了一些注释，其中包含了这样的想法:设计糟糕或代码不可维护的软件是“遗留”的一大部分。

> “重构遗留软件”意味着重构你的系统以允许代码测试，然后实现这些测试。

一个“整体”基本上是“你所有的代码都在一个地方。”换句话说，您没有将您的**产品**的不同逻辑区域分隔成隔离的区域。

例如，如果你正在开发一个基于. NET 的 web 应用程序，并且你的所有代码都在一个项目中(web 项目)，那么你肯定有一个整体。

如果您的部署过程要求在添加任何新功能或修复错误时“推动”整个系统，那么这就是一个整体。

# 现实的目标

在我们更改现有代码之前，认为“遗留”代码存在的想法表明该产品的软件过程没有很好地工作。我们需要考虑一个更高层次的问题:“我们如何创建软件？”

我认为，您在遗留项目中可能遇到的问题可以归结为一个核心问题:

> 软件不是使用已知的当前行业标准设计的。

这些标准有哪些？

*   测试代码
*   将业务逻辑与表示逻辑分离开来
*   当可靠的库存在来做你需要的事情时，不要重新发明轮子
*   避免贬值的第三方软件(无论是供应商还是开发社区都这么认为)

你还能想到更多吗？我很想在评论中听到你的意见。:)

# 防患于未然

因此，我们首先需要着手解决这些问题。但即使在此之前，我们需要意识到所有未来的软件创作都是**仍然**遵循当前存在的任何过程！

最近经历了这些，并为未来的发展创造了一个基础——至少—**允许**遵循这些标准，我想我有了一些见解。所以我们的第一步就是:

> 使系统至少**允许**未来的开发遵循行业标准。

# 实用步骤

最重要的一点，回到“遗留”软件的定义——是你需要代码测试。为什么？

*   系统需求的更清晰的定义(因为测试对应于单独的业务需求)
*   强制你的系统模块化(例如，可以很好测试的代码通常设计得很好)
*   当您的代码出错时的早期安全网

但是，为了能够正确地测试，您需要将您的业务代码(即“业务逻辑”)从您的(例如)web 项目中分离出来。除非能够测试业务逻辑本身，否则无法测试业务规则。对于 web 项目来说，将代码分成(至少)两个不同的层是必要的，因为:

> 您的业务代码可以依赖于数据库访问抽象，而不是数据库访问实现。

什么？让我问你一个问题:“你能在没有活动数据库的情况下测试你的代码吗？”在真正的“遗留”项目中，99%的情况下答案是“不”。

我们需要的是让我们的代码依赖于一个公开提供数据库访问的`methods`的`interface`。然后，我们可以根据该接口创建我们的产品代码。我们的系统需要以某种方式自动将那个`interface`的具体实现“传入”到我们的业务代码中。

另一方面，我们的测试可以使用实现那个`interface`的存根或模拟对象。我们的业务代码仍然会做它该做的事情，不会崩溃，因为没有数据库连接。

# 我们在思考...

因此，我们正在思考核心问题，以及我们需要做些什么来解决这些问题。在本系列的下一部分，我们将着眼于试图说服管理层，我们确实需要改变软件在我们组织中的制作方式。

让我知道你的想法——或者我是否错过了什么等等。谢谢！

# 保持联系

别忘了在 [twitter](https://twitter.com/jamesmh_dev) 或 [LinkedIn](https://www.linkedin.com/in/jamesmhickey/) 上联系我！

# 导航您的软件开发生涯

一封电子邮件简讯，我将在其中回答订阅者的问题，并就以下主题提供建议:

✔:软件开发人员的一般阶段是什么？✔:我怎么知道自己处于哪个阶段？我如何进入下一阶段？
✔什么是技术领导者，我如何成为一名技术领导者？

听起来有趣吗？加入社区吧！