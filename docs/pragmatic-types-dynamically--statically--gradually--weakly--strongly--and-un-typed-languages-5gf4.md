# 语用类型:动态语言、静态语言、渐进语言、弱类型语言、强类型语言和非类型语言

> 原文：<https://dev.to/stereobooster/pragmatic-types-dynamically--statically--gradually--weakly--strongly--and-un-typed-languages-5gf4>

请阅读[文章“什么是类型？”](https://dev.to/stereobooster/pragmatic-types-what-are-types-45jn)在这之前。如果你决定跳过前一章，这里是你需要知道的:我将**类型**定义为事物的集合，将**类型检查**定义为检测事物是否属于集合以防止无意义操作的过程。

## 动态类型或动态类型

如果您将动态类型更改为动态检查类型，这就更清楚了——这意味着类型检查发生在运行时。

### 概念性的观点

从概念上讲，运行时的任何类型检查都可以被视为一个动态类型系统，它包括 IO 验证，例如当程序从输入中读取一个字符串并检查这是否是数字时。

### 实现观点

从实现的角度来看，动态类型化的语言需要在运行时拥有关于类型的数据——存储在内存中的每个值还应该存储一些指向类型描述符的标志或指针。

在 OOP 语言中，如 Ruby 或 Smalltalk，每个值都存储一个指向类的指针，因为方法存储在类中并在所有实例之间共享(这个规则有一些例外，但我们不关注这个)。这使得一些 OOP 语言自动动态类型化。

如果您能够在运行时自省类型，或者在运行时比较类型，或者根据类型或反射进行模式匹配——从实现的角度来看，所有这些都可以被视为动态类型。

我更喜欢使用概念性的观点，因为这更容易区分，你不需要知道实现细节。

## 静态类型或静态类型

如果您将静态类型更改为静态检查类型，这将变得更加清楚——这意味着类型检查发生在运行时之前，它可以是其他步骤中的一个，就像编译、蒸腾、林挺。

## 动态 vs 静态类型

大多数时候，动态类型被认为是静态类型的对立面。动态和静态类型没有冲突，**语言可以同时被动态检查和静态检查**。

## 渐进型系统

有一种趋势是将静态类型分析器添加到现有的动态语言中，例如，用于 Javascript 的 Flow、用于 Ruby 的 Diamondback 和 Sorbet。这种将静态类型检查“逐渐”引入动态检查语言的系统，就是人们所说的渐进类型系统。

## 非类型化语言

如果你读了“什么是类型？”您知道，类型更多的是一种概念性的东西，以防止出现无意义的情况，比如对不合适的类型应用操作。你如何避免这种情况，以便能够在概念层面上拒绝类型？简单——确保系统中只有一种类型，比如汇编语言——所有的值都是位串。当只有一种类型时，对错误类型的值应用运算就不会有问题。

无类型语言——是只有一种类型的语言(或者没有变量的语言，没有大的应用领域)。

> 从非类型化宇宙到类型化宇宙的道路已经在许多不同的领域被遵循了很多次，而且很大程度上是出于同样的原因。例如，考虑以下非类型化的宇宙:
> (1)计算机内存中的位串
> (2)纯 Lisp 中的 S 表达式
> (3) λ演算中的λ表达式
> (4)集合论中的集合
> 
> - [理解类型、数据抽象和多态性](http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf)

## 弱型和强型系统

绝对没有办法定义这个术语的含义，所以避免使用它以防止对话中的混淆。可以说一个类型系统比另一个更强大，比如 Haskell 的类型系统比 Go 的更强大，Agda 的比 Haskel 的更强大(我猜的)，但是独立的术语“弱”和“强”没有太大意义。

其他人试图解释强势与弱势:

*   在讨论类型系统之前应该知道什么
*   加里·伯恩哈特 2017 年出版的《懂编程语言的人的类型》

[这篇文章是](https://dev.to/t/pragmatictypes)系列文章的一部分。在[推特](https://twitter.com/stereobooster)和 [github](https://github.com/stereobooster) 上关注我。