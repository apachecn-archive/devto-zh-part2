# x86 ISA 扩展第一部分:MMX

> 原文:[https://dev.to/ilevex/x86-isa-extensions-part-i-mmx-1hjf](https://dev.to/ilevex/x86-isa-extensions-part-i-mmx-1hjf)

欢迎来到关于 x86 体系结构指令集扩展的系列文章。X86 是一种计算机体系结构，多年来一直在发展负载，并且对原始指令集进行了许多扩展(包括 64 位“长”模式)。在几篇博文中，我们探索了这些扩展及其存在背后的原因。

所以，我想谈的第一个扩展是 MMX 扩展，它最初是在 20 世纪 90 年代末随奔腾 P5 系列英特尔处理器推出的。让我们开始吧！

## 有 MMX 吗？

与每个指令集扩展一样，系统的 CPU 可能不支持它。鉴于 MMX 已经存在了很长时间，这种可能性非常小，但为了确保安全，请遵循以下说明:

在 Linux 上:

```
$ cat /proc/cpuinfo | grep -wq mmx && echo "MMX available" || echo "MMX not available" 
```

在 OS X/macOS 上:

```
$ sysctl machdep.cpu.features | grep -wq MMX && echo "MMX available" || echo "MMX not available" 
```

或者，您可以使用`CPUID`指令来判断您的 CPU 是否支持 MMX(如 Leaf 1 的第 23 位所示):

```
.text
.globl _is_mmx_available
_is_mmx_available:
    pushq   %rbx

    movq    $1, %rax
    cpuid
    movq    %rdx, %rax
    shrq    $23, %rax
    andq    $1, %rax

    popq    %rbx
    ret 
```

## 技术细节

有趣的是，MMX 没有引入新的寄存器，而是选择为 80 位 x87 FPU 寄存器的底部 64 位引入别名。这些被称为`%mmx0, %mmx1, ..., %mmx7`。由于这些只是别名而不是真正的寄存器，很明显，当 FPU 操作正在进行时，这些寄存器不能使用。由于 FPU 寄存器是 80 位长，而 MMX“寄存器”是 64 位的，所以注意这些 FPU 寄存器中 MMX 寄存器的位置很重要:它们构成了原始 FPU 寄存器的 64 位尾数，其余 16 位都设置为 1。这很有用，因为这意味着 FPU 可以将寄存器中的 SIMD 数据识别为 NaN 或无穷大，当然，软件也可以区分这两种类型的数据。

但是为什么英特尔选择使用别名而不是增加新的寄存器呢？他们希望与现有操作系统的上下文切换代码兼容，这些代码已经知道如何保存和恢复 FPU 寄存器，现在凭借别名，它还支持保存和恢复 MMX 寄存器。

MMX 的主要卖点是能够将多个值打包到 MMX 寄存器中，并在一条指令中单独对每个值进行操作，因此具有 SIMD ( *单指令多数据*)的特性。单个 MMX 寄存器中可以有八个单字节值:

```
%mmx0 = 
+------+------+------+------+------+------+------+------+
|   7  |   6  |  5   |   4  |   3  |   2  |  1   |   0  | Byte
+------+------+------+------+------+------+------+------+
| 0x11 | 0x22 | 0x33 | 0x44 | 0x55 | 0x66 | 0x77 | 0x88 | Values
+------+------+------+------+------+------+------+------+ 
```

或者可能在寄存器中有两个 4 字节长的值:

```
%mmx1 = 
+------+------+------+------+------+------+------+------+
|   7  |   6  |  5   |   4  |   3  |   2  |  1   |   0  | Byte
+------+------+------+------+------+------+------+------+
|          0xcc77ff88       |          0x11223344       | Values
+------+------+------+------+------+------+------+------+ 
```

类似地，也可能有四个双字节值。

## 新指令

新指令的使用示例可以在本系列的 [GitHub Repo](https://github.com/levex/x86-isa-extensions/tree/master/mmx) 中找到。它只是将两个乘以四的单字节值相加。

下表列出了 MMX 提出的一些简单说明:

| 指令 | 描述 |
| --- | --- |
| `emms` | 重置 MMX 状态 |
| `paddb` / `paddw` / `paddd` / `paddq` | 添加两组字节、字、双字或四字 |
| `psub` / `psubw` / `psubd` / `psubq` | 减去两组字节、字、双字或四字 |
| `pcmpeqb` / `pcmpeqw` / `pcmpeqd` / `pcmpeqq` | 比较两组字节、字、双字或四字的相等性 |

更复杂的指令是`unpck`类指令，它允许通过将组大小加倍来交错来自两组数据的数据:

*   `punpckhbw`
*   `punpckhwd`
*   `punpckhdq`
*   `punpcklbw`
*   `punpcklwd`
*   `punpckldq`

下图很好地描述了由`punpckhbw`完成的交错，但是让我们将这个指令分解成一个更易读的形式:

*   `p` = >打包
*   `unpck` = >解包
*   `h` = >高阶
*   `b` = >从字节
*   `w` = >来的话

综上所述，这似乎意味着该指令将一组字节的高位部分(上半部分)交错到目标寄存器的一组字中。这可能仍然很令人困惑，所以我希望这里有一个图表能更好地解释它:

```
 Source Register                          Destination Register                     

+----+----+----+----+----+----+----+----+   +----+----+----+----+----+----+----+----+          
| Y7 | Y6 | Y5 | Y4 | Y3 | Y2 | Y1 | Y0 |   | X7 | X6 | X5 | X4 | X3 | X2 | X1 | X0 |          
+----+----+----+----+----+----+----+----+   +----+----+----+----+----+----+----+----+          
   |    |    |    |                            |    |    |    |                                
   |    |    |    |                            |    |    |    |                                
   |    |    |    |                            |    |    |    |                                
   |    |    |    |           +---------+------+--+-+----+  +-+                                
   |    |    |    |           |         |         |         |                                  
   |    |    |    |           |         |         |         |                                  
   |    |    |    |           v         v         v         v                                  
   |    |    |    |   +----+----+----+----+----+----+----+----+                                
   |    |    |    |   | Y7 | X7 | Y6 | X6 | Y5 | X5 | Y4 | X4 | Destination Register           
   |    |    |    |   +----+----+----+----+----+----+----+----+                                
   |    |    |    |      ^         ^         ^         ^                                       
   |    |    |    |      |         |         |         |                                       
   +----+----+----+------+---------+---------+---------+ 
```

## 继任者

AMD 很快跟上了英特尔 MMX 的发展，命名为“3DNow！”这并没有取得多大成功，但是我们将在本系列的下一期文章中讨论它。

其他继任者包括英特尔的“扩展 MMX”和 SSE ( *流式 SIMD 扩展*)。《扩展的 MMX》引起了人们的特别兴趣，因为它向 MMX 介绍了几个新的、有趣的指令:

| 指令 | 描述 |
| --- | --- |
| `movntq` | 将一个四字(64 位值)移到内存中，不要放在缓存中(绕过缓存) |
| `pextrw` | 从一组单词中提取一个(特定的)单词 |
| `pinsrw` | 将单词插入到组中的指定位置 |
| `pmovmskb` | 从 MMX 寄存器中八个单字节值的最高有效位创建一个 8 位整数 |
| `pavgb` / `pavgw` | 平均(无符号)字节或字 |

## 结论

我希望你喜欢这一部分，并会喜欢这个系列的其余部分。我将非常感谢您的任何反馈。如果你有一个 MMX 用例的例子，很高兴收到你的来信，当然，也可以随时向上面链接的回购提交拉请求。