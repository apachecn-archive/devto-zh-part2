# ç”¨æ¦†æ ‘å¯»æ‰¾çœŸç›¸

> åŸæ–‡:[https://dev.to/1hko/finding-truth-with-elm-7on](https://dev.to/1hko/finding-truth-with-elm-7on)

å½“ä½¿ç”¨[å‘½é¢˜é€»è¾‘](https://en.wikipedia.org/wiki/Propositional_calculus)æ—¶ï¼Œéœ€è¦åˆ›å»º[çœŸå€¼è¡¨](https://en.wikipedia.org/wiki/Truth_table)ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤º

| **P** | **é—®** | **P** | **P âˆ¨ Q** | **P â‡’ Q** |
| --- | --- | --- | --- | --- |
| T | T | F | T | T |
| T | F | F | F | F |
| F | T | T | T | T |
| F | F | T | T | T |

> ***è¡¨ 1***
> 
> *   *`P â‡’ Q`åœ¨é€»è¾‘ä¸Šç­‰åŒäº`Â¬P âˆ¨ Q`*

åšè¿™ä¸ªç»ƒä¹ å¾ˆé‡è¦ï¼Œä½†ä¹Ÿå¾ˆå®¹æ˜“å‡ºé”™ã€‚å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªç¨‹åºä¸ºæˆ‘ä»¬ç”ŸæˆçœŸå€¼è¡¨ï¼Œæˆ‘ä»¬å¯ä»¥æ›´ç¡®å®šç»“æœã€‚è¿™è®©æ‡’æƒ°æˆä¸ºå¯èƒ½ï¼Œæ‰€ä»¥æˆ‘ä»¬å½“ç„¶æƒ³è¿™ä¹ˆåšã€‚

### [](#goal)ç›®æ ‡

ç¨‹åºåº”è¯¥æ˜¯ç›´è§‚çš„ï¼Œç®€å•åœ°æ¥å—ä¸€ä¸ªå‘½é¢˜è¡¨è¾¾å¼åˆ—è¡¨ã€‚å¯¹è¡¨è¾¾å¼çš„åˆ†æå°†å†³å®šæ„å»ºå“ªäº›`True` / `False`æ’åˆ—ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢è¿™ç»„è¡¨è¾¾å¼åŒ…å« 3 ä¸ªå”¯ä¸€å˜é‡`P`ã€`Q`å’Œ`R`

| **P** | **é—®** | **R** | **(P â‡’ Q) â‡’ R** | **P â‡’ (Q â‡’ R)** | **(P â‡’ R) âˆ¨ (Q â‡’ R)** |
| --- | --- | --- | --- | --- | --- |
| T | T | T | T | T | T |
| T | T | F | F | F | F |
| T | F | T | T | T | T |
| T | F | F | T | T | T |
| F | T | T | T | T | T |
| F | T | F | F | T | T |
| F | F | T | T | T | T |
| F | F | F | F | T | T |

> ***è¡¨äºŒ***
> 
> *   *`â‡’`ä¸å¯äº¤æ¢*
> *   *`(P â‡’ Q) â‡’ R`ä¸ç­‰åŒäº`P â‡’ (Q â‡’ R)`*
> *   *`P â‡’ (Q â‡’ R)`åœ¨é€»è¾‘ä¸Šç­‰åŒäº`(P â‡’ R) âˆ¨ (Q â‡’ R)`*

* * *

### [](#now-available-as-a-package)ç°å·²ä½œä¸ºä¸€ä¸ªåŒ…æä¾›

è¿™ä¸ªç¨‹åºç°åœ¨å­˜åœ¨äº Elm åŒ…åº“ä¸­ï¼Œ [`1hko/elm-truth-table`](http://package.elm-lang.org/packages/1hko/elm-truth-table/latest) ã€‚ä½ åœ¨è¿™ç¯‡æ–‡ç« ä¸­çœ‹åˆ°çš„ä»£ç å¤§éƒ¨åˆ†æ˜¯ç›¸åŒçš„ï¼Œåªæ˜¯æœ‰ä¸€äº›ä¸œè¥¿è¢«é‡å‘½åäº†ã€‚

* * *

### [](#possible-api)å¯èƒ½çš„ API

æˆ‘ä¸æ˜¯åœ¨æ‰¾ä»€ä¹ˆèŠ±å“¨çš„ä¸œè¥¿ã€‚å‘½é¢˜åº”è¯¥æ˜“äºæŒ‡å®šï¼Œå…è®¸ç”¨æˆ·åœ¨ä¸€ç»„è¡¨è¾¾å¼ä¸­æŒ‡å®šä»»æ„æ•°é‡çš„å˜é‡â€”

```
type Expr =
    -- ...

truthTable : List Expr -> Html msg
truthTable exprs =
    -- ...

-- table 1
truthTable
    [ Not (Var "P")                  -- Â¬P
    , Or (Not (Var "P")) (Var "Q")   -- Â¬P âˆ¨ Q
    , Implies (Var "P")  (Var "Q")   -- P â‡’ Q
    ]

-- table 2
truthTable
    -- (P => Q) => R
    [ Implies (Implies (Var "P")  (Var "Q")) (Var "R")

    -- P => (Q => R)
    , Implies (Var "P") (Implies (Var "Q")  (Var "R"))

    -- (P â‡’ R) âˆ¨ (Q â‡’ R)
    , Or (Implies (Var "P") (Var "R")) (Implies (Var "Q") (Var "R"))
    ] 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

ç¨åæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå°†`"Q => P" : String`è§£æä¸º`Implies (Var "Q") (Var "P") : Expr`çš„`String -> Expr`å‡½æ•°ã€‚ä½†æ˜¯ç°åœ¨ï¼Œè¿™æ˜¯æˆ‘ä»¬å¼€å§‹çš„å…¨éƒ¨éœ€è¦ã€‚

* * *

### [](#implementation)å®ç°

å•ä¸ªè”åˆç±»å‹`Expr`è¶³ä»¥æ»¡è¶³æˆ‘ä»¬ç¨‹åºçš„éœ€æ±‚ã€‚æˆ‘å°†åœ¨è¿™é‡Œå±•ç¤ºå®Œæ•´çš„ç±»å‹ï¼Œä½†æ˜¯æˆ‘çŸ¥é“åœ¨è¿›å…¥ä¸‹ä¸€ä¸ª
ä¹‹å‰ï¼Œæˆ‘å·²ç»å®Œå…¨å®ç°äº†ä¸€ä¸ªå˜ä½“

```
type Expr
    = Or Expr Expr
    | And Expr Expr
    | Xor Expr Expr
    | Implies Expr Expr
    | Equiv Expr Expr
    | Not Expr
    | Var String 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

#### [](#table-header)è¡¨å¤´

æ¯å¼ æ¡Œå­éƒ½ä»¥`<thead>`å¼€å¤´ã€‚æˆ‘ä»¬çš„ç¨‹åºéœ€è¦æ ¹æ®è¾“å…¥è¡¨è¾¾å¼æ¥åˆ†æå’Œåˆ›å»ºåˆ—æ ‡é¢˜ã€‚åœ¨*è¡¨ 1* ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°â€”

| **P** | **é—®** | **P** | **P âˆ¨ Q** | **P â‡’ Q** |
| --- | --- | --- | --- | --- |
| â€¦ | â€¦ | â€¦ | â€¦ | â€¦ |

> ***è¡¨ 1***
> 
> *   *è¡¨è¾¾å¼é›†ä¸­å‡ºç°çš„æ¯ä¸ªå˜é‡ä¸€ä¸ªåˆ—æ ‡é¢˜ï¼›`P`å’Œ`Q`*
> *   *æ¯ä¸ªè¡¨è¾¾å¼å¯¹åº”ä¸€åˆ—â€”`Â¬P`ã€`Â¬P âˆ¨ Q`ã€`P â‡’ Q`ã€*

ä¸ºäº†è®¡ç®—æ¯ä¸ªå˜é‡çš„åˆ—ï¼Œæˆ‘ä»¬åˆ›å»ºäº†`vars` â€”

```
vars : Expr -> Set String
vars expr =
    case expr of
        Or a b ->
            Set.union (vars a) (vars b)

        Xor a b ->
            Set.union (vars a) (vars b)

        And a b ->
            Set.union (vars a) (vars b)

        Implies a b ->
            Set.union (vars a) (vars b)

        Equiv a b ->
            Set.union (vars a) (vars b)

        Not a ->
            vars a

        Var a ->
            Set.singleton a

And (Var "P") (Var "Q") |> vars
-- [ "P", "Q" ] : Set String 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

æˆ‘ä»¬å¯ä»¥å°†æ¯ä¸ªè¡¨è¾¾å¼è½¬æ¢æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç”¨äºå‰©ä½™çš„åˆ—æ ‡é¢˜â€”

```
exprToString : Expr -> String
exprToString expr =
    case expr of
        And a b ->
            exprToString a ++ " âˆ§  " ++ exprToString b

        Or a b ->
            exprToString a ++ " âˆ¨ " ++ exprToString b

        Xor a b ->
            exprToString a ++ " âŠ• " ++ exprToString b

        Implies a b ->
            exprToString a ++ " â‡’ " ++ exprToString b

        Equiv a b ->
            exprToString a ++ " â‡” " ++ exprToString b

        Not a ->
            "Â¬" ++ exprToString a

        Var a ->
            a

Implies (Var "P") (Var "Q") |> exprToString
-- "P â‡’ Q" : String 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

ç°åœ¨æˆ‘ä»¬å¯ä»¥å¼€å§‹ä¸º`truthTable`â€”
å¡«å……ä¸€äº›å®ç°

```
truthTable : List Expr -> Html msg
truthTable exprs =
    let
        ids =
            exprs
                |> List.map vars
                |> List.foldl Set.union Set.empty
                |> Set.toList

        columns =
            ids ++ List.map exprToString exprs

        -- ...
    in
    Html.table [ Attributes.style [ ( "width", "100%" ) ] ]
        [ Html.thead [] [ tableHeader columns ]
        , -- ...
        ]

tableHeader : List String -> Html msg
tableHeader labels =
    labels
        |> List.map (tableCell [ ( "font-weight", "bold" ) ])
        |> Html.tr []

tableCell : List ( String, String ) -> String -> Html msg
tableCell style text =
    Html.td [ Attributes.style style ] [ Html.text text ] 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

#### [](#table-rows)è¡¨æ ¼è¡Œ

ç»§ç»­å‰è¿›ï¼Œæˆ‘ä»¬åˆ°è¾¾`<tbody>`ã€‚åœ¨*è¡¨ 1* ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°éœ€è¦ä¸º`P`å’Œ`Q`çš„æ¯ä¸ªå¯èƒ½åœºæ™¯ç”Ÿæˆ`True` / `False`å€¼

| **P** | **é—®** | **P** | **P âˆ¨ Q** | **P â‡’ Q** |
| --- | --- | --- | --- | --- |
| T | T | â€¦ | â€¦ | â€¦ |
| T | F | â€¦ | â€¦ | â€¦ |
| F | T | â€¦ | â€¦ | â€¦ |
| F | F | â€¦ | â€¦ | â€¦ |

> ***è¡¨ 1***
> *æ‰€æœ‰å¯èƒ½çš„`True` / `False`æ’åˆ—ä¸º 2 ä¸ªå˜é‡ï¼Œ`P`å’Œ`Q`*

å½“è¿™ç»„è¡¨è¾¾å¼æ‰©å±•åˆ°åŒ…æ‹¬ç¬¬ä¸‰ä¸ªå˜é‡`R`æ—¶ï¼Œåœ¨*è¡¨ 2* ä¸­ï¼Œå¢åŠ äº†å¦ä¸€åˆ—ï¼Œæ›´å¤šçš„`True` / `False`å€¼ä¹Ÿè¿›è¡Œäº†æ’åˆ—

| **P** | **é—®** | **R** | **(P â‡’ Q) â‡’ R** | **P â‡’ (Q â‡’ R)** | **(P â‡’ R) âˆ¨ (Q â‡’ R)** |
| --- | --- | --- | --- | --- | --- |
| T | T | T | â€¦ | â€¦ | â€¦ |
| T | T | F | â€¦ | â€¦ | â€¦ |
| T | F | T | â€¦ | â€¦ | â€¦ |
| T | F | F | â€¦ | â€¦ | â€¦ |
| F | T | T | â€¦ | â€¦ | â€¦ |
| F | T | F | â€¦ | â€¦ | â€¦ |
| F | F | T | â€¦ | â€¦ | â€¦ |
| F | F | F | â€¦ | â€¦ | â€¦ |

> ***è¡¨ 2***
> *æ‰€æœ‰å¯èƒ½çš„`True` / `False`æ’åˆ—ä¸º 3 ä¸ªå˜é‡ï¼Œ`P`ã€`Q`å’Œ`R`ã€*

æˆ‘ä»¬å®ç°`permute`æ¥ç”Ÿæˆæ¯è¡Œéœ€è¦å¡«å……çš„å€¼â€”

```
permute : Int -> List a -> List (List a)
permute n list =
    let
        loop acc n xs =
            if n == 0 then
                [ acc ]
            else
                list
                    |> List.concatMap (\x -> loop (acc ++ [ x ]) (n - 1) xs)
    in
    loop [] n list 

permute 2 [ "A", "B" ]
-- [ [ "A", "A" ]
-- , [ "A", "B" ]
-- , [ "B", "A" ]
-- , [ "B", "B" ]
-- ] : List (List String) 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

ç»™å®šä¸€ä¸ªå˜é‡åˆ—è¡¨å’Œä¸€ä¸ªå€¼åˆ—è¡¨ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—ä¸€ä¸ªè¡¨è¾¾å¼â€”

```
makeEnv : List String -> List Bool -> Env
makeEnv ids values =
    values
        |> List.map2 (,) ids
        |> Dict.fromList

eval : Env -> Expr -> Result String Bool
eval env expr =
    case expr of
        And a b ->
            Result.map2 (&&) (eval env a) (eval env b)

        Or a b ->
            Result.map2 (||) (eval env a) (eval env b)

        Xor a b ->
            Result.map2 xor (eval env a) (eval env b)

        Implies a b ->
            Result.map2 implies (eval env a) (eval env b)

        Equiv a b ->
            Result.map2 equiv (eval env a) (eval env b)

        Not a ->
            Result.map not (eval env a)

        Var a ->
            Dict.get a env
                |> Result.fromMaybe ("unbound identifier: " ++ toString a)

And (Var "P") (Var "Q")
    |> eval (makeEnv [ "P", "Q" ], [ True, False ])
    -- Ok False : Result String Bool 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

ä¸ºäº†å®Œæˆ`truthTable`ï¼Œæˆ‘ä»¬é¦–å…ˆç”Ÿæˆ`True` / `False`å€¼æ’åˆ—ï¼Œç„¶åå¯¹æ¯ä¸ªè¡¨è¾¾å¼è¿›è¡Œæ±‚å€¼â€”

```
truthTable : List Expr -> Html msg
truthTable exprs =
    let
        ids =
            -- ...

        columns =
            -- ...

        count =
            List.length ids

        rows =
            permute count [ True, False ]
                |> List.map (tableRows (makeEnv ids) exprs)
    in
    Html.table [ Attributes.style [ ( "width", "100%" ) ] ]
        [ Html.thead [] [ tableHeader columns ]
        , Html.tbody [] rows
        ] 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

æœ€åæˆ‘ä»¬å†™`tableRows`æŠŠæ‰€æœ‰çš„éƒ¨åˆ†ç²˜åœ¨ä¸€èµ·â€”

```
tableRows : (List Bool -> Env) -> List Expr -> List Bool -> Html msg
tableRows makeEnv exprs values =
    let
        env =
            makeEnv values

        results =
            exprs
                |> List.map (eval env)
                |> List.foldr (Result.map2 (::)) (Ok [])
                |> Result.map ((++) values)
                |> Result.withDefault []

        viewCell truth =
            if truth then
                tableCell [ ( "color", "#19A974" ) ] "T"
            else
                tableCell [ ( "color", "#E7040F" ) ] "F"
    in
    results
        |> List.map viewCell
        |> Html.tr [] 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

* * *

### [](#practical-application)å®é™…åº”ç”¨

å¦‚æœç”¨æˆ·å·²ç™»å½•ï¼Œä»¤ç‰Œæœ‰æ•ˆï¼Œç”¨æˆ·å±äºç¼–è¾‘è€…ï¼Œå¸–å­å¯ç¼–è¾‘ï¼Œå¸–å­æœªé”å®šï¼Œåˆ™...â€“ç¼–å†™æ˜“äºé˜…è¯»çš„ç¨‹åºå¾ˆå›°éš¾ã€‚æœ‰æ—¶å€™å¤æ‚çš„é€»è¾‘å‘½é¢˜å¯ä»¥ç”¨ç®€åŒ–çš„[ç­‰ä»·è¡¨è¾¾å¼](https://en.wikipedia.org/wiki/Logical_equivalence)æ¥ä»£æ›¿ã€‚çœŸå€¼è¡¨å¸®åŠ©æˆ‘ä»¬è¯†åˆ«è¿™äº›ç­‰ä»·

| **P** | **é—®** | å°±è¿™æ ·äº§ç”Ÿäº†ä¸€ä¸ª 1231 åˆ†é’Ÿçš„è¯´æ³• | **(P âˆ¨ Q)** |
| --- | --- | --- | --- |
| T | T | F | F |
| T | F | F | F |
| F | T | F | F |
| F | F | T | T |

> ***è¡¨ 3***
> 
> ```
>  truthTable
>       [ And (Not (Var "P")) (Not (Var "Q"))
>       , Not (Or (Var "P") (Var "Q"))
>       ] 
> ```
> 
> *   *[å¾·æ‘©æ ¹å®šå¾‹](https://en.wikipedia.org/wiki/De_Morgan%27s_laws) : `Â¬(P âˆ¨ Q)`ç›¸å½“äº`(Â¬P) âˆ§ (Â¬Q)`*
> *   *å³ï¼Œâ€œ<u>é</u>å¤šäº‘<u>æˆ–</u>ä¸‹é›¨â€ç›¸å½“äºâ€œ<u>é</u>å¤šäº‘<u>é</u>ä¸‹é›¨â€*

* * *

### [](#truth-table-generator)çœŸå€¼è¡¨ç”Ÿæˆå™¨

é€šè¿‡ [ellie-app](https://ellie-app.com/Qs4HCPzYfra1) ä¸Šæä¾›çš„å®Œæ•´æºä»£ç ï¼Œè‡ªå·±å¯»æ‰¾çœŸç›¸ã€‚

ä¸ºäº†å†™è¿™ç¯‡æ–‡ç« ï¼Œæˆ‘ä½¿ç”¨äº†è¿™ä¸ªåœ¨çº¿å·¥å…·[å°† HTML è¡¨æ ¼è½¬æ¢æˆ GHF Markdown](https://jakebathman.github.io/Markdown-Table-Generator/)

#### [](#todo)å¾…åŠäº‹é¡¹

åœ¨æ—¶é—´å…è®¸çš„æƒ…å†µä¸‹ï¼Œæˆ‘å°†ç»§ç»­å¯¹æ­¤è¿›è¡Œæ”¹è¿›

*   `exprToString`åº”è¯¥åŒ…æ‹¬åœ†æ‹¬å·`()`æ¥æ¶ˆé™¤åƒ`P â‡’ Q â‡’ R`è¿™æ ·çš„è¡¨è¾¾çš„æ­§ä¹‰
*   `Expr`è”åˆç±»å‹å¤§æ¦‚å¯ä»¥ç®€åŒ–ä¸º`type Expr = Unary ... | Binary ...`
*   ä¸€ä¸ªè§£æå™¨
*   ä½ çš„æƒ³æ³•ğŸ”¥