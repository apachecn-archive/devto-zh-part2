# Rust + ReasonML -初学者的爱情故事

> 原文:[https://dev.to/deciduously/rust-原因 ml-a-初学者-爱情故事-45a2](https://dev.to/deciduously/rust--reasonml---a-beginners-love-story-45a2)

# [](#babys-first-fullstack-app)宝宝的第一款全栈 App

我做到了-我创造了一个东西。我发现了我遇到的一个问题，设计了一个解决方案，并编写了一堆代码，这些代码可以很好地完成我想要的事情，让其他人也可以使用。我现在大概有六个完整的用户。

我知道这几乎是这项技术的游戏名称，你们每天都这样做，但这对我来说有点大不了。能够完成练习、教程和小玩具终端应用程序与像这样的成熟应用程序之间的差距是很大的，即使最终产品在范围上非常简单。

一般来说，聪明人的建议，尤其是在学习的时候，是倾向于那些久经考验并被广泛使用的工具。

无论如何，我想对尝试这些奇怪的东西提出反驳——我相信选择 Rust 作为后端，选择 ReasonML 作为前端，可以让我在问题上花费比工具更多的时间，温和地引导我走向更好的实践，增加我对一些概念的理解，同时让我很好地过渡到更主流的工具，而没有太多的准备时间。

我不会说太多细节，只是想提一下这个项目的一些部分，我认为因为这些选择，这些部分变得更容易了。

该项目托管在 GitHub 上——它被称为 [mifkad](https://github.com/deciduously/mifkad) 。它旨在取代一个手写的过程来跟踪一个小学校的出勤率，并根据出勤率生成一天中“额外时间”的花名册。

## [](#the-backend)后端

我对 actix-web 再高兴不过了。当我偶然发现 Rust 的时候，我已经使用它有一段时间了，并且在仅仅阅读网站的几分钟内，就有几个端点像预期的那样工作。易于配置，非常灵活，运行速度惊人，因为它是 Rust，所以我得到了一个没有运行时依赖性的小型可移植二进制文件——我被说服了。然而，虽然 Rust 和 actix 很棒，但构建这个后端真正打动我的是 *rust 编译器*如何教会我如何编写异步代码。

构建它最棘手的部分是确保它能在会话之间工作——一整天都需要来自不同工作站的多个用户。我决定在每次点击时将整个状态保存到一个共享的网络存储中，但是需要确保写操作不会冲突。

不久前，这种问题还会在我头上飞过。线程安全代码是为聪明的、有经验的人编写的，他们知道自己在做什么！

事实证明，Rust 编译器基本上可以帮你做到。我使用过引用计数类型，所以我隐约知道一个叫做 [`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html) 的东西存在。我知道我需要某种互斥体，所以我打开标准库文档，找到了 [`RwLock`](https://doc.rust-lang.org/std/sync/struct.RwLock.html) ，听起来差不多。

我然后...猜测:

```
pub struct AppState {
    pub school: Arc<RwLock<School>>,
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我把我的常规老学校类型换成了上面的，只是想看看我是否在正确的轨道上。

我不仅是在正确的轨道上——这几乎是*T2。我重写了我的处理程序，以便在读取和写入应用程序状态之前获取正确的锁，并按照 actix 文档将我的所有处理程序切换到返回未来(这是框架的内置功能——这大约需要 10 分钟)，然后修复所有的`rustc`错误。*

它只是该死的工作了。那是*坚果*。现在我不再害怕在 Rust 代码中使用并发原语。

## [](#the-frontend)前端

2018 年的 React.js 是个畜生。我的意思是可爱的——生态系统是巨大而强大的，你可以从中挑选满足各种需求的东西。

开始一个全新的 React 项目，尽管之前从未尝试过？退一步说，令人畏惧。不管你做了什么选择，总有一种挥之不去的感觉，下一次搜索会有更好的东西，尽管在大多数情况下，无论你用的是什么都没问题。有太多的选择可能会让你停滞不前，或者用稍微不同的库一遍又一遍地构建一个项目的相同起点，并且永远不会完成。

选择 ReasonML 允许我完全跳过整个过程，而不放弃控制。虽然我知道并欣赏像`create-react-app`这样的工具，但亲自尝试给我留下了不好的印象。它非常神奇，在你运行`eject`之前，它对用户隐藏了它正在做的事情来提供如此多的功能。然而，在弹出之后，你只剩下一大堆*要筛选——太多东西要马上学习。我更喜欢自己构建这种东西，确保我真正理解每个组件，这样工具就不会为我工作。*

你通过`bsb -init`获得的基本应用非常简单。我完全理解了我在新文件夹中看到的一切，并能够立即开始迭代。不知道原因或地点并没有成为一个问题——原因反应与常规的旧反应非常接近！经过一天的缓慢进展，我不再遇到语法错误，并且知道每一行新代码应该放在哪里。

更不用说我不需要附加一个状态管理库——它带有内置的`reducerComponent`,所以你可以有一个类似 Redux 的动作调度器，而不是 setState，但没有与应用程序范围的 Redux 存储相关的样板文件。你只需为你的动作设置一个 sum 类型，然后像任何其他 React 生命周期方法一样，从你的`reducerComponent`上可用的`reducer`方法中使用它们，这一切都很容易使用。

然而，最大的好处是编译器。它跑得很快，你永远也跑不过它。TypeScript 和 Flow 甚至都不接近。它是围绕一个行业巨头的类型推理构建的，所以你会得到非常有用的错误消息，指出你到底做错了什么。这是一种学习新工具的非凡方式，附带训练轮——我在构建这个工具时学到的几乎所有东西都可以带到“真正的”React 应用程序中，但这就像有一个专门的导师在你身后平静地指出你做的每一件蠢事。最终，你会停止做那些事情！

我真的觉得 ReasonReact 让出了我的路，让我来写应用程序。对我来说，设置类型来镜像后端使用的类型是有意义的。将 json 响应反序列化为 ReasonML 数据结构很简单。我喜欢默认情况下我所有的道具都是全类型的。生成的输出只是出现在代码旁边的普通的旧 JavaScript，所以弄清楚如何捆绑最终的应用程序并不复杂。任何地方都没有摩擦，我从来没有遇到过在 React 网站上没有明确回答的问题。

## [](#your-turn)轮到你了！

当然，我并没有试图在这里做什么花哨的东西——但是我确实温习了互操作的故事，而且这也很容易。在这个项目的任何时候，我都没有感觉到我在和我的工具战斗——它总是相反的。我没有使用我“应该”使用的主流工具的经验。我认为我比用普通的 JS 做得更快更好，并且学到了更多。

有其他人在使用工具时有过类似的经历吗？有没有一些提升你生活质量的新鲜事物的推荐？我很想听听！