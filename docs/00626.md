# 我生命中最不为人知的两个错误

> 原文:[https://dev.to/reg__/two-most-obscure-bugs-in-my-life-3ian](https://dev.to/reg__/two-most-obscure-bugs-in-my-life-3ian)

修复 bug 是软件开发的一个重要部分，也是一个非常情绪化的部分——从不知道发生了什么时的沮丧到找到原因并知道如何修复时的欣喜。有许多不同种类的错误以及它们被引入代码的原因。(对每个 bug 是如何发生的进行深入调查可能是一个有趣的想法——有一天我会就此写一篇独立的博文...)但最令人沮丧的可能是那些只在某些特定条件下发生的错误，比如只在许多受支持的平台之一上发生，或者只在“发布”而不是“调试”配置中发生。下面你会发现我在生活中发现并修复的两个最模糊的错误的描述，供你学习和娱乐:)两者都是大型的、多平台的 C++代码库。

1:有一个错误报告导致不正确的程序行为，只发生在构建和使用程序的许多平台之一上。可能是麦克，但我记不清了。它被归类为一种回归——它以前可以工作，但在一些特定的代码更改之后，就停止工作了，被自动化测试所捕获。奇怪的是，提交到代码库的罪犯只引入了新的注释，而没有引入其他内容。代码注释中的变化如何引入新的 bug？！

原来这个修改的作者想在他的评论中画一个漂亮的“ASCII 艺术”，所以他放了这样的东西:

```
// HERE STARTS AN IMPORTANT SECTION
//========================================================\\
Function1();
Function2();
(...) 
```

你注意到什么可疑的事情了吗？...

在 C/C++中，行尾的反斜杠“\”表示逻辑行延续到下一行。该特性主要用于编写复杂的预处理宏。但是从两个斜线“//”开始的代码会开始一个注释，一直延续到行尾。现在的问题是:单行注释也跨到下一行吗？换句话说:第一个函数调用是否被注释掉了？

我不知道，也不太关心“语言律师”会从 C++规范中读到什么，并定义为适当的行为。真实的情况是，一些平台上使用的编译器认为单行注释跨越到下一行，因此注释掉了对`Function1()`的调用，而其他平台则不这样认为。这导致该错误只出现在某些平台上。

很明显，解决方案是修改注释，使其在行尾不包含反斜杠，即使牺牲了这个小艺术品的美观和对称性:)

2:我被分配了一个“堆栈溢出”错误，它只发生在 Visual Studio 项目的“调试”配置中，而不发生在“发布”配置中。一开始，我很确定会很容易找到。毕竟“堆栈溢出”通常意味着无限递归，对吗？堆栈是分配局部函数变量以及嵌套函数调用的返回地址的一块内存。它们往往不会太大，而默认情况下堆栈是 1 MB，因此一定有不合理的调用深度会导致该错误。

结果证明不是真的。经过几次调试和阅读相关代码后，我明白这里没有无限递归。这是一个树形结构的遍历，但是它的层次深度不够大，不值得关注。我花了一段时间才意识到堆栈已经膨胀到一个函数超出其容量的程度。这是一个非常长的函数——你知道，这种函数你可以在违背任何良好实践的企业环境中看到，但没有人觉得有责任重构。随着时间的推移，它一定会随着越来越多的代码逐渐增加，直到达到数百行。这只是一个大开关，每个开关都有很多代码。

```
void Function(Option op)
{
  switch(op)
  {
  case OPTION_FIRST:
    // Lots of code, local variables, and stuff...
    break;
  case OPTION_SECOND:
    // Lots of code, local variables, and stuff...
    break;
  case OPTION_THIRD:
    // Lots of code, local variables, and stuff...
    break;
  ...
  }
} 
```

真正导致错误的是这个函数中使用的局部变量的数量和大小。每种情况都涉及许多变量，有些变量很大，如固定大小的数组或某些类的对象，由堆栈上的值定义。递归调用这个函数几次就足以耗尽堆栈容量。

为什么“栈溢出”只发生在“调试”配置中而不发生在“发布”中？显然，Visual Studio 编译器可以在 switch 指令的不同情况下延迟分配或别名局部变量，而“调试”配置禁用了所有优化，因此它在每次函数调用时都分配所有这些变量。

解决方案只是用一个开关重构这个长函数——将每个案例中的代码放在一个单独的新函数中。

你在编码实践中遇到过的最隐晦的 bug 是什么？请在下面的评论中告诉我。