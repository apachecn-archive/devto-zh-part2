# [P2]用 C#编写序列化库:性能是一个特性

> 原文:[https://dev . to/goaty 92/p2-writing-a-serialization-library-in-c-performance-is-a-feature-12p 2](https://dev.to/goaty92/p2-writing-a-serialization-library-in-c-performance-is-a-feature-12p2)

在本系列的第一篇博客文章中，我简要介绍了 Ion，以及为什么它提供了比 JSON 和 XML 等流行格式更好的序列化选择。在接下来的几篇文章中，我将讨论 [IonDotnet](https://github.com/dhhoang/IonDotnet) 正在实现的一些性能特性。

我之所以说性能’*特性*，是因为开发者往往不把它当成一个。有时有很好的理由:及时运送产品总是(也应该是)最重要的事情。毕竟人们都说优化的第一法则是[不要做](http://wiki.c2.com/?FirstRuleOfOptimization)。然而，当谈到编写一个库，尤其是处理数据的库时，我认为性能应该是一个特性。如果你在用我的库，而你的软件运行缓慢，我希望是你的错，而不是我的🤫。

一般来说，优化是从架构- >算法- >缓存- >微优化。在这种情况下，算法非常简单:大多数串行器运行一个状态机，根据输入写数据和更新状态。话虽如此，即使你不必想出一些新颖的绝妙算法，注意代码中的一些细节，尽管与算法无关，也会让你受益匪浅。

我们将以一个简单的提示结束这篇博客:

#### 如果你有一个 C#结构，总是覆盖`Equals()`、`==`、`!=`和`GetHashCode()`。

C#的一个重要特性当然是定义`struct`值类型的能力。然而，这有一个警告:默认情况下比较 2 `struct`将迫使运行时使用反射并比较结构中的所有嵌套字段。

考虑到反射有多慢，如果你有一个你想比较很多的结构，重写`Equals()`、`==`、`!=`和`GetHashCode()`会给你带来巨大的性能优势。

在 IonDotnet 代码库中，有一个叫做`SymbolToken`的结构，这个结构与其他结构进行了很多比较。我足够小心地遵循了指导方针，覆盖了所有必要的方法(并实现了`IEquatable`)。我很想知道如果我错过了那场演出会是什么样。我将把基准测试结果放在这里:

```
// benchmark, serializing 1000 records
          Method |     Mean |     Error |    StdDev |    Gen 0 |   Gen 1 | Allocated |
--------------------- |---------:|----------:|----------:|---------:|--------:|----------:|
 No-override     | 8.385 ms | 0.1034 ms | 0.0916 ms | 828.1250 | 93.7500 |   3.67 MB |
 Overrided       | 2.319 ms | 0.0216 ms | 0.0202 ms | 31.2500  | 15.6250 | 383.37 KB | 
```

Enter fullscreen mode Exit fullscreen mode

如果你感兴趣的话，还有一篇很棒的博客文章详细讨论了这个问题。

就这样，下期帖子见。