# 科特林数据 vs 公开课

> 原文:[https://dev.to/tsalikispk/kotlin-data-vs-open-class-2ckn](https://dev.to/tsalikispk/kotlin-data-vs-open-class-2ckn)

## 科特林*数据*类

Kotlin 语言提供的众多便利特性之一是*数据*关键字。当我们用*数据*关键字声明一个类时，编译器实现了 *equals(Object o)* 、 *hashCode()* 和 *toString()* 方法，这样就免去了我们手动操作的麻烦。[官方文档](https://kotlinlang.org/docs/reference/data-classes.html)提供了全面的例子，现在它已经成为一个广为人知的语言特性，所以一个例子可以留在这篇文章的范围之外。

## 科特林中的所有职业都默认为*最终*

Kotlin 在幕后做的另一件事是编译你声明为 *final* 的每个类，除非你给它添加了 *open* 关键字。我们可以看到语言是如何受到*有效 Java 第二版*(第三版也出来了！).更具体地说，项目 16 和 17 陈述如下:

> 第 16 条:重组合轻继承
> 
> 第 17 项:设计和文件的继承或禁止它

## 关键字定义之间的冲突

这是这种语言的一个非常好的特性，正如书中所描述的，它试图保护我们免受不恰当使用继承的各种危险。不幸的是，当你试图声明一个既开放又数据的类时，事情开始变得混乱。编译器会抱怨一个数据类不能同时打开，给我们一个错误。

让我们停下来想一想，为什么这种语言的设计师决定设置这样一个障碍。首先，我们将努力记住史蒂夫·弗里曼和纳特·普莱斯所著的《测试驱动的面向对象系统的发展》一书中的一些至理名言。第 2 章介绍了*值*和*对象*之间的区别。对象通过发送消息相互通信，并根据它们的状态有一些特定的行为。如果他们的状态改变，他们的行为也会改变。另一方面，*值*——换句话说——只是用于计算的数据袋。

既然*对象*和*值*之间的定义和区别已经很清楚了，我们可以看到 Kotlin 在使用*数据*和*打开*关键字时强加这样的规则是有意义的。一个*数据*类是一个*值*，只保存——最好是不可变的——没有行为的数据。既然扩展一个类来改变它的行为是有意义的，而*数据*类没有行为，为什么我们应该能够扩展它呢？

尽管这一设计决策的理由非常充分，但是强加的限制使得从 Java 到 Koltin 的过渡非常困难。我们的代码库中可能有一个类是成为数据类的完美候选，但是如果由于某种原因这个类被另一个类扩展，您不能立即进行转换，因为您必须首先确定这个类被扩展的事实。当我们有一个很深的嵌套层次结构时，这个问题会变得更糟。

## 一些情景和解决问题的可能方法

处理这个问题的一个方法是检查这个类是否有字段。如果它没有，只是作为一个标记，我们可以删除这个类，跟踪编译器错误，用父类替换。事实上，我们可以使用这种技术，只要子类没有在任何检查的*实例中使用。在这种情况下，问题会变得更糟，尤其是当父类也涉及到*检查的*实例时。这里我们在系统中有一个行为改变，我们不能仅仅通过用父类替换检查来修复它，这是一个很难改变的。过去的罪恶终于惩罚了我们。*

现在让我们考虑这样一种情况，子类扩展了父类，只是为了继承父类的部分或全部字段，并添加了自己的字段。然后我们可以根据具体情况尝试使用某种组合。

## 最后的想法

也许上面描述的最糟糕的问题是检查的*实例。如果我们能够找到一种方法来解决这些检查问题，那么用父代替换子代或者将父代作为依赖项传递就变得不那么困难了。*

不幸的是，这篇文章并没有提供一个最终的解决方案，而是试图对 Kotlin 的实现决策进行推理，并探索如何解决 Java 到 Kotlin 迁移过程中出现的问题。