# 多范式是最好的范式

> 原文：<https://dev.to/dwd/multi-paradigm-is-the-best-paradigm-3pm0>

我最近一直在学习 React 这是我二十年来第一次学习 Javascript 编程。很有趣。

React 的 JSX 为您提供了声明性代码来表达您的应用程序的结构。Redux 为您提供了管理状态的命令式、类似函数的技术。Saga 把必要的协程扔进了这个混合体。有了这个令人愉快的框架，您就可以继续用面向对象语言编写命令性的过程代码来完成工作，并根据自己的感觉在过程代码和面向对象代码之间来回切换。

经过几年对代码的研究，我认识到了很多东西，很高兴看到它与我在标题中的论点相一致——虔诚地坚持单一范例是过度限制性的，可能会阻碍完成手头任务的正确方法。

## 警告:范式转换锁定开启

范式——不管你的环境是声明式的还是命令式的，函数式的还是面向对象的——对你如何表达一个问题施加了限制，因此你必须如何考虑它。这些限制是为了降低你的认知负荷，并且(通常)在一个领域工作时忘记另一个领域的细节。

声明性代码说明事情应该如何，并避免讨论它们将如何实现。纯函数式代码是声明性代码的一种形式，但是可能有更好的例子——例如 SQL 和 XSLT。虽然它在这些特定领域语言中非常流行，但它从未真正作为一种通用编程技术脱颖而出——尽管 Haskell 和其他人做出了勇敢的努力。

另一方面，命令式代码只讨论一系列操作——一系列指令。事实证明，这比声明性模型更适合复杂任务的人类心智模型。考虑一个蛋糕的食谱——描述蛋糕上覆盖着糖衣，中间有果酱是一件让我感到饥饿的美妙事情，但没有告诉我应该如何制作它。大型应用程序也是如此。

命令式代码然后相当整齐地分裂成过程式代码——基本上有函数，你可以调用它们——和面向对象的代码——这可能是最容易被误解的范例。

面向对象基于一个相当简单的概念:状态和行为作为一个对象绑定在一起，这个对象专门用于它的任务，你只能通过传递一个定义了语义的消息来间接调用行为。与大多数面向对象语言相比，所有这些听起来都很神秘，所以让我解释一下，消息传递通常是作为方法调用来实现的。请注意，我没有说“类”，或者“继承”。

几乎每一种现代命令式语言都是面向对象的，这包括 ES3、Lua 和无数其他语言，人们花了很多个晚上坚持认为它们不是面向对象的。说真的，如果这一节有什么要说的话，那就是 OO 不仅仅是 Java 做的事情。

在所有情况下，编程范例都有助于人脑推理和处理复杂的应用程序。大多数情况下，这是通过使你能够根据一小组通用规则对行为做出假设，将复杂性本地化来实现的。

## 反动的范式

在顶层，React 是一种声明性语言，通过 JSX。每个组件都被简单地声明，它是如何形成的，它的属性和状态在很大程度上被隐藏起来了。应用程序作为一个整体直接从虚空中生成——几乎没有初始化，没有引导，也没有样板文件。作为一种描述应用程序结构和避免应用程序不同部分共享状态的陷阱的方法，它非常棒。

但是，在定义组件时，React 会使用命令式代码。但是——我认为这真的很聪明——它避免了直接陷入全面的面向对象。相反，它倾向于过程化，允许简单的组件被定义为功能。

现在，为了避免我的注释流充满“哦，但是真的”，是的，这些确实定义了对象——但是语法是函数定义的语法。

尽管如此，React 确实有一个非常完整的 ES6 风格的类系统，可用于更复杂的组件，甚至是继承树，它也非常有用。

## 减少、再利用、回收

在管理状态时，大多数 React 开发人员似乎都求助于 Redux 及其朋友 Ducks。

状态的全局规则是不应该有全局状态——正如我们所知，这实际上是一个用代码调用的副作用来管理期望的问题 Redux 确实非常巧妙地处理了这一点。

它提供了一个 mahoosive 全局状态对象，但将其视为只读的——事实上，就像 React 组件的属性一样，它经常绑定到状态的一部分。这些部分使用单独的 Ducks 进行管理，Redux 将这些部分组合成一个 mashoosive“Reducer”。(旁白:“Mashoosive”是一个错别字，但我真的很喜欢它，所以它留下来了)。

需要改变这种状态的应用程序的其他部分通过向 Redux 发送类似 JSON 的对象来间接地改变这种状态，Redux 将这些对象分派给封装了状态部分并实现其行为的各种鸭。如果这听起来很熟悉，那是因为我实际上只是用这些术语来描述面向对象编程。

但是等等！我介绍的时候不是说是“类功能”吗？是的，我说了，现在也是。Redux 也借用了大量的函数式编程来管理状态。通过这个镜头来看，鸭子实现的方法可以看作是 reducer(如在 Map/Reduce 中)。这是迄今为止看待 Redux 更正常的方式，这就是为什么状态管理函数确实被称为 Reducers。

因此，你不是操纵巨大的全局状态对象，而是将它视为函数调用的结果，不是直接改变状态，而是用状态的副本调用 reducers 并返回新的状态。数据永远不会改变。

但是，如果你更喜欢把还原器叫做“方法”，把鸭子当成对象，我不会告诉任何人。

## 传奇，传奇，燃烧的光明

然而，当管理真正复杂的事件序列时，Redux 是不够的。虽然您可以绞尽脑汁将一系列事件转换成一组名义上独立的处理程序，但这真的很难。

Saga 为此提供了一些有用的工具，它将事物包装成协同例程。协同例程是线程的小兄弟，是围绕生成器构建的。生成器是生成一个函数的一种方式，该函数返回在迭代时创建的序列。例如，你可以通过编写一个简单的斐波那契生成器来打印一个无限的斐波那契数列。它将在每次迭代运行时生成下一个值，当它“产生”一个值时，本质上暂停函数的执行。

协同例程是通过让步建立的，以便将控制权交还给主调度程序，让您在协同例程之间进行多任务协作。在 Saga 的情况下，产生的值是承诺，并且承诺解析导致执行被恢复；这允许您等待来自外部源的事件，分派 Redux 事件，等等——但是控制流作为单个函数变得可见(并且可管理)。

当然，事件驱动编程已经是一个必不可少的过程，但是通过引入协同例程，它使之成为一个简单的线性过程，因此更适合心智模型。

## 当你所拥有的不是一把锤子

人们很容易认为，无论你手头有什么工具，都是最适合这项工作的。经过片刻思考后，我们中没有人认为这是真的，但是我和其他人一样对使用一种工具或技术感到内疚，因为我知道这是一种可以解决问题的工具，即使我知道另一种我不太了解的工具会更适合。

React 和它的朋友们的聪明之处不在于他们选择了一个真正的范例。聪明的一点是，他们将几种不同的范例无缝地融合在一起，并使它们有效地工作。