# 我最近发现了一个包裹，太神奇了

> 原文:[https://dev . to/dubyabrian/I-最近发现的包裹及其神奇之处-37h3](https://dev.to/dubyabrian/i-recently-discovered-parcel-and-its-amazing-37h3)

在玩 WebAssembly 和 rust 的时候，我偶然发现了一个我以前从未听说过的资产捆绑器的插件。不可否认，我最初的想法是“该死，为什么他们不能直接用 webpack？”毕竟，webpack 在过去满足了我的所有需求，似乎已经成为事实上的标准。“是时候卷起袖子学习如何配置这个东西了……”我以为。

关于[包](https://github.com/parcel-bundler/parcel)给我的第一个印象是，有*有*没有配置文件。理论上，我想，这很好，但不可避免的是，我需要对*之类的东西进行细粒度的控制。*

(旁白:“他还没有遇到过这样的场景。”)

事实上，到目前为止，我只在两个个人项目中使用过 package，但是我根本不需要配置任何东西。一切正常，我用它做了一些相对新奇的事情:

*   将 rust 编译到 WebAssembly 并捆绑最终的工件
*   将 markdown 文件捆绑和公开为 React 组件

然后是一些不那么奇特的东西，它们都是开箱即用的:Javascript、TypeScript、CSS、HTML 等等。

### 超过刚才的零配置

零配置是一个巨大的卖点，但这不是 package 的唯一卖点。像 webpack 这样的捆绑器只能转换 javascript 文件，而 Parcel 可以转换任何文件(更正:webpack 4 现在可以转换其他类型的文件)。任何不受开箱即用支持的文件类型都可以通过插件来支持。这里的实际含义是，您可以使用任何类型的文件作为入口点，而不仅仅是 javascript。这允许以更自然的方式捆绑资产。例如，我可以指定一个 HTML 文件作为我的入口点，它将从那里递归地定位和捆绑所有资产。

Parcel 通过在比它的对手更高的层次上操作来适应这一点——它实际上*解析*支持的文件类型，并转换生成的抽象语法树。当它遇到一个 javascript 文件时，它转换`import`和`require`声明。当它遇到 HTML 时，它会转换`script`和`link`标签。当它遇到 CSS 文件时，它转换`import`和`url`声明。

## 哦，真他妈的快

根据 Parcel 的 github 页面上的自述，在不缓存资产时，它的速度是 webpack 的两倍，在缓存资产时，它的速度快了近一个数量级。默认情况下，它缓存资产，我还没有遇到过需要关闭缓存的情况。有趣的是，这些数字得到了证实。

所以，下次你需要一个资产捆绑者，你应该认真考虑包裹。