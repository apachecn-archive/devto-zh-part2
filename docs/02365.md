# ä½¿ç”¨ Actix-Web ä½¿ç”¨ rust éªŒè¯ Web å¾®æœåŠ¡-å®Œæ•´æ•™ç¨‹ç¬¬ 1 éƒ¨åˆ†

> åŸæ–‡:[https://dev . to/mygnu/auth-web-microservice-with-rust-using-actix-web-complete-tutorial-part-1-2id 8](https://dev.to/mygnu/auth-web-microservice-with-rust-using-actix-web---complete-tutorial-part-1-2id8)

è¿™ä¸ªå¸–å­ç°åœ¨å·²ç»è¿‡æ—¶äº†è¯·é˜…è¯»æ›´æ–°ç‰ˆæœ¬ [Auth Web Microservice with rust ä½¿ç”¨ Actix-Web 1.0 -å®Œæ•´æ•™ç¨‹](https://gill.net.in/posts/auth-microservice-rust-actix-web1.0-diesel-complete-tutorial/)

### ä»€ä¹ˆï¼Ÿ

æˆ‘ä»¬å°†åœ¨`rust`ä¸­åˆ›å»ºä¸€ä¸ªç½‘ç»œæœåŠ¡å™¨ï¼Œåªå¤„ç†ç”¨æˆ·æ³¨å†Œå’Œè®¤è¯ã€‚åœ¨æˆ‘ä»¬è¿›è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä¼šè§£é‡Šæ¯ä¸ªæ–‡ä»¶ä¸­çš„æ­¥éª¤ã€‚å®Œæ•´çš„é¡¹ç›®ä»£ç åœ¨è¿™é‡Œ[å›è´­](https://gitlab.com/mygnu/rust-auth-server/tree/part_one)ã€‚è¯·ä¸è¦å…¨ä¿¡ï¼Œå› ä¸ºæˆ‘è¿˜æ˜¯ä¸€ä¸ªç”Ÿé”ˆçš„æ–°æ‰‹ğŸ˜‰ã€‚

##### äº‹ä»¶çš„æµç¨‹ä¼šæ˜¯è¿™æ ·çš„:

*   æ³¨å†Œç”µå­é‚®ä»¶åœ°å€â¡æ”¶åˆ°ä¸€ä¸ªğŸ“¨ç”¨é“¾æ¥æ¥éªŒè¯
*   æŒ‰ç…§é“¾æ¥â¡æ³¨å†Œç›¸åŒçš„ç”µå­é‚®ä»¶å’Œå¯†ç 
*   ç”¨ç”µå­é‚®ä»¶å’Œå¯†ç ç™»å½•â¡å¾—åˆ°éªŒè¯ï¼Œå¹¶æ”¶åˆ°æ™ºå¨æ±¤é€Šä»¤ç‰Œ

##### æˆ‘ä»¬è¦ç”¨çš„æ¿æ¡ç®±

*   [actix](https://crates.io/crates/actix) // Actix æ˜¯ä¸€ä¸ª Rust actors æ¡†æ¶ã€‚
*   [actix-web](https://crates.io/crates/actix-web) // Actix web æ˜¯ä¸€ä¸ªç®€å•ã€å®ç”¨ã€é€Ÿåº¦æå¿«çš„ fast web æ¡†æ¶ã€‚
*   [brcypt](https://crates.io/crates/bcrypt) //ä½¿ç”¨ bcrypt è½»æ¾æ•£åˆ—å’ŒéªŒè¯å¯†ç ã€‚
*   [chrono](https://crates.io/crates/chrono) //é”ˆæ—¥æœŸæ—¶é—´åº“ã€‚
*   ç”¨äº PostgreSQLã€SQLite å’Œ MySQL çš„å®‰å…¨ã€å¯æ‰©å±•çš„ ORM å’ŒæŸ¥è¯¢ç”Ÿæˆå™¨ã€‚
*   [dotenv](https://crates.io/crates/dotenv)//Rust çš„ä¸€ä¸ª dotenv å®ç°ã€‚
*   [env_logger](https://crates.io/crates/env_logger) //æ—¥å¿—çš„æ—¥å¿—å®ç°ï¼Œé€šè¿‡ç¯å¢ƒå˜é‡é…ç½®ã€‚
*   [å¤±è´¥](https://crates.io/crates/failure) //å®éªŒæ€§é”™è¯¯å¤„ç†æŠ½è±¡ã€‚
*   [jsonwebtoken](https://crates.io/crates/jsonwebtoken) //ä»¥å¼ºç±»å‹æ–¹å¼åˆ›å»ºå¹¶è§£æ JWTã€‚
*   [futures](https://crates.io/crates/futures)//futures å’Œ streams çš„å®ç°ï¼Œå…·æœ‰é›¶åˆ†é…ã€å¯ç»„åˆæ€§å’Œç±»ä¼¼è¿­ä»£å™¨çš„æ¥å£ã€‚
*   [r2d2](https://crates.io/crates/r2d2) //é€šç”¨è¿æ¥æ± ã€‚
*   serde //ä¸€ä¸ªé€šç”¨çš„åºåˆ—åŒ–/ååºåˆ—åŒ–æ¡†æ¶ã€‚
*   [serde_json](https://crates.io/crates/serde_json) //ä¸€ç§ json åºåˆ—åŒ–æ–‡ä»¶æ ¼å¼ã€‚
*   [serde_derive](https://crates.io/crates/serde_derive) //å® 1.1 å®ç°#[derive(Serializeï¼ŒDeserialize)]ã€‚
*   [sparkpost](https://crates.io/crates/sparkpost) //ä¸º sparkpost ç”µå­é‚®ä»¶ api v1 ä¿¡ä»»ç»‘å®šã€‚
*   [uuid](https://crates.io/crates/uuid) //ç”Ÿæˆå¹¶è§£æ uuid çš„åº“ã€‚

æˆ‘å·²ç»ä»ä»–ä»¬çš„å®˜æ–¹æè¿°ä¸­æä¾›äº†å…³äºæ­£åœ¨ä½¿ç”¨çš„æ¿æ¡ç®±çš„ç®€è¦ä¿¡æ¯ã€‚å¦‚æœæ‚¨æƒ³äº†è§£è¿™äº›æ¿æ¡ç®±çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·ç‚¹å‡»åç§°å‰å¾€`crates.io`ã€‚**ä¸è¦è„¸æ’:** `sparkpost`æ˜¯æˆ‘çš„æ¿æ¡ç®±å–œæ¬¢/ä¸å–œæ¬¢è¯·ç•™ä¸‹åé¦ˆã€‚

##### å…ˆå†³æ¡ä»¶

è¿™é‡Œæˆ‘å‡è®¾ä½ æœ‰ä¸€äº›ç¼–ç¨‹çŸ¥è¯†ï¼Œæœ€å¥½ä¹Ÿæœ‰ä¸€äº› rustã€‚éœ€è¦ä¸€ä¸ª`rust`çš„å·¥ä½œè®¾ç½®ã€‚æŸ¥çœ‹ [https://rustup.rs](https://rustup.rs) è·å– esasy rust è®¾ç½®ã€‚äº†è§£æ›´å¤šå…³äºé“é”ˆç»“å¸[T5 æœ¬ä¹¦](https://doc.rust-lang.org/stable/book/2018-edition/index.html)ã€‚

æˆ‘ä»¬å°†ä½¿ç”¨ diesel æ¥åˆ›å»ºæ¨¡å‹ï¼Œå¹¶å¤„ç†æ•°æ®åº“ã€æŸ¥è¯¢å’Œè¿ç§»ã€‚è¯·å‰å¾€ http://diesel.rs/guides/getting-started/çš„T3 å¼€å§‹è®¾ç½®`diesel_cli`ã€‚åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨`postgresql`,æ‰€ä»¥è¯·æŒ‰ç…§è¯´æ˜æ¥è®¾ç½® postgresã€‚æ‚¨éœ€è¦æœ‰ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„ postgres æœåŠ¡å™¨ï¼Œå¹¶ä¸”å¯ä»¥åˆ›å»ºä¸€ä¸ªæ•°æ®åº“æ¥å®Œæˆæœ¬æ•™ç¨‹ã€‚å¦ä¸€ä¸ªä¸é”™çš„å·¥å…·æ˜¯ [Cargo Watch](https://github.com/passcod/cargo-watch) ï¼Œå®ƒå¯ä»¥è®©ä½ è§‚å¯Ÿæ–‡ä»¶ç³»ç»Ÿï¼Œå¹¶åœ¨ä½ åšä»»ä½•æ”¹å˜æ—¶é‡æ–°ç¼–è¯‘å’Œè¿è¡Œåº”ç”¨ç¨‹åºã€‚

å¦‚æœæ‚¨çš„ç³»ç»Ÿä¸Šæ²¡æœ‰ç”¨äºæœ¬åœ°æµ‹è¯• api çš„è½¯ä»¶ï¼Œè¯·å®‰è£…`Curl`ã€‚

##### æˆ‘ä»¬å¼€å§‹å§

åœ¨æ£€æŸ¥äº†ä½ çš„ rust å’Œ cargo ç‰ˆæœ¬å¹¶ç”¨
åˆ›å»ºäº†ä¸€ä¸ªæ–°é¡¹ç›®ä¹‹å

```
# at the time of writing this tutorial my setup is 
rustc --version && cargo --version
# rustc 1.29.1 (b801ae664 2018-09-20)
# cargo 1.29.0 (524a578d7 2018-08-05)

cargo new simple-auth-server
# Created binary (application) `simple-auth-server` project

cd simple-auth-server # and then 

# watch for changes re-compile and run
cargo watch -x run 
```

åœ¨è´§ç‰©ä¾èµ–é¡¹ä¸­å¡«å…¥ä»¥ä¸‹å†…å®¹ï¼Œæˆ‘å°†åœ¨é¡¹ç›®ä¸­ä½¿ç”¨æ—¶é€ä¸€æŸ¥çœ‹ã€‚æˆ‘ä½¿ç”¨çš„æ˜¯æ¿æ¡ç®±çš„æ¸…æ™°ç‰ˆæœ¬ï¼Œæ­£å¦‚ä½ æ‰€çŸ¥ï¼Œä¸œè¥¿ä¼šå˜è€å’Œæ”¹å˜ã€‚(å¦‚æœæ‚¨åœ¨æœ¬æ•™ç¨‹åˆ›å»ºå¾ˆé•¿æ—¶é—´åè¿˜åœ¨é˜…è¯»å®ƒ)ã€‚åœ¨æœ¬æ•™ç¨‹çš„ç¬¬ 1 éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬ä¸ä¼šç”¨åˆ°æ‰€æœ‰çš„å·¥å…·ï¼Œä½†æ˜¯åœ¨æœ€ç»ˆçš„åº”ç”¨ç¨‹åºä¸­å®ƒä»¬éƒ½ä¼šå˜å¾—å¾ˆæ–¹ä¾¿ã€‚

```
[dependencies]
actix = "0.7.4"
actix-web = "0.7.8"
bcrypt = "0.2.0"
chrono = { version = "0.4.6", features = ["serde"] }
diesel = { version = "1.3.3", features = ["postgres", "uuid", "r2d2", "chrono"] }
dotenv = "0.13.0"
env_logger = "0.5.13"
failure = "0.1.2"
frank_jwt = "3.0"
futures = "0.1"
r2d2 = "0.8.2"
serde_derive="1.0.79"
serde_json="1.0"
serde="1.0"
sparkpost = "0.4"
uuid = { version = "0.6.5", features = ["serde", "v4"] } 
```

##### è®¾ç½®åŸºç¡€ APP

åˆ›å»ºæ–°æ–‡ä»¶`src/models.rs` `src/app.rs`ã€‚

```
// models.rs
use actix::{Actor, SyncContext};
use diesel::pg::PgConnection;
use diesel::r2d2::{ConnectionManager, Pool};

/// This is db executor actor. can be run in parallel
pub struct DbExecutor(pub Pool<ConnectionManager<PgConnection>>);

// Actors communicate exclusively by exchanging messages. 
// The sending actor can optionally wait for the response. 
// Actors are not referenced directly, but by means of addresses.
// Any rust type can be an actor, it only needs to implement the Actor trait.
impl Actor for DbExecutor {
    type Context = SyncContext<Self>;
} 
```

è¦ä½¿ç”¨è¿™ä¸ª Actorï¼Œæˆ‘ä»¬éœ€è¦è®¾ç½®`actix-web`æœåŠ¡å™¨ã€‚åœ¨`src/app.rs`ä¸­æˆ‘ä»¬æœ‰ä»¥ä¸‹å†…å®¹ã€‚æˆ‘ä»¬æš‚æ—¶è®©èµ„æºæ„å»ºå™¨ä¸ºç©ºã€‚è¿™æ˜¯è·¯ç”±çš„æ ¸å¿ƒéƒ¨åˆ†è¦å»çš„åœ°æ–¹ã€‚

```
// app.rs
use actix::prelude::*;
use actix_web::{http::Method, middleware, App};
use models::DbExecutor;

pub struct AppState {
    pub db: Addr<DbExecutor>,
}

// helper function to create and returns the app after mounting all routes/resources
pub fn create_app(db: Addr<DbExecutor>) -> App<AppState> {
    App::with_state(AppState { db })
        // setup builtin logger to get nice logging for each request
        .middleware(middleware::Logger::new("\"%r\" %s %b %Dms"))

         // routes for authentication
        .resource("/auth", |r| {
        })
        // routes to invitation
        .resource("/invitation/", |r| {
        })
        // routes to register as a user after the
        .resource("/register/", |r| {
        })
} 
```

```
// main.rs
// to avoid the warning from diesel macros
#![allow(proc_macro_derive_resolution_fallback)]

extern crate actix;
extern crate actix_web;
extern crate serde;
extern crate chrono;
extern crate dotenv;
extern crate futures;
extern crate r2d2;
extern crate uuid;
#[macro_use] extern crate diesel;
#[macro_use] extern crate serde_derive;
#[macro_use] extern crate failure;

mod app;
mod models;
mod schema;
// mod errors;
// mod invitation_handler;
// mod invitation_routes;

use models::DbExecutor;
use actix::prelude::*;
use actix_web::server;
use diesel::{r2d2::ConnectionManager, PgConnection};
use dotenv::dotenv;
use std::env;

fn main() {
    dotenv().ok();
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let sys = actix::System::new("Actix_Tutorial");

    // create db connection pool
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    let pool = r2d2::Pool::builder()
        .build(manager)
        .expect("Failed to create pool.");

    let address :Addr<DbExecutor>  = SyncArbiter::start(4, move || DbExecutor(pool.clone()));

    server::new(move || app::create_app(address.clone()))
        .bind("127.0.0.1:3000")
        .expect("Can not bind to '127.0.0.1:3000'")
        .start();

    sys.run();
} 
```

åœ¨è¿™ä¸ªé˜¶æ®µï¼Œæ‚¨çš„æœåŠ¡å™¨åº”è¯¥åœ¨`127.0.0.1:3000`ä¸Šç¼–è¯‘å¹¶è¿è¡Œã€‚ç°åœ¨å®ƒæ²¡æœ‰åšä»»ä½•æœ‰ç”¨çš„äº‹æƒ…ã€‚è®©æˆ‘ä»¬åˆ›å»ºä¸€äº›æ¨¡å‹ã€‚

##### è®¾ç½® Diesel å¹¶åˆ›å»ºæˆ‘ä»¬çš„ç”¨æˆ·æ¨¡å‹

æˆ‘ä»¬ä»ä¸ºç”¨æˆ·åˆ›å»ºä¸€ä¸ªæ¨¡å‹å¼€å§‹ã€‚æ ¹æ®å‰é¢çš„æ­¥éª¤ï¼Œå‡è®¾æ‚¨å·²ç»å®‰è£…äº†`postgres`å’Œ`diesel-cli`å¹¶ä¸”æ­£åœ¨å·¥ä½œã€‚åœ¨æ‚¨çš„ç»ˆç«¯`echo DATABASE_URL=postgres://username:password@localhost/database_name > .env`ä¸­ï¼ŒæŒ‰ç…§æ‚¨çš„è®¾ç½®æ›¿æ¢æ•°æ®åº“åç§°ã€ç”¨æˆ·åå’Œå¯†ç ã€‚ç„¶åæˆ‘ä»¬åœ¨ç»ˆç«¯è¿è¡Œ`diesel setup`ã€‚è¿™å°†åˆ›å»ºæˆ‘ä»¬çš„æ•°æ®åº“ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œå¹¶è®¾ç½®ä¸€ä¸ªè¿ç§»ç›®å½•ç­‰ã€‚

è®©æˆ‘ä»¬å†™ä¸€äº›`SQL`ï¼Œå¥½å—ï¼Ÿé€šè¿‡`diesel migration generate users`å’Œ`diesel migration generate invitations`é‚€è¯·åˆ›å»ºè¿ç§»ã€‚æ‰“å¼€ migrations æ–‡ä»¶å¤¹ä¸­çš„ up.sql å’Œ down.sql æ–‡ä»¶ï¼Œåˆ†åˆ«æ·»åŠ ä»¥ä¸‹ sqlã€‚

```
 --migrations/TIMESTAMP_users/up.sql
CREATE TABLE users (
  email VARCHAR(100) NOT NULL PRIMARY KEY,
  password VARCHAR(64) NOT NULL, --bcrypt hash
  created_at TIMESTAMP NOT NULL
);

--migrations/TIMESTAMP_users/down.sql
DROP TABLE users;

--migrations/TIMESTAMP_invitations/up.sql
CREATE TABLE invitations (
  id UUID NOT NULL PRIMARY KEY,
  email VARCHAR(100) NOT NULL,
  expires_at TIMESTAMP NOT NULL
);

--migrations/TIMESTAMP_invitations/down.sql
DROP TABLE invitations; 
```

å‘½ä»¤`diesel migration run`å°†åœ¨ DB ä¸­åˆ›å»ºè¡¨å’Œæ–‡ä»¶`src/schema.rs`ã€‚è¿™æ˜¯æˆ‘å°†è°ˆåˆ°çš„å…³äº diesel-cli å’Œè¿ç§»çš„èŒƒå›´ã€‚è¯·é˜…è¯»ä»–ä»¬çš„æ–‡æ¡£ä»¥äº†è§£æ›´å¤šä¿¡æ¯ã€‚

åœ¨è¿™ä¸ªé˜¶æ®µï¼Œæˆ‘ä»¬å·²ç»åˆ›å»ºäº†æ•°æ®åº“ä¸­çš„è¡¨ï¼Œè®©æˆ‘ä»¬ç¼–å†™ä¸€äº›ä»£ç æ¥åˆ›å»º rust ä¸­çš„ç”¨æˆ·å’Œé‚€è¯·çš„è¡¨ç¤ºã€‚åœ¨`models.rs`ä¸­ï¼Œæˆ‘ä»¬æ·»åŠ äº†ä»¥ä¸‹å†…å®¹ã€‚

```
// models.rs
...
// --- snip
use chrono::NaiveDateTime;
use uuid::Uuid;
use schema::{users,invitations};

#[derive(Debug, Serialize, Deserialize, Queryable, Insertable)]
#[table_name = "users"]
pub struct User {
    pub email: String,
    pub password: String,
    pub created_at: NaiveDateTime, // only NaiveDateTime works here due to diesel limitations
}

impl User {
    // this is just a helper function to remove password from user just before we return the value out later
    pub fn remove_pwd(mut self) -> Self {
        self.password = "".to_string();
        self
    }
}

#[derive(Debug, Serialize, Deserialize, Queryable, Insertable)]
#[table_name = "invitations"]
pub struct Invitation {
    pub id: Uuid,
    pub email: String,
    pub expires_at: NaiveDateTime,
} 
```

æ£€æŸ¥æ‚¨çš„å®ç°æ²¡æœ‰é”™è¯¯/è­¦å‘Šï¼Œå¹¶ç•™æ„ç»ˆç«¯ä¸­çš„`cargo watch -x run`å‘½ä»¤ã€‚

### [é˜…è¯»æ›´å¤š...](https://hgill.io/posts/auth-microservice-rust-actix-web-diesel-complete-tutorial-part-1/#read-more)