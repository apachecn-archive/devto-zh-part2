# GraphQL 还是 REST？我应该用什么？

> 原文：<https://dev.to/sadarshannaiynar/graphql-or-rest-what-should-i-use-38mj>

这是一个已经在开发社区中争论了一段时间的话题，许多人对此有不同的看法。那么我应该用哪一个呢？是街区里的新人还是经验丰富的老人？。在我们继续之前，让我们了解一下 REST 和 GraphQL。

### 什么是休息？

表述性状态转移或 REST 是一种架构风格，它符合特定的指导原则和 Web APIs 实现的约束。这是罗伊·菲尔丁在他的博士论文中提出的。它鼓励用无状态的信息交换模式来分离客户机和服务器。请记住，不是所有的 API 都是 REST，但是所有 RESTful 服务都是 API。

### 什么是 GraphQL？

GraphQL 是一种用于 Web APIs 的查询语言。它由脸书于 2012 年创建，并于 2015 年开源。它既不是架构模式，也不是 web 服务。它充当中介，帮助查询从各种数据源接收的数据。这些数据源可以是数据库或 web 服务。

多年来，REST 已经成为 Web API 的主导标准。因为它使用了标准的 HTTP 方法(GET、POST、PUT、DELETE 等。)随着互联网中 web 应用的增加，它获得了发展势头和受欢迎程度。此外，它与语言和平台无关，这使它成为创建 web 服务的更好选择。因为当调用 URL 时，每个数据都被视为要发送的资源，所以甚至可以使用 web 浏览器或 cURL 请求来调用它。

### 弊之馀

尽管 REST 非常成功，但它也有缺点，随着 RESTful 服务的规模和复杂性的增长，这些缺点变得非常明显。

#### 1。多个端点(多次往返)

在 RESTful 服务中，URL 只是表示一个资源。因此，当需要访问多个资源时，您需要调用多个端点，从而导致多次往返以获取所有必要的数据。

例如，让我们考虑一个博客应用程序。你有一篇博文，每篇博文都有评论。一个典型的 REST 端点将看起来像

```
GET /posts/<postId> - To fetch a particular post
GET /posts/<postId>/comments - To fetch all comments related to a post
GET /posts/<postId>/comments/<commentId> - To fetch a particular comment of a particular post 
```

Enter fullscreen mode Exit fullscreen mode

你可以看到端点的长度在增加。随着实体之间关系的增加，端点 URL 的数量也在增加。随着应用程序的增长，维护这些 API 变得很麻烦。

#### 2。过蚀刻/欠蚀刻数据

有时，当您与 API 交互时，您会在获得相关数据的同时获得不必要的数据，有时您会接收不到足够的数据，因此您最终会进行多次往返。这是 RESTful 服务中的一个常见问题。有些情况下，您可能只需要 2-3 个值，但您会得到大约 20-25 个值作为响应。这只会导致传输大量未使用的数据，从而增加响应时间。在后一种情况下，您可能需要比从单个端点获得的信息更多的信息，因此有必要进行多次往返。这也导致客户端获取所有所需数据的总时间增加。

#### 3。API 版本控制

API 版本控制是一种方法，用于避免由于响应格式的变化而中断客户端应用程序。当 API 响应格式发生变化时，会创建一个新版本。这样做是为了让生产客户端应用程序可以按预期运行，并给开发人员一些喘息时间来迁移到新的 API 版本。

但是这种版本化成为一个问题，因为当一个新版本发布时，它意味着新的端点。API 的维护和使用变得很困难，并且经常导致重复的代码。

#### 4。弱类型化

并不是所有我们从 RESTful 服务收到的数据都是强类型的，也就是说，它们没有被恰当地赋予特定的数据。在编写 API 文档时，这就成了一个问题，因为我们必须指定客户端通过调用端点可以得到什么样的数据。

#### 5。客户被蒙在鼓里

客户端在收到响应结构之前并不知道它。因此，客户端不知道它可以期待什么样的响应。这可能经常导致一些错误和数据得不到正确处理，从而降低了使用 API 的可靠性。

### 亲图 SQL

GraphQL 是由脸书发明的，主要是为了克服 REST 的缺点。

#### 1。一个请求就能得到全部

GraphQL 服务仅公开一个端点，客户端可以通过该端点传递检索数据所需的查询。使用之前考虑过的同一个示例，让我们看看 GraphQL 查询

```
{
    findPost(id: <postId>) {
        id
        title
        content
        author
        comments {
            id
            comment
            commentedBy
        }
    }
} 
```

Enter fullscreen mode Exit fullscreen mode

如您所见，我们在一个请求中就获得了所有必要的数据。因此，当您需要一个新字段时，只需将其添加到查询中，它就会开始出现在响应中。

#### 2。强类型

GraphQL 受强类型模式支配。这些类型可以是基本类型，也可以是派生类型。强类型系统允许 API 自文档化，从而使客户知道当查询特定查询时他将得到什么响应。

#### 3。客户是驱动者

GraphQL 提供了一种声明性语法，允许客户端指定他们确切需要的字段。这消除了数据过度提取和提取不足的可能性，因为是客户端根据模式向 GraphQL 服务器陈述他的数据需求。

#### 4。API 演变

由于 GraphQL 中的一切都是模式驱动的扩展，所以这不会成为问题，因为新字段不会影响现有字段，而且 GraphQL 还引入了`@deprecated`注释来取代字段。这消除了对 API 进行版本控制的需要。

#### 5。传输层不可知

这是 GraphQL 的一个非常好的优势。API 服务器可以通过 HTTP、HTTPS、WebSockets、TCP、UDP 等任何协议交换信息。这是因为 GraphQL 最不关心客户机和服务器之间如何交换信息。

### 图 QL 的 Cons

哇，GraphQL 太棒了。但这是一个众所周知的事实，这个世界上的一切都有一个陷阱，GraphQL 也不能逃脱这个事实。

#### 1。不存在的缓存

与使用本地 HTTP 缓存机制的 RESTful 服务不同，GraphQL 不支持浏览器和移动缓存。这导致了为了实现缓存而进行的开发工作。尽管像 Relay 这样的工具为缓存提供了一些支持，但是它们没有 RESTful 服务所使用的缓存机制成熟。

#### 2。监控和错误报告

RESTful 服务利用 HTTP 状态代码来处理可能遇到的不同错误。这使得对开发人员来说监视 API 变得非常容易和容易。但是用 GraphQL 服务总是返回`200 OK`响应。典型的 GraphQL 错误消息如下所示，状态代码为`200 OK`。

```
{
    errors: [
        { 
            message: 'Some error occurred'
        }
    ]
} 
```

Enter fullscreen mode Exit fullscreen mode

这使得处理错误场景非常困难，并且使得监控过程很麻烦。

#### 3。暴露的模式和资源攻击

与 RESTful 服务不同，GraphQL 服务要求客户端必须了解要查询的数据模式。如果你向第三方公开你的 API，你基本上是在公开你的内部数据结构。必须非常小心，以使客户端不会创建昂贵的连接查询，这可能会导致对服务器的拒绝服务(DoS)攻击。

#### 4。安全性-身份验证和授权

关于如何处理 GraphQL 服务器的安全部分，GraphQL 社区中仍然存在困惑。仍然没有集成身份验证和授权的本地解决方案。它通常被抽象到业务逻辑层来授权用户，但是我们真的必须为未经授权的用户解析和验证查询吗？这仍然是 GraphQL 领域中的一个问题。

#### 5。N + 1 查询问题

在 RESTful 服务中，记录执行的 SQL 查询并进一步优化它非常容易。但是在 GraphQL 的情况下，解析性质是动态的，很难获得准确的查询并进一步优化它。有时，字段解析器可能会导致 N + 1 查询问题和昂贵的连接操作。但是脸书正在开发像 DataLoader 这样的工具来解决这个问题。所以也许将来这不会是一个缺点。

#### 6。年轻的生态系统

GraphQL 就像这个 API 生态系统中的一个婴儿，这意味着不时会有问题和突破性的变化，所以我们在使用任何与 GraphQL 相关的库和模块时都必须非常勤奋。

### 结论

让我先说 GraphQL 仅仅是一个工具，REST 是一个架构模式。如果说 GraphQL 可以取代 REST，那就大错特错了。但是在这个微服务的时代，我们在原子级别隔离和创建 API，我们可以利用这两者，没有一个银弹。

GraphQL 服务器将性能放在首位，而 RESTful 服务则保持可靠性。

GraphQL 端点可以通过现有的 RESTful 服务作为端点公开，例如`/graphql`，它可以作为运行 GraphQL 查询的网关，同时还为某些用例维护 REST 端点。

在某些用例中，使用 GraphQL 会更好，在某些用例中，REST 肯定会胜出。因此，在说哪种更好之前，只需分析需求和相关数据，就可以得出哪种更好的结论。