# 在从社交游戏开发经验中学到的游戏中使用 Redis 时的 Tips

> 原文:# t0]https://dev . to/gumi/redistrips-59 na

本稿以“[在从沙蚕开发经验中学到的游戏中使用 Redis 时的 Tips](https://qiita.com/ta_ta_ta_miya/items/0c50e169b5ed58aaf26b) ”为基础进行了修改，整理了文章。

近年来的 KVS 中，Redis 取得了霸权(与本公司相比)，公司内部的很多项目都开始使用 Redis。 因此，诀窍也积累了很多，所以我来总结一下(我想也有只适用于处理大量用户数据的社交游戏的部分)。

# 单纯地将性能视为 RDB <Redis，暂且不缓存

虽然说“Redis 很快”，但是对索引好的 RDB 的查询也并不慢。 毕竟通信成本要大得多，所以综合考虑内部的取得时间差，大多数情况下是误差。 将只能由 RDB 主键检索的数据缓存在 Redis 中没有优势。 写要缓存的代码的成本更高。 对于耗时且频繁访问的查询(如必须引用 RDB 中的多个表)，应该进行高速缓存。

# 基本上不附带 Expire

Redis 还具有可以使数据永久化的特点，但反过来说，由于不会消失，磁盘容量会不断受到压迫。 对于不需要持久性的内容，添加 Expire 可以减少磁盘被破坏的可能性。 特别是对于缓存，这是必需的。

# 本来就设计成不压迫容量

Expire 只是过期时间，如果短时间内有大量访问，根据数据设计的不同，也会出现容量不足的情况。 所以，请事先设计好数据不要那样爆炸。 严禁设计为每次用户执行某项动作时记录都会增加(例如，用户每次执行请求时记录会增加一条记录)。

基本上对于用户和功能，如果让数据量达到 1:1 的话，数据量很难一下子增加，而且数据量也很容易掌握(在不久前的游戏中常见的“一天打一次招呼”的功能，一次打招呼一个记录。

# 永久数据

## 不同时统一更新 Redis 和 RDB 的数据

如果同时更新 Redis 数据和 RDB 数据时出现错误，则 RDB 数据受事务保护，但需要手动回滚 Redis 数据。 安装上和维护性都不好，所以应该极力避免。

原本在错误时就必须回滚的数据，也许应该避免放入 Redis。 如果出现错误的话，那个数据会暂时删除，轻松一点的话会有各种各样的轻松。

## 避免在 Redis 中输入用户的永久数据

虽然和上一项有点关系，但是最好不要放入用户的永久数据。 因为用户数会因为广告效果等每天大量增加，所以会在意想不到的地方产生债务(虽然 RDB 的负荷分散很充分，但是没有考虑 Redis 的负荷分散！ 等等。 为了分散负荷，必须暂时删除数据！ 但是因为是用户数据，所以不能删除！ 等等)

本来就有 RDB，应该没有必要特意将 Redis 用于永久数据的保存地(但是一点点的参数，在注意到的时候不知为什么就只被 Redis 保存了。 ~~必须进行千兆位制~~)。

非用户数据的永久数据是设定类的吗...(不出例子)。 除了用户数据以外，开发方还可以在一定程度上控制数据量，如果可以方便地使用的话，我想可以使用。

# 游戏中 Redis 的使用方法

## 缓存

因为是 KVS，所以最先想到缓存，但是如上所述，缓存对象还是要斟酌一下。 当然 Expire 是必须的！ 还有，负荷高的时候可以做到向外扩展就好了。 我觉得向外扩展 Redis 比向外扩展效果更好(也许是因为是单线程，所以有过即使增加内核数量等，性能也不会提高到那个程度的经验)。 各种语言的 Redis 库也比较支持阴影。 因为大致上是根据密钥的散列值分配给各影子的实现，所以高速缓存服务器的增减也很容易。

## 排行榜

使用已排序集实现排名是 Redis 的有效用法。 因为各用户的积分应该保存在 DB 里，所以如果发生了什么事，只要重新统计排行榜就可以了，这一点也是 good！ (~~同分问题不在管辖范围内~~)

## 瑞德(大家一起打老板的家伙)

像多用户打倒一体的 boss 这样的东西，boss 体力减少的比赛状态很麻烦，但是 Redis 的 incrby、decrby 很原子，所以大家一起打也没关系(做了哦)。

# 最后

到此为止。 虽然 Redis 很方便，但是作为数据的保存地址，寄在 RDB 上更容易运用。 即使 Redis 的内容被吹走了，只要重新制作就可以了，这样的设计在精神上很轻松(我并不是说 Redis 的数据很容易被吹走，而是说必须死守的东西很多的话就很辛苦)。