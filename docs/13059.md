# 即时一致性与最终一致性

> 原文:[https://dev . to/barryo sull/immediate-vs-finally-consistency-5cna](https://dev.to/barryosull/immediate-vs-eventual-consistency-5cna)

在[上一篇文章](https://barryosull.com/blog/projection-building-blocks-what-you-ll-need-to-build-projections)中，我们看了投影仪，它是任何 CQRS/事件驱动系统的支柱。这篇文章原本是关于实现投影仪的，但我意识到有一个重要的问题需要首先回答，这个问题将形成解决方案，“我们什么时候投影事件，现在，还是以后？”。事实证明，这个问题有着深远的影响，所以我们在继续讨论之前深入了解它是很重要的。

# [](#immediate-vs-eventual-consistency)即时一致性与最终一致性

当谈到投影仪时，有两种选择，立即或最终的一致性。有了 immediate，事件一发生就被投影仪处理。使用 usually，事件会在稍后的时间(通常是一瞬间之后)在不同的进程中处理。

Immediate 是一种要么全有要么全无的操作，如果出现任何问题，整个过程都会暂停。不存储任何事件，也不处理任何事件。最终是一个交错的操作，一旦事件被存储，每个投影仪将在以后处理它们(并且可能失败)。

## [](#reasons-to-not-use-immediate-consistency)不使用即时一致性的理由

从上面你可能会认为立即是显而易见的选择，它似乎更简单，有更少的移动部分。嗯，简单是一种错觉。事实证明，immediate 要复杂得多，下面的问题将说明原因。

### [](#1-what-happens-if-one-of-the-projectors-has-an-error)1。如果其中一台投影仪出现错误，会发生什么？

假设投影仪出现故障并抛出异常，你会怎么做？理想的解决方案是回滚所有的更改，即。假装什么都没发生过。如果您使用单个数据库来存储所有内容(transactions FTW ),这很容易，但是如果您使用多种技术(例如 Redis/MySQL/MongoDB/等...)那么这个问题就变得难很多了。您是否回滚所有这些文件？你是怎么做到的？你如何测试它？如果进行了两次无法回滚的 API 调用，会发生什么情况？嗯，事情变得非常复杂。

### [](#2-what-happens-if-one-of-the-projectors-has-a-temporary-error)2。如果其中一台投影仪出现临时错误，会发生什么情况？

有些错误是暂时的。假设您有一台连接到速率受限的 API 的投影仪。

*   用户发出请求导致事件
*   投影仪试图处理该事件
*   它发出一个 API 请求，你超过了速率限制，所以它失败了
*   另一个用户发出请求，导致一个事件
*   投影仪试图处理该事件
*   它发出一个 API 请求，你在限制之下，所以它通过

你如何处理这个？你只是接受它并允许过程失败吗？你是否强迫用户重试请求，并希望这次能成功？这不是一个很好的用户体验，而且肯定会惹恼用户。

### [](#3-what-happens-if-one-of-the-projectors-is-slow)3。如果其中一个投影仪很慢会怎么样？

假设其中一个投影仪执行一个昂贵的过程，比如连接到一个缓慢的外部服务(例如发送电子邮件)。对于即时一致性，我们必须等待它完成，然后才能让用户继续。更糟糕的是，如果我们使用事务来确保跨域的数据完整性(例如，电子邮件地址是唯一的)，那么您可能会减慢其他流程，而不仅仅是这个流程。这些成为影响整个系统的瓶颈。

### [](#4-what-happens-when-you-launch-a-new-projector-in-a-running-system)4。在运行的系统中启动新的投影仪会发生什么？

即使你选择立即一致的投影机，你仍然需要一些方法来播放历史事件到投影机，否则你将无法推出新的。虽然新的投影仪正在旋转，但它们与现场系统并不一致，但它们将会一致。你可以设计这个过程，这样你只在所有的项目完成后才发布代码(我们做了，做得很好)，但是即使这样，你也必须构建一个最终一致的系统的核心。

### [](#5-what-if-you-need-to-process-events-on-a-different-service)5。如果您需要在不同的服务上处理事件，该怎么办？

啊，分布式系统的经典问题。在单个服务中处理事件可能会变得复杂，但与在不同的服务/服务器上立即处理事件相比，这算不了什么。最懒惰的解决方案是通过同步调用强制其他服务立即处理事件，但是现在您已经将自己耦合到了那个系统；如果下跌；你下去了，然后你做什么？一旦您与另一个服务进行通信，即时一致性就变得非常困难(几乎不可能)，即使它是您自己控制的服务。

## [](#reasons-to-use-eventual-consistency)使用最终一致性的理由

现在我们已经看到了强制即时一致性所导致的问题，让我们看看当我们采取最终一致的方法时事情会如何发展。

### [](#1-what-happens-if-one-of-the-projectors-has-an-error)1。如果其中一台投影仪出现错误，会发生什么？

这很好，如果有错误，报告它，也许禁用投影仪(取决于错误)。一旦事件发生，它就发生了，所以如果一个投影仪出现故障，我们不需要将事件或更改回滚到其他投影仪。相反，我们修复投影仪，推出新版本，让它赶上来。一旦你接受了最终的一致性，像这样的问题就变得容易处理多了。

### [](#2-what-happens-if-one-of-the-projectors-has-a-temporary-error)2。如果其中一台投影仪出现临时错误，会发生什么情况？

同样，非常简单。我们只是吞下错误，再试一次。我们知道请求最终会被接受，我们只需要继续发送它。如果是速率限制问题，我们可以调节投影仪，降低它处理事件的速度。

### [](#3-what-happens-if-one-of-the-projectors-is-slow)3。如果其中一个投影仪很慢会怎么样？

这根本不是问题。投影仪在自己的后台进程中运行，所以他们想用多长时间就用多长时间。如果我们发现某个投影仪特别慢，并且影响到其他投影仪，我们可以简单地将它转移到自己的进程中，然后继续前进。很好很容易。

### [](#4-what-happens-when-you-launch-a-new-projector-in-a-running-system)4。在运行的系统中启动新的投影仪会发生什么？

这里不多说了。运行新投影仪与运行任何其他投影仪一样，它将播放事件，直到最终赶上。这已经不再是一个问题了。

### [](#5-what-if-you-need-to-process-events-on-a-different-service)5。如果您需要在不同的服务上处理事件，该怎么办？

是的，这里也没有问题。事件被其他服务以自己的速度消费。生产服务不需要等待它们来处理事件，所以它们是否运行缓慢，甚至它们是否正在运行都没有关系。

## [](#immediately-consistent-views)立即一致的看法

在这一点上，我希望让您相信最终的更好，但是仍然有一个问题需要解决，一个您现在可能会问的问题，“当您需要视图立即一致时会发生什么？”。

举个例子，假设您已经处理了一个向购物车添加商品的请求，并且用户被重定向到购物车页面，如果因为购物车投影仪运行缓慢而没有显示最新的商品，您该怎么办？很简单，你假装的。即使视图显示商品不在购物车中，您也可以将页面呈现为商品确实在购物车中。

这并不像听起来那么疯狂，事实上大多数应用程序一直在这样做，你几乎不会注意到。你有没有在脸书发帖，看到你的帖子出现，然后刷新页面，发现你的帖子不在那里？他们是假装的。这种伪装大部分是在客户端完成的，而且像 [reflux](https://github.com/reactjs/redux) 这样的东西使它变得更加容易。这种模式通常被称为乐观 UI，[这里有一篇关于这个概念的文章](https://uxplanet.org/optimistic-1000-34d9eefe4c05)。

我想说的是，这真的没什么大不了的，应用程序总是这样做，而且很容易实现，所以真的没有理由不这样做。

## [](#choosing-immediate-or-eventual)选择立即或最终

在这个阶段，应该清楚这两者之间有一个权衡。Immediate 更容易理解，因为它是一个要么全有要么全无的操作，但是它为许多潜在的问题打开了大门，尤其是当您转向分布式架构时。另一方面，finally 给了你更多的自由和可伸缩性，但是它使调试更加困难。当决定使用哪一种时，一定要问自己如何处理失败。如果您正在使用多种存储技术或 API，那么您应该认真考虑转向最终的一致性。

> Protip:当运行验收测试时，立即一致地运行您的所有投影仪，这使得在测试过程中更容易发现错误，并使调试变得不那么复杂。

就我个人而言，在处理领域规划(即验证领域范围内的业务约束所需的规划)时，我选择即时一致性，而对于其他所有事情，我选择最终一致性。

你呢，你选择立即一致还是最终一致？你遇到过什么样的问题，你是如何解决的？请在评论中告诉我！