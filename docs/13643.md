# Redis 高可用性

> 原文:[https://dev.to/dzeban/redis-high-availability-5b7b](https://dev.to/dzeban/redis-high-availability-5b7b)

最近，在我工作的地方，我们开始使用 Redis 进行类似会话的对象存储。尽管这些对象很小并且寿命很短，但是没有它们，我们的服务将停止工作，因此出现了一个关于 Redis 高可用性的问题。事实证明，对于 Redis 来说，没有现成的解决方案——有多种选择，有不同的权衡，信息有时有点匮乏，分布在文档和博客帖子中，因此我写这篇文章是希望帮助像我一样的另一个可怜的人解决这样的问题。我绝不是 Redis 大师，但我还是想分享我的经验，因为毕竟这是我的个人博客。

我将从节点故障而不是持久性的角度来描述高可用性。

## Redis 高可用性选项

独立的 Redis 是一个很好的老版本，你可以在安装后启动它，它很容易设置和使用，但是它不能从运行它的节点的故障中恢复。无论您使用 RDB 还是 AOF，只要有一个节点不可用，您就有麻烦了。

多年来，Redis 社区提出了一些高可用性选项——其中大多数内置于 Redis 本身，但也有一些是第三方工具。让我们深入研究一下。

## 简单重复复制

Redis 有一个复制支持，就像永远一样，它工作得很好——只需将`slaveof <addr> <port>`放入配置文件，实例将开始从主服务器接收数据流。

您可以为主服务器配置多个从服务器，您可以为从服务器配置从服务器，您可以启用仅从服务器持久性，您可以使复制同步(默认情况下是异步的)——您可以使用 Redis 做的事情似乎只受您的想象力的限制。只需阅读用于复制的[文档](https://redis.io/topics/replication)—这真的很棒。

优点:

*   设置快速简单
*   可以通过配置管理工具实现自动化
*   只要有一个主实例可用，就继续工作——它可以承受所有从实例的失败。

缺点:

*   写操作必须由主机完成
*   从属服务器可以提供读取服务，但是因为复制是异步的，所以您可能会获得过时的读取
*   它不共享数据，所以主服务器和从服务器会有不平衡的利用率
*   如果主服务器出现故障，您必须手动选择新的主服务器

最后一点是，依我看，这是一个主要的缺点，而这正是 Redis Sentinel 可以提供帮助的地方。

## Redis 复制用哨兵

没有人想在半夜醒来，只是为了发布`SLAVEOF NO ONE`来选举新的主人——这很愚蠢，应该自动化，对吗？没错。这就是 Redis Sentinel 存在的原因。

Redis Sentinel 是监控 Redis 主设备和从设备并自动从其中一个从设备中选出新主设备的工具。这是一个非常关键的任务，所以你最好让 Sentinel 本身高度可用。幸运的是，它有一个内置的集群，这使它成为一个分布式系统。

Sentinel 是一个法定人数系统，这意味着为了就新的主节点达成一致，应该有大多数 Sentinel 节点存活。这对于如何部署 Sentinel 有着巨大的影响。这里基本上有两种选择——与 Redis 服务器共存或部署在单独的集群上。与 Redis 服务器共存是有意义的，因为 Sentinel 是一个非常轻量级的过程，所以为什么要为额外的节点付费呢？但是在这种情况下，我们失去了弹性，因为如果您将 Redis 服务器和 Sentinel 放在 3 个节点上，您只能失去 1 个节点，因为 Sentinel 需要 2 个节点来选举新的 Redis 服务器主服务器。没有哨兵，我们可能会失去两个从节点。所以也许你应该考虑一个专用的哨兵集群。如果你在云上，你可以把它部署在某种纳米实例上，但可能不适合你。权衡，权衡，我知道。

除了维护一个分布式系统之外，使用 Sentinel，您应该改变客户机使用 Redis 的方式，因为现在您的主节点可以移动了。在这种情况下，您的应用程序应该首先访问 Sentinel，向它询问当前的 master，然后才能使用它。您可以在这里用 HAProxy 构建一个聪明的黑客——您可以在 Redis 服务器前放置一个 HAProxy，在 TCP 检查的帮助下检测新的主服务器，而不是使用 Sentinel。参见 HAProxy 博客上的示例

尽管如此，Sentinel 与 Redis 服务器共存是 Redis 高可用性的一个真正常见的解决方案，例如，Gitlab 在其管理指南中推荐了它。

优点:

*   出现故障时自动选择新主机。耶！
*   易于设置，(似乎)易于维护。

缺点:

*   还要维护另一个分布式系统
*   如果与 Redis 服务器不在同一位置，可能需要一个专用集群
*   仍然不共享数据，所以与从服务器相比，主服务器会被过度利用

## 再组团

上面所有的解决方案看起来都是半吊子，因为它们增加了更多的东西，而且这些东西至少乍一看是不明显的。我不知道任何其他系统通过添加另一个本身必须可用的集群来解决可用性问题。就是烦。

因此，最近版本的 Redis 出现了集群——这是一个内置的功能，为已知和受欢迎的 Redis 添加了分片、复制和高可用性。在一个集群中，有多个主实例服务于一个键空间子集。客户端可以向任何主实例发送请求，这些请求将重定向到给定键的正确实例。主实例可以有任意多的副本，即使没有仲裁，这些副本也会自动提升为主实例。不过，请注意，整个集群工作需要主实例仲裁，但是包括新的主选举在内的分片工作不需要仲裁。

Redis 集群中的每个实例(主或从)都应该部署在一个专用节点上，但是您可以配置交叉复制，其中每个节点将包含多个实例。不过，这里有一些尖锐的地方，我将在下一篇文章中说明，所以请继续关注！

优点:

*   跨多个节点划分数据
*   具有复制支持
*   内置了主服务器的故障转移

缺点:

*   不是每个图书馆都支持它
*   可能不如独立的 Redis 或 Sentinel 强大
*   工具是古怪的，构建和维护(替换节点)集群是一个手动过程
*   引入额外的网络跳，以防我们错过碎片。

## Twemproxy

Twemproxy 是一个内存数据库的特殊代理——即 memcached 和 Redis——由 Twitter 构建。它添加了带有一致散列的分片，因此重分片并不痛苦，而且还维护了持久连接并支持请求/响应管道。

我没有尝试过，因为在 Redis 集群的时代，它似乎与我不再相关，所以我无法说出利弊，但 YMMV。

## 再创企业

在最初的帖子之后，很多人联系我，告诉我他们在 Redis 实验室的 Redis Enterprise 上取得了巨大的成功。看看 Reddit 上的这张照片。重点是，如果您的工作负载非常高，并且您的数据更加重要，并且您能够承受，那么您应该考虑他们的解决方案。

你也可以查看他们关于 Redis 高可用性的指南——它也写得很好，并且有插图。

## 结论

为 Redis 高可用性选择正确的解决方案充满了权衡。没有人比你更了解你的情况，所以要了解 Redis 是如何工作的——这里没有魔法——最终，你必须维护这个解决方案。在我的例子中，经过大量的测试并编写了一个关于如何处理故障的文档，我们选择了一个具有交叉复制的 Redis 集群。

目前就这些，请继续关注 Redis 集群的专题文章！