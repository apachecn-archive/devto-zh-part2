# 构建基于堆栈的虚拟机

> 原文:[https://dev . to/jimsy/building-a-stack-based-virtual-machine-5g KD](https://dev.to/jimsy/building-a-stack-based-virtual-machine-5gkd)

在过去的几天里，我一直在阅读 Fletcher Haynes 关于基于寄存器的虚拟机的伟大系列，我认为是时候谈谈我是如何创建堆栈虚拟机箱的了。

先说一些背景；当我学习一门新语言时，我的目标是实现一门编程语言。构建一门语言使用了程序员工具箱中的所有工具，并给了你充分的机会来锻炼你的大脑肌肉。我认为，如果你能使用一种特殊的工具开发出一种有效的(如果简单的话)编程语言，那么你就能开发出你的客户或雇主想要的任何东西。多年来，我已经用 Ruby、Rubinius、Elixir、Erlang、Rust 和 C++/LLVM 构建了语言。所有这些语言被统称为“Huia”，尽管除了它们的作者之外没有任何共同之处。他们中的一些躺在互联网上，一些已经被删除的后代。

去年到了学习 Rust 的时候，我决定不要把一门语言构建成一个可怕的复杂的烂摊子，而是选择一个编程环境的特定部分来构建它们。这就是我构建 [wrc](https://crates.io/crates/wrc) 和 stack-vm 的原因。

## [](#what-is-a-stackbased-virtual-machine)什么是基于栈的虚拟机？

冯·诺依曼机器主要有三种:

*   *累加器* -处理器的最基本形式，其中只有一个寄存器用于存储计算结果。
*   *堆栈* -堆栈机器使用操作数堆栈将结果从顶部推入和弹出。
*   *寄存器* -寄存器机器使用许多命名的(或编号的)寄存器来存储值或传递参数。

据我所知，大多数语言虚拟机都是堆栈机器(非科学的例子——不要嘲笑我)。我认为这主要是因为它们更容易编写，并且在编写程序集时不必跟踪寄存器的使用情况。有趣的是，堆栈和寄存器机器可以相互模拟，这是有意义的，因为我们在通常是寄存器机器的物理处理器上运行它们。

你可以把栈想象成一个简单的数组。当你初始化你的机器时，栈是空的(即`[ ]`)，机器执行的每条指令可以从栈顶弹出值，并将值压入栈中。假设我们从简单的计算器示例开始，添加两个数字:

*   初始化机器(`[ ]`)
*   使用一条`push`指令将数字 2 添加到堆栈上:`push 2` ( `[ 2 ]`)
*   将数字 3 推到堆栈上:`push 3` ( `[ 2, 3 ]`)
*   使用一条`add`指令从堆栈中弹出两个项目，并将结果`add` ( `[ 5 ]`)推回

希望这足以让您对堆叠机的工作原理有一个基本的了解。

## [](#stack-machine-terminology)栈机术语

以下是我们将在本系列课程中使用的一些基本术语:

*   *Stack* -一堆值，通常以数组或向量的形式，其中的值只能从“顶部”添加或删除。
*   *操作数*——由指令对进行操作的被添加到堆栈和*中的值。*
*   指令 -我们机器中最小的行为单位。指令可以将操作数弹出堆栈，对其进行操作，然后将结果推回堆栈。
*   *操作码*——操作码的简称。对应于特定指令的一个唯一编号，它允许程序比使用它们的名字更紧凑地序列化。
*   *程序* -机器要执行的指令列表(通常通过操作码)及其操作数参数。
*   *指令指针* -程序的索引，跟踪当前执行的(或下一条)指令。

还有一些其他的小细节，但我们会在进行中涵盖它们。

想看看实际代码吗？[继续第 2 部分](https://dev.to/jimsy/building-a-stack-based-virtual-machine-part-2---the-stack-d07)。