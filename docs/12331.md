# 为什么我们从 NoSQL MongoDB 迁移到 PostgreSQL

> 原文:[https://dev . to/pavanbelagatti/why-we-moved-from-no SQL-MongoDB-to-PostgreSQL-2 m0](https://dev.to/pavanbelagatti/why-we-moved-from-nosql-mongodb-to-postgresql-2m0)

最初发表于[shippible](http://bit.ly/mongodbvspostgres)
shippible 成立于大约 5 年前。Docker 的简单 CI 已经发展成为一个成熟的 DevOps 自动化平台，支持大量的工具和语言、流行的第三方工具，并且很快会支持多种操作系统。今天，我们部署了 50 多个微服务，以及核心 API 和 UI。在员工方面，我们也有了相当大的增长，我们有许多人已经开发了大规模的 web 级应用程序，也有一些人相对来说是企业级应用程序的新手。

几年前，我们将代码库转移到 monorepo，这帮助我们在代码重用和整体开发速度方面取得了巨大的进步。我们非常自豪能够在零停机升级的情况下运行 99.99%可用性的弹性服务。

从一开始，我就决定将 Javascript 作为我们的默认编码语言。最重要的原因是，我想雇用能够处理产品各个方面的全栈开发人员，所以我们选择 Angular.js 作为 UI，Node.js 作为 API，以及无模式 JSON 数据库(又名 NOSQL MongoDB)。我们基于这一理念做出了所有的技术决策(另一篇博客讲述了我所学到的东西，以及为什么我不再是全栈开发人员的粉丝),它运行得非常好...一段时间。

它始于一些小问题...

尽管我们有能力以闪电般的速度添加功能，但我们开始看到偶尔的停机时间，这似乎总是归结于 MongoDB。例如:

我们非常高兴 MongoDB 的主实例和辅助实例能够全天候可用。然而，有一天我们的性能突然下降，每个文档的检索时间开始超过一秒。我们尝试使用许多工具和分析器，但是无法弄清楚发生了什么。最后，我们重建了一个新的服务器，将它切换为主服务器，并重建了辅助服务器。检索时间再次下降到 150 毫秒。这还是一个未解之谜！我们的 Mongo 实例达到了 4TB，我们为不断增长的采用率感到自豪。由于缺乏管理大型数据库的工具，我们依赖索引来降低搜索时间。当 NoSQL DBs 首次流行时，没有办法创造独特性，所以这些功能是事后才想到的。我们的 MongoDB 的一些膨胀实际上是由于索引，但是重建它们是原始的，并且整个 DB 将被锁定。
有一次，我们需要重启我们的数据库服务器，MongoDB 花了 4 个小时才恢复在线。这导致我们的服务停机时间延长，并且我们对 MongoDB 流程或状态的了解非常少。

然后是致命一击！
MongoDB 最大的优点和缺点是它有一个灵活的模式。这意味着同一集合中的文档(旧世界中的表)不需要有相同的字段集或结构，集合文档中的公共字段可以保存不同类型的数据。简而言之，没有严格的模式规则，这就给牛仔们带来了很多麻烦。

虽然许多开发人员喜欢这种灵活性，但这也让他们承担了很高的责任来把事情做好。

例如，让我们考虑一个存储 Git 存储库信息的简单模式:

在
供应商 2012 年 12 月 1 日
报告 2012 年 12 月 1 日
报告名称 2012 年 12 月 1 日
为 2014 年 7 月 17 日
hasTeams 2016 年 2 月 23 日

正如您所猜测的，随着字段的增加，模式会在一段时间内更新，以满足不断发展的产品的新需求。这意味着，根据存储库添加到该文档的时间，它可能有也可能没有 isPrivate 和 hasTeams 字段。我们的后端和前端服务需要优雅地处理这两种情况，这导致了如下代码:

[![alt text](../Images/824e4185ae0f18561bd04cd95b4fd1b1.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--fXxG729N--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/ounu2371vuuwpcc0cssd.png)

每个使用 repo.hasTeams 的地方，我们都需要添加这段代码。随着许多微服务、许多模式和 40 多名开发人员到处添加这些模块，我们的代码库开始变得难看。此外，每次我们看到系统出现故障时，都是一个壮观的崩溃，没有简单的方法来恢复。我敢打赌，90%的崩溃都是由于某段代码需要一个不存在于该文档中的字段。内部头脑风暴提出了构建模式验证器和各种黑客的想法，但这难道不是数据库应该提供的现成功能吗？一个针对 Mongo(或任何等效的 NoSQL 数据库)的大黑点！

压垮骆驼的最后一根稻草是，我们引入了一个关键字段，它绝对需要出现在我们最重要的集合中的每个文档中。为了确保每个文档都包含该字段，我们必须逐个检索每个文档，更新它，然后放回原处。由于收集了数百万个文档，这一过程导致数据库性能下降到不可接受的程度，我们不得不接受 4 个多小时的停机时间。

就在那时，我决定 NoSql 不适合我们。每个人都有自己的想法，我们已经完成了与它的斗争，并给我们的客户(和我们自己)带来了不必要的心痛。

## [](#postgres-to-the-rescue)Postgres 来救援了！

在大约一年前发生的最后一次事件之后，我们迁移到了 PostgreSQL。如果你感兴趣的话，我可以在另一篇博客中解释一步一步的迁移过程。我们没有遗憾，以下因素极大地提高了我们的可用性和弹性:

*   Postgres 有一个强类型模式，几乎没有出错的空间。首先为表创建模式，然后向表中添加行。您还可以使用规则定义不同表之间的关系，以便可以跨多个表存储相关数据并避免数据重复。所有这一切意味着团队中的某个人可以充当“数据库架构师”并控制模式，该模式充当其他人遵循的标准。

*   您可以在 PostgreSQL 中更改表，而不需要每次操作都锁定它。例如，您可以快速添加一列并设置默认值，而无需锁定整个表。这确保了表中的每一行都有该列，并且您的代码库保持干净，而不需要在每个阶段都检查该列是否存在。更新每一行也要快得多，因为 Postgres 不需要检索每一行，更新每一行，然后放回原处。

*   Postgres 还支持 JSONB，它允许您创建非结构化数据，但具有数据约束和验证功能，有助于确保 JSON 文档更有意义。Sisense 的人写了一篇很棒的博客，对 Postgres 和 MongoDB 的 JSON 文档进行了详细的比较。

*   我们的数据库大小减少了 10 倍，因为 Postgres 更高效地存储信息，并且数据不会不必要地跨表重复。

*   正如之前的研究所示，我们发现 Postgres 在索引和连接方面表现得更好，结果我们的服务变得更快更敏捷。自从迁移以来，我们对 Postgres 非常满意，我们不再为管理数据库而苦恼。结果，我们看到我们的 NPS 显著上升，因为客户对“始终工作”的平台更满意..

99.99%的可用性万岁！