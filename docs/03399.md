# 满足 NanoQueue 和模式依赖原则

> 原文:[https://dev . to/hakash/meet-nano queue-and-the-schema-dependency-principles-1e9f](https://dev.to/hakash/meet-nanoqueue-and-the-schema-dependency-principles--1e9f)

> **免责声明:**
> 
> *   这个项目目前处于稳定的 alpha 阶段，需要用例及贡献来开始成长。
> *   “模式依赖原则”这个名字很有意思。
> *   本文还将给出所提出观点的背景，因此 tldr 是:*模块化代码很酷，依赖项则不酷。依赖于信息模式，而不是类或命名模块！*

# [](#introduction)简介

NanoQueue 是我在为挪威的市政部门研究基于微服务的概念时产生的一个想法。它深受我们工作的消息驱动架构的影响，本身并不像许多框架声称的那样是任何问题的真正答案。

NanoQueue 是一个极简的消息代理和浏览器的模块注册表。目前它是用不到 70 行 JavaScript 实现的，包括空白行、花括号等等。

NanoQueue 的任务是帮助模块化您的代码，并将您的页面分割成更小的独立组件，最大限度地减少对外部的依赖。我相信使用合适的部件构建应用程序的原则，就像拼图一样，而不是购买庞大、笨重的框架来解决所有问题，制造你从来不知道自己遇到的新问题，并以前所未有的规模吸收移动数据。

让我们面对现实吧，前端之地是一个同时拥有壮丽的奇迹和难以言喻的恐怖的地方。

## [](#the-mission)使命

我参与合作的概念源于检查主数据管理的需要，我们很快发现了与此相关的越来越多的问题。我们看到的一些问题是我们的数据被供应商锁定，需要共享数据的系统之间不兼容，以及公共部门可用的巨型独石的绝对复杂性。

我们很快发现，杀死整体是最可行的前进方式，但是将整体分割成无数的微服务，这些微服务仍然紧密耦合并且彼此严重依赖，这让我们觉得很奇怪。此时，微服务是云领域的新宠，甚至 Docker 还不是一个真正的东西，或者只是在它的早期。

在这方面做了更多的工作后，我们得出结论，服务的依赖性应该在于它需要的数据，以及它输出的数据。在消息驱动的架构中，这是可能的，因为服务之间从不直接对话。他们只在公共消息代理上发布和订阅主题、队列或消息类型。通过使用像 AMQP 这样的标准协议，甚至可以在某种程度上放松对代理的依赖。

这将我们引向概念的核心: ***依赖于标准化消息中发布的信息模式，而不是服务或模块。**T3】*

主要的好处是，您可以用另一个部分替换任何一个部分，这个部分至少使用和产生相同的模式。当然，这个概念还有更多的内容，但这是它的核心，也是我试图带入前端空间的核心。

## [](#but-frontend)但是前端？

是的，这个核心原则在一个有许多组件共享数据和事件的网页上同样有价值，依赖于发生的事情或获取的数据，甚至是用户动作。

现在，这不是试图攻击，贬低或反对使用像 Redux，React，Vue，Angular 和类似的工具，因为他们都是以他们自己的方式和领域的伟大工具，他们绝对解决了很多问题。然而，它们可能相当复杂，并且经常被使用，只是因为这就是正在做的事情。

在许多情况下，您的组件需要的只是被告知相关数据的变更、相关事件，甚至是完成工作的请求。

### [](#state)状态

组件应该关心和处理自己的状态，并与依赖于该数据的其他组件共享其状态的变化。它应该只在发生内部事件时改变状态，并且当它接收到包含它关心的新的或更新的数据的消息时，应该发生内部事件来处理该数据并可能影响状态。

### [](#ui-components)UI 组件

所有组件都应该知道如何根据收到的消息或内部事件(如用户对组件本身的操作)来改变自己的外观。UI 组件应该只关心数据或交互元素的显示，而不知道数据是如何获取的，也不知道交互会发生什么。

这里的一些例外是组件中需要响应交互而发生的内部动作，如改变颜色、选中复选标记或其他类型的 UI 改变，以向用户指示他们确实与组件进行了交互。

### [](#nonui-components)非 UI 组件

这些组件通常是维护一些主数据记录的组件，是解决争端或诸如此类的当前事实。它们还执行后台任务，如与服务器对话、管理会话、cookies、本地存储等，执行计算、翻译、转换、解析或其他类型的基于请求的短期或长期运行的任务。充当传入数据的中间件，自动解析等。在发射结果之前，也将是一个伟大的应用。

## [](#nanoqueues-role)NanoQueue 的作用

NanoQueue 和其他类似的代理可以扮演的角色是处理消息传递的中心枢纽。正如我在介绍中所说的，NanoQueue 并没有真正解决问题，但是它为解决问题提供了便利。

我希望看到的是，我们可以建立一个社区来为特定类型的消息创建标准化的消息模式。

### [](#a-simple-example)一个简单的例子

让我们来看一个显示用户资料的组件。它需要像用户名，显示名称，电子邮件，个人资料图片等数据。有些概要文件自然比其他的更复杂，但是对于这个例子，我们将保持它的简单，并假设额外的数据可以在“模式扩展”或类似的中提供。

```
{  username:  "some_dev",  email:  "some_dev@email.some-dev.com",  display_name:  "Some Dev 👨‍💻",  profile_picture:  "http://some-dev.com/pic.png"  } 
```

可以使用类似于`general.user.profile.request`或类似的主题来请求这些数据。这种结构有助于轻松解析主题，为每个点增加特异性，并使在字典中查找内容变得非常容易。至少在某些服务器端消息代理中，这也是某种程度上的标准。

知道如何处理对用户配置文件的请求的组件将这样做，如果它还没有数据，就从服务器获取配置文件，并通过另一个消息返回它，例如使用像`general.user.profile`这样的主题使每个想要该数据的人都可以获得该数据。

一些确保只有发送方接收到响应的机制可以很容易地使用契约绑定回调来实现，组件生成的一次性主题如`general.callback.[some unique id]`在请求中作为回调地址给出。为了确保只有请求者可以订阅回复，NanoQueue 需要一点功能扩展，但这应该相对简单。

现在，消息本身可能看起来像下面这样:

**请求:**

```
{  publish_topic:  "general.user.profile.request",  data:  {  user:  "some user id"  },  callback_topic:  "general.callback.123456789"  } 
```

**公众反应:**

```
{  publish_topic:  "general.user.profile",  data:  {  username:  "some_dev",  email:  "some_dev@email.some-dev.com",  display_name:  "Some Dev 👨‍💻",  profile_picture:  "http://some-dev.com/pic.png"  }  } 
```

**与私回应:**

```
{  publish_topic:  "general.callback.123456789",  data:  {  username:  "some_dev",  email:  "some_dev@email.some-dev.com",  display_name:  "Some Dev 👨‍💻",  profile_picture:  "http://some-dev.com/pic.png"  }  } 
```

## [](#bonus-feature)奖励功能

作为一个额外的特性，NanoQueue 支持将角色作为模块注册表。如果您有一个依赖项，它是一个模块，而不是一个模式，或者希望尽可能地将 HTML 与 JavaScript 代码分开，那么您可以让模块在加载时向 NanoQueue 进行自注册，例如使用自执行匿名函数(我见过的另一个名称是立即调用匿名函数)在脚本加载时加载模块。

然后，您可以使用模块名称:
来访问模块

```
const myModule = _Q.getModule("myModule"); 
```

这也避免了你用大量的模块和随机变量来破坏窗口对象。您可以在一个地方找到您的数据和依赖项。只有 NanoQueue 需要通过窗口对象进行全局访问。

## [](#conclusion)结论

我还没有到目前为止，在这个项目中，但经纪人的工作。概念是制定的，但不是实施的。NanoQueue 生活在 GitHub 上的 repo 中:

## ![GitHub logo](../Images/375dfcc32199b4dedf2b526645c27ff7.png) [哈卡什](https://github.com/hakash) / [纳米队列](https://github.com/hakash/nanoqueue)

### 页面上组件间消息传递的最小发布/订阅消息代理

<article class="markdown-body entry-content p-5" itemprop="text">

# 纳米队列

最小的发布/订阅消息代理和模块注册表，用于页面上组件之间的消息传递。参见[https://nanoqueue.dittdesign.com](https://nanoqueue.dittdesign.com/example1.html)中的一个使用实例。

* * *

## 介绍

NanoQueue 是一个极简的消息代理和模块注册表，用于分离网页上的模块和组件。

NanoQueue 在全局`window`对象中将自己注册为`NanoQueue`，并使用缩写`_Q`。访问框架就像`window.NanoQueue`、`window._Q`一样简单，或者最简单的形式就是`_Q`。

### 信息发送

NanoQueue 主要用于在组件之间发送消息，让您有一个简单的方法来确保难以到达的组件获得它们的状态更新。您还可以注册多个组件来订阅相同的主题，这样您就可以非常容易地一次向许多接收者发送相同的信息。

这种架构作为“发布/订阅”架构或消息驱动架构在云原生、微服务和扩展领域广为人知。

正在工作…

</article>

[View on GitHub](https://github.com/hakash/nanoqueue)

我猜标准化的消息模式和整个概念应该在某个地方有自己的空间，并且可能有一些工具来验证模式。

我乐于接受建议和评论，贡献和合作者，他们可以帮助我阐明这个概念并传播这个词。

感谢您的阅读！