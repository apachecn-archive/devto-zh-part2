# 内存高效的数据结构

> 原文:[https://dev . to/fros nerd/memory-efficient-data-structures-2hki](https://dev.to/frosnerd/memory-efficient-data-structures-2hki)

# [](#introduction)简介

RUM 系列的[第一篇博文](https://dev.to/frosnerd/rum-conjecture---reasoning-about-data-access-4781)介绍了 RUM 猜想。它描述了在设计数据结构和访问方法时应该考虑的读取(RO)、更新(UO)和内存(MO)开销之间的权衡。

在这篇文章中，我们想仔细看看两种为低空间开销设计的数据结构:Bloom filters 和 bitmap indexes。

这篇博文是朗姆酒系列的第四部分:

1.  [RUM 猜想——关于数据访问的推理](https://dev.to/frosnerd/rum-conjecture---reasoning-about-data-access-4781)
2.  [读取高效的数据结构](https://dev.to/frosnerd/read-efficient-data-structures-57i5)
3.  [更新高效的数据结构](https://dev.to/frosnerd/update-efficient-data-structures-7cn)
4.  [内存高效的数据结构](#)

博客的结构如下。首先，我们将回顾最初博客文章中的内存优化解决方案，并激励我们如何在牺牲结果正确性的同时实现更好的内存开销。下一节介绍 Bloom filters，这是一种近似的数据结构，旨在降低和调整内存开销。之后，我们将讨论位图索引，它代表了一种以内存高效的方式编码数据并支持快速多维查询的方法。接下来，我们将总结这篇文章的主要观点。我们将在最后一节结束朗姆酒系列。

# [](#memoryoptimal-solution)记忆-最优解

实现恒定内存开销的最简单方法是不存储辅助数据。在我们的整数集示例中，内存优化实现将所有整数存储在一个大小正好符合要求的数组中，并根据需要调整数组的大小。我们得出以下朗姆酒管理费用:

*   ro≤n
*   *UO ≤ N + 2*
*   *MO = 1*

在这个实现中，当对整数进行排序时，我们可以权衡读取开销和更新开销。这允许二分搜索法，但要求在插入时保持顺序。另一种方法是使用压缩，这样可以减少内存需求。然而，它可以应用于任何数据结构，详细讨论超出了本文的范围。

然而在实践中，我们通常没有太严格的内存要求，因为在过去的几十年里，存储变得越来越便宜。对于大多数用例，使用哈希表或其他读取效率高的数据结构具有合理的内存开销。这就是为什么在下一节中，我们要研究一种内存开销小于 1 的数据结构。

# [](#bloom-filters)Bloom 滤镜

## [](#concept)概念

布隆过滤器[1]是一种节省空间的近似数据结构。如果甚至一个加载良好的散列表都不适合内存，并且我们需要持续的读访问，那么就可以使用它。然而，由于其近似性质，人们必须意识到假阳性是可能的，即成员资格请求可能返回真，尽管该元素从未被插入到集合中。

布隆过滤器背后的思想类似于哈希表。第一个区别是，我们不是为整数数组保留空间，而是分配一个由 *m* 位组成的数组。其次，我们利用不是一个而是 *k* 个独立的散列函数。每个散列函数取集合中的一个(潜在的)元素，并在位数组中产生一个位置。

[![bloom filter illustration](../Images/bac44c4f8532389553dc2afe11ed992c.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--Iv8w9lvT--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/tgp11bpflakmwhzlwtdd.png)

最初，所有位都设置为 0。为了向集合中插入一个新值，我们使用每个 *k* 散列函数来计算它的散列值。然后，我们将相应位置的所有位设置为 1。

成员资格查询还会计算所有哈希值，并检查每个位置的位。如果所有位都设置为 1，我们返回 true，有一定的正确概率。如果我们看到至少一个 0，我们就可以确定这个元素不是集合的成员。

误报的概率取决于哈希函数的数量 *k* ，位数组的大小 *m* ，以及已经插入布隆过滤器的元素数量 *n* 。假设所有位都独立设置，则误报率 *FP* 可以近似为

[![false positive rate formula](../Images/2e26f8f0f8ebae5f27f71ebebbdd7761.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--xhgA0gIi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/ea5iz4sisnkfy0fbh0s1.png)

对于已经插入了 100 万比特、5 个散列函数和 100k 个元素的布隆过滤器，我们得到 *FP ≈ 1%* 。如果你想自己摆弄这些变量，可以看看托马斯·赫斯特的这个很棒的[布鲁姆过滤器计算器](https://hur.st/bloomfilter)。

除了可能存在假阳性的事实之外，一个很大的缺点是不支持删除。我们不能简单地将要删除的元素的所有位置都设置为 0，因为我们不知道在插入其他元素时是否有哈希冲突。嗯，我们甚至不能确定我们试图删除的元素是否在布隆过滤器中，因为它可能是误报。

那么 Bloom filters 在实践中有什么用呢？一个用例是网络爬行。为了避免重复工作，爬虫需要在跟随一个链接之前确定他是否已经访问过一个站点。布隆过滤器是完美的，因为在内存中存储所有访问过的网站实际上是不可能的。此外，如果我们得到一个误报，这意味着我们没有访问一个网站，尽管它以前没有被访问过。如果爬虫的输出被用作搜索引擎的输入，我们真的不介意，因为排名高的网站很可能不会只有一个输入链接，因此我们有机会再次看到它。

另一个用例是在数据库中。Bloom filters 与 LSM 树结合使用，我们已经从之前的博客文章中知道了。当执行读取操作时，我们可能需要检查日志的每个级别。我们可以使用布隆过滤器来有效地检查我们正在寻找的密钥是否存在于每个块中。如果 Bloom filter 告诉我们密钥不存在，我们可以确定并且不必接触该块，这对于通常存储在磁盘上的更高级别非常有用。

## [](#rum-overheads)朗姆酒饮料

布隆过滤器的 RUM 开销类似于散列表的开销。读取和更新开销都对应于没有冲突解决的哈希表中的开销。然而，计算哈希函数的开销是使用 *k* 哈希函数的 *k* 倍。

存储开销取决于元素大小，即存储的元素越大，效果越大，以及滤波器的负载系数。对于存储在 1 MB 布隆过滤器中的 100k 32 位整数值，我们得到大约 0.33 的存储器开销。

# [](#bitmap-indexes)位图索引

## [](#concept)概念

位图索引[2]是数据库索引中常用的数据结构。与布隆过滤器类似，位图索引基于位数组，也称为位图。

从概念上讲，位图索引是一组位数组，它们将数据库列的值编码在一个逻辑位向量中。对于每个可能的值，我们存储一个列大小的位数组。让我们看一个布尔列的例子。表中的第一列表示原始值。第二和第三列是每个可能值的位数组。如果该值未设置，我们只需将所有位保留为 0。

| 布尔代数学体系的 | 真实的 | 错误的 |
| --- | --- | --- |
| `True` | `1` | `0` |
| `False` | `0` | `1` |
| `Null` | `0` | `0` |

这意味着我们将`True`表示为`[1, 0]`、`False`表示为`[0, 1]`、`Null`表示为`[0, 0]`。我们也可以将这个过程推广到更高基数的列。

我们从中获得了什么？位图索引背后的主要动机是通过使用按位逻辑操作有效地回答多维查询的可能性。如果我们想知道所有住在德国并拥有高级合同的客户，我们只需使用成对的`and`组合`Germany`和`premium`位数组。此外，位图索引比 B 树索引或类似的数据结构具有更少的空间开销。

一个缺点是，只有当基数相当低时，低内存开销效果才有效。此外，原始列中的更新需要更新所有位图。因此，当应用于只读数据时，性能是最佳的，例如在数据仓库应用中。

## [](#rum-overheads)朗姆酒饮料

使用位图索引来实现一组整数并不是一个好主意。如果基数太高，您需要先执行宁滨。为了便于讨论，现在让我们考虑一组字符串。

由于位图只是编码原始数据的一种不同方式，读取开销与列中的元素数量成正比。如果我们要寻找一个特定的值，比如说`Frank`，我们必须扫描整个`Frank`位数组来寻找 1。由于插入元素需要调整位数组的大小，更新开销同样很高。

就内存开销而言，我们将基数为 *c* 的 *n* 值表示为一个 *n×c* 位矩阵。内存开销不仅取决于基数，还取决于原始值的大小。

假设我们想要代表美利坚合众国的一组州。如果我们将它们存储为 256 个 ASCII 字符长字符串的数组，这将意味着每个状态现在占用 50 位，而不是 256 字节。这种表示的额外内存开销将是 *50 / (256 ⋅ 8) ≈ 0.02* ，具有高效多维查询的效果。这个计算有点不可靠，因为有人可能会说，计算基本数据消耗的内存时，应该考虑最有效的编码。不过，我希望你能明白。

# [](#summary)总结

在这篇博文中，我们已经看到 Bloom filters 是一种通过牺牲一点正确性来改善最优内存开销的方法。位图索引是一个很好的例子，说明了我们如何在不增加太多额外内存开销的情况下获得索引提供的一些好处。

你在一个项目中使用过布隆过滤器或者其他近似的数据结构/扩展来布隆过滤器吗？你是如何确定散列函数的数量和过滤器的大小的？您是否在运行时监控假阳性率？

# [](#closing-words)结束语

在 RUM 系列中，我想阐明在设计或推理数据结构和访问模式时所面临的不同权衡。在比较不同的实现时，考虑读取、更新和内存开销有助于更好地理解差异，甚至为您的工作选择正确的实现。我还想概述一下现有的不同数据结构，尤其是在 RUM 猜想的背景下。

在岗位上工作期间，我学到了很多东西。我对一些数据结构的内部细节不太熟悉。阅读报纸很有趣，我也很喜欢我亲自参与的讨论和目前为止的评论，我期待着未来的讨论。感谢大家的反馈，敬请关注即将发布的博文。

# [](#references)参考文献

*   [1]布鲁姆博士，1970 年。具有容许误差的散列编码中的空间/时间权衡。《美国计算机协会通讯》，第 13 卷第 7 期，第 422-426 页。
*   [2]斯皮格勒、伊斯雷尔和拉菲·马扬。"二进制数据库的存储和检索考虑."信息处理与管理 21.3 (1985): 233-254。
*   封面图片:par lplt 个人作品，CC BY-SA 3.0，[https://commons . wikimedia . org/w/index . PHP？curid = 2656862](https://commons.wikimedia.org/w/index.php?curid=26568662)